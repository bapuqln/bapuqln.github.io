<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AddTwoNumber</title>
    <url>/2019/11/22/AddTwoNumber/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://leetcode.com/problems/add-two-numbers/">AddTwoNumbers</a> You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li><code>2</code> 个 <code>非空</code>链表，长度可能不相等</li>
<li>每个链表为<code>逆序</code></li>
<li>返回两个链表的和</li>
<li>每个元素应该为正数</li>
</ul>
<h3 id="理解例子">理解例子</h3>
<ul>
<li><code>2 -&gt; 4 -&gt; 3</code> = <code>342</code></li>
<li><code>5 -&gt; 6 -&gt; 4</code> = <code>465</code></li>
<li><code>342 + 465 = 807</code></li>
<li>答案 : <code>7 -&gt; 0 -&gt; 8</code></li>
</ul>
<h3 id="思路">思路</h3>
<ul>
<li>将每一个链表变成整形，然后相加，结果分解成链表不大合适，还得处理越界的情况</li>
<li>比较合理的办法：是一边遍历一边生成链表</li>
<li>每一个生成的节点为两个数的和，有可能产生进位: 如 <code>7+8=15</code></li>
<li>一个节点的结果为：<code>sum = 前一个节点的进位+两个节点的和</code>，<code>res = sum % 10</code>;</li>
<li>一个节点的结果几种情况
<ul>
<li><code>last_carry + left + right &lt; 10</code></li>
<li><code>last_carry + left + right &gt;= 10</code></li>
<li><code>只要有进位，就一定会有一个新的节点出现</code></li>
</ul></li>
</ul>
<h3 id="代码">代码</h3>
<h4 id="非递归">非递归</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode *head = &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + carry;</span><br><span class="line">            head-&gt;next = <span class="keyword">new</span> ListNode (sum % <span class="number">10</span>);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l2) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">var</span> val: <span class="type">Int</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">var</span> next: <span class="type">ListNode?</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> val: <span class="type">Int</span>) &#123;</span><br><span class="line">     <span class="keyword">self</span>.val = val</span><br><span class="line">     <span class="keyword">self</span>.next = <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(<span class="number">_</span> l1: ListNode?, <span class="number">_</span> l2: ListNode?)</span></span> -&gt; <span class="type">ListNode?</span> &#123;</span><br><span class="line">    	<span class="keyword">var</span> l1 = l1</span><br><span class="line">        <span class="keyword">var</span> l2 = l2</span><br><span class="line">        <span class="keyword">var</span> prev = <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> head = prev</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l1 != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> || carry != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> cur = <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">let</span> sum = (l2 == <span class="literal">nil</span> ? <span class="number">0</span> : l2!.val) + (l1 == <span class="literal">nil</span> ? <span class="number">0</span> : l1!.val) + carry</span><br><span class="line">            cur.val = sum % <span class="number">10</span></span><br><span class="line">            carry = sum / <span class="number">10</span></span><br><span class="line">            prev.next = cur</span><br><span class="line">            prev = cur</span><br><span class="line">            l1 = l1 == <span class="literal">nil</span> ? l1: l1?.next</span><br><span class="line">            l2 = l2 == <span class="literal">nil</span> ? l2: l2?.next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归">递归</h4>
<p>这道题比较简单，递归模式也比较好想到 加法需要三个值，两个操作符（来自两个链表）以及一个进位标记。 因此递归模式为：</p>
<ul>
<li>递归出口：两个链表都已经到达末尾，并且没有进位</li>
<li>递归实现：
<ul>
<li>当前节点的结果为：和/10</li>
<li>当前节点的next节点为：对于两个链表next节点的计算的结果</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2, <span class="keyword">int</span> carry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1 &amp;&amp; !l2 &amp;&amp; !carry) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = (l1?l1-&gt;val:<span class="number">0</span>) + (l2?l2-&gt;val:<span class="number">0</span>) + carry;</span><br><span class="line">        ListNode *ans = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        ans-&gt;next = addTwoNumbers(l1?l1-&gt;next:<span class="literal">nullptr</span>, l2?l2-&gt;next:<span class="literal">nullptr</span>, sum / <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addTwoNumbers(l1, l2, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度">时间复杂度</h3>
<p>遍历次数：<code>max(len(l1), len(l2)) + 1</code>，因此是线性时间 \(\)</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p>额外申请了和一个链表，因此空间复杂度也为 \(\)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>Basic Calculator</title>
    <url>/2020/06/12/BasicCalculator/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://leetcode.com/problems/basic-calculator/">Basic Calculator</a> Implement a basic calculator to evaluate a simple expression string.</p>
<p>The expression string may contain open ( and closing parentheses ), the plus + or minus sign -, non-negative integers and empty spaces .</p>
<p>Example 1: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">&quot;1 + 1&quot;</span></span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure></p>
<p>Example 2: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">&quot; 2-1 + 2 &quot;</span></span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure></p>
<p>Example 3: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">&quot;(1+(4+5+2)-3)+(6+8)&quot;</span></span><br><span class="line">Output: 23</span><br></pre></td></tr></table></figure></p>
<p>Note: You may assume that the given expression is always valid. Do not use the eval built-in library function.</p>
<a id="more"></a>
<h2 id="解题报告">解题报告</h2>
<h3 id="思路">思路</h3>
<ul>
<li>看到这种模式肯定要用到栈 <code>stack</code></li>
<li>会有括号的处理，这块可能会复杂点，因为有可能会导致计算优先级改变。</li>
<li>说白了就是将整个过程看为求和，每个数分配一个操作符，用来求和</li>
<li>分析例子可以知道 &gt; * 每一个数字都会消耗掉一个符号(+、-) &gt; <em> 每一个数字都会产生一个新的符号(+, -) &gt; </em> 每一个 <code>(</code> 都会复制当前的符号，这样的话他就能给该操作范围内的第一个数用， &gt; * 每一个 <code>)</code> 都会关闭当前的操作范围，因此会丢弃掉当前的符号</li>
</ul>
<h2 id="代码">代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 2 sign</span></span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sign</span><span class="params">(<span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length();i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span> (i &lt; s.size() &amp;&amp; <span class="built_in">isdigit</span>(s[i]))</span><br><span class="line">                    n = n * <span class="number">10</span> + (s[i++] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                ans += sign.back() * n;</span><br><span class="line">                sign.pop_back();</span><br><span class="line">                i--;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                sign.pop_back();</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                sign.push_back(sign.back() * (c == <span class="string">&#x27;-&#x27;</span> ? <span class="number">-1</span> : <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="例子">例子</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> remaining   sign <span class="built_in">stack</span>      total</span><br><span class="line"><span class="number">3</span>-(<span class="number">2</span>+(<span class="number">9</span><span class="number">-4</span>))   [<span class="number">1</span>, <span class="number">1</span>]            <span class="number">0</span></span><br><span class="line"> -(<span class="number">2</span>+(<span class="number">9</span><span class="number">-4</span>))   [<span class="number">1</span>]               <span class="number">3</span></span><br><span class="line">  (<span class="number">2</span>+(<span class="number">9</span><span class="number">-4</span>))   [<span class="number">1</span>, <span class="number">-1</span>]           <span class="number">3</span></span><br><span class="line">   <span class="number">2</span>+(<span class="number">9</span><span class="number">-4</span>))   [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>]       <span class="number">3</span></span><br><span class="line">    +(<span class="number">9</span><span class="number">-4</span>))   [<span class="number">1</span>, <span class="number">-1</span>]           <span class="number">1</span></span><br><span class="line">     (<span class="number">9</span><span class="number">-4</span>))   [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>]       <span class="number">1</span></span><br><span class="line">      <span class="number">9</span><span class="number">-4</span>))   [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>]   <span class="number">1</span></span><br><span class="line">       <span class="number">-4</span>))   [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>]      <span class="number">-8</span></span><br><span class="line">        <span class="number">4</span>))   [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>]   <span class="number">-8</span></span><br><span class="line">         ))   [<span class="number">1</span>, <span class="number">-1</span>, <span class="number">-1</span>]      <span class="number">-4</span></span><br><span class="line">          )   [<span class="number">1</span>, <span class="number">-1</span>]          <span class="number">-4</span></span><br><span class="line">              [<span class="number">1</span>]              <span class="number">-4</span></span><br></pre></td></tr></table></figure>
<h2 id="另一种解法">另一种解法</h2>
<h3 id="思路-1">思路</h3>
<ul>
<li>括号内优先计算</li>
<li>碰到 <code>(</code> ,将计算结果和操作符入栈</li>
<li>碰到数字就带着符号计算结果。</li>
</ul>
<h3 id="代码-1">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> l = s.length();</span><br><span class="line">        <span class="keyword">int</span> sign = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk_;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; l; i++) &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">isdigit</span>(c)) &#123;</span><br><span class="line">                <span class="keyword">int</span> d = c - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                <span class="keyword">while</span> (i+<span class="number">1</span> &lt; l &amp;&amp; <span class="built_in">isdigit</span>(s[i+<span class="number">1</span>])) &#123;</span><br><span class="line">                    d = d * <span class="number">10</span> + (s[++i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ans += d * sign;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span> || c == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                sign = c == <span class="string">&#x27;+&#x27;</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                stk_.push(ans);</span><br><span class="line">                stk_.push(sign);</span><br><span class="line">                ans = <span class="number">0</span>;</span><br><span class="line">                sign = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">                ans *= stk_.top(); stk_.pop();</span><br><span class="line">                ans += stk_.top(); stk_.pop();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>Best Time To Buy Sell Stock IV</title>
    <url>/2020/06/07/BestTimeToBuyAndSellStockIV/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/">Best Time to Buy and Sell Stock IV</a> Say you have an array for which the i-th element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete at most k transactions.</p>
<p>Note: You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p>Example 1: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: [2,4,1], k = 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.</span><br></pre></td></tr></table></figure> Example 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: [3,2,6,5,0,3], k = 2</span><br><span class="line">Output: 7</span><br><span class="line">Explanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4.</span><br><span class="line">             Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解题报告">解题报告</h2>
<h3 id="思路">思路</h3>
<ul>
<li>获取收益肯定应该在地点买入，高点卖出，假定 <code>vally</code> 表示低价格的索引，<code>peak</code> 表示高价格的索引，因此 <code>(v1, p1)</code> 和 <code>(v2, p2)</code> 表示两个连续的 <code>valley-peak</code> 的价格。考虑如下两个 case *<code>prices[v1] &lt;= prices[v2] &amp;&amp; prices[p1] &lt;= prices[p2]</code>，在该条件下，如果只能交易一次，那就是<code>(v1, p2)</code>。 如果是两个交易，那就是<code>(v1, p1)</code> 和 <code>(v2, p2)</code>。为了省事，将<code>(v1, p2)</code>看做为第一个交易，<code>(v2, p1)</code> 看做第二个交易.</li>
<li><code>prices[v1] &gt;= prices[v2] || prices[p1] &gt;= prices[p2]</code>，在该条件下，如果只能交易一次，要么就用<code>(v1,p1)</code>，要么就用 <code>(v2,p2)</code>。如果是两次交易，就全部使用。</li>
</ul>
<h3 id="步骤">步骤</h3>
<ul>
<li>找到全部的交易，并且记录每一笔的收益，使用 <code>stack</code> 记录每一对 <code>vally-peak</code> 。并且保证 <code>vally</code> 是按照升序排列。所有的收益都放在 <code>vector</code> 数组中，时间复杂度为 <code>O(n)</code>.</li>
<li>找到前 <code>k</code> 个交易收益，时间复杂度为 <code>O(n)</code></li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span></span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = prices.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; profits;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; vps; <span class="comment">// vally-peak pairs</span></span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">0</span>, p = <span class="number">-1</span>; <span class="comment">// padding p , so not using p-1</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// find next vally and peak</span></span><br><span class="line">            <span class="keyword">for</span> (v = p+<span class="number">1</span>; v+<span class="number">1</span> &lt; m &amp;&amp; (prices[v] &gt;= prices[v+<span class="number">1</span>]); v++);</span><br><span class="line">            <span class="keyword">for</span> (p = v;   p+<span class="number">1</span> &lt; m &amp;&amp; (prices[p] &gt;= prices[p<span class="number">-1</span>]); p++);</span><br><span class="line">            <span class="keyword">if</span> (v == p) <span class="keyword">break</span>; <span class="comment">// to the end of prices</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// v &lt; p</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// (v1,p1) (v2,p2)</span></span><br><span class="line">            <span class="comment">// if (prices[v1] &gt;= prices[v2]) no need to combine two transactions</span></span><br><span class="line">            <span class="comment">// after å top is (v1,p2), push p2-v1 into profit --&gt; step ∑</span></span><br><span class="line">            <span class="keyword">while</span> (!vps.empty() &amp;&amp; (prices[v] &lt;= prics[vps.top().first])) &#123;</span><br><span class="line">                profits.push_back(prices[vps.top().second] - prices[vps.top().first]);</span><br><span class="line">                vps.pop();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// (v1, p1) (v2,p2)</span></span><br><span class="line">            <span class="comment">// if (prices[v1] &lt; prices[v2] &amp;&amp; prices[p1] &lt; prices[p2]) we need to combine two transactions</span></span><br><span class="line">            <span class="comment">// update (v1,p1) --&gt; (v1, p2)</span></span><br><span class="line">            <span class="comment">// p2-v2 + p1-v1 == p2-v1 + p1-v2</span></span><br><span class="line">            <span class="comment">// after step ∑ top is (v1, p2)</span></span><br><span class="line">            <span class="keyword">while</span> (!vps.empty() &amp;&amp; (prices[p] &gt;= prices[vps.top().second])) &#123;</span><br><span class="line">                <span class="comment">// save profit (v2, p1)</span></span><br><span class="line">                profits.push_back(prices[vps.top().second] - prices[v]);</span><br><span class="line">                <span class="comment">// v1 --&gt; v</span></span><br><span class="line">                v = vps.top()first;</span><br><span class="line">                vps.pop();</span><br><span class="line">                <span class="comment">// v is v1</span></span><br><span class="line">                <span class="comment">// p is p2</span></span><br><span class="line">                <span class="comment">// step å</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// if step å  (v1, p2) is top of vps</span></span><br><span class="line">            vps.push(<span class="built_in">make_pair</span>(v, p));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate all the profits</span></span><br><span class="line">    <span class="keyword">while</span> (!vps.empty()) &#123;</span><br><span class="line">        profits.push_back(prices[vps.top().second] - prices[vps.top().first]);</span><br><span class="line">        vps.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// calculate k highest profitœ</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> n = profits.size();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; = k) &#123;</span><br><span class="line">        accumulate(profits.begin(), profits.end(), <span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        nth_element(profits.begin(), profits.end() - k, profits.end());</span><br><span class="line">        accumulate(profits.end() - k,profit.end(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>BinaryGap</title>
    <url>/2020/10/11/BinaryGap/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://app.codility.com/demo/results/trainingUFUBUW-TAQ/">BinaryGap</a> A binary gap within a positive integer N is any maximal sequence of consecutive zeros that is surrounded by ones at both ends in the binary representation of N.</p>
<p>For example, number 9 has binary representation 1001 and contains a binary gap of length 2. The number 529 has binary representation 1000010001 and contains two binary gaps: one of length 4 and one of length 3. The number 20 has binary representation 10100 and contains one binary gap of length 1. The number 15 has binary representation 1111 and has no binary gaps. The number 32 has binary representation 100000 and has no binary gaps.</p>
<p>Write a function:</p>
<p>int solution(int N);</p>
<p>that, given a positive integer N, returns the length of its longest binary gap. The function should return 0 if N doesn't contain a binary gap.</p>
<p>For example, given N = 1041 the function should return 5, because N has binary representation 10000010001 and so its longest binary gap is of length 5. Given N = 32 the function should return 0, because N has binary representation '100000' and thus no binary gaps.</p>
<p>Write an efficient algorithm for the following assumptions:</p>
<p>N is an integer within the range [1..2,147,483,647]. Copyright 2009–2020 by Codility Limited. All Rights Reserved. Unauthorized copying, publication or disclosure prohibited.</p>
<a id="more"></a>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>给定十进制数字，求最大的二进制的 <code>gap</code>。</li>
<li><code>gap</code> 必须是在两个 1 之间</li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> found = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (N) &#123;</span><br><span class="line">        <span class="keyword">while</span> (N &amp;&amp; (N &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            found = <span class="literal">true</span>;</span><br><span class="line">            N &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (N &amp;&amp; !(N &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            N &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (found)</span><br><span class="line">            ans = max(ans, count);</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度">时间复杂度</h3>
<p><code>O(N)</code></p>
]]></content>
      <categories>
        <category>Codility</category>
      </categories>
      <tags>
        <tag>Codility</tag>
      </tags>
  </entry>
  <entry>
    <title>BinaryTree</title>
    <url>/2020/06/29/BinaryTree/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="二叉树总结">二叉树总结</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right</span><br><span class="line">    TreeNode(<span class="keyword">int</span> v): value(v),left(<span class="literal">nullptr</span>), right(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="遍历二叉树">遍历二叉树</h3>
<h4 id="前序遍历">前序遍历</h4>
<ul>
<li>递归</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;preOrderTraversal(TreeNode* tree) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        function&lt;<span class="keyword">void</span>(TreeNode *)&gt; preOrderTraversalHelper = [&amp;](TreeNode *node)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">            ans.push_back(node-&gt;val);</span><br><span class="line">            preOrderTraversalHelper(node-&gt;left);</span><br><span class="line">            preOrderTraversalHelper(node-&gt;right)</span><br><span class="line">        &#125;;</span><br><span class="line">        preOrderTraversalHelper(tree);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>非递归</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;preOrderTraversal(TreeNode *node)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; stk_;</span><br><span class="line">        stk_.push(node);</span><br><span class="line">        <span class="keyword">while</span> (!stk_.empty()) &#123;</span><br><span class="line">            TreeNode *root = stk_.top();</span><br><span class="line">            stk_.pop();</span><br><span class="line">            ans.(root-&gt;value);</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">                stk_.push(root-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">                stk_.push(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;push_back</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">        TreeNode* cur = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">                cur = root-&gt;right;</span><br><span class="line">                <span class="keyword">while</span> (cur-&gt;left &amp;&amp; cur-&gt;left != root) &#123;</span><br><span class="line">                    cur = cur-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (cur-&gt;left == root) &#123;</span><br><span class="line">                    cur-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">                    root = root-&gt;left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    nums.push_back(root-&gt;val);</span><br><span class="line">                    cur-&gt;left = root;</span><br><span class="line">                    root = root-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                nums.push_back(root-&gt;val);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历">中序遍历</h3>
<ul>
<li>递归</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">inOrderTraversal</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        function&lt;<span class="keyword">void</span>(TreeNode *)&gt; inOrderTraversalHelper = [&amp;](TreeNode * root)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">            inOrderTraversalHelper(root-&gt;left)</span><br><span class="line">            ans.push_back(root-&gt;val);</span><br><span class="line">            inOrderTraversalHelper(root-&gt;right);</span><br><span class="line">        &#125;;</span><br><span class="line">        inOrderTraversalHelper(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>非递归</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;inOrderTraversal(TreeNode *root)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; stk_;</span><br><span class="line">        <span class="keyword">while</span> (root || !stk_.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root) &#123;</span><br><span class="line">                stk_.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk_.top(); stk_.pop();</span><br><span class="line">            ans.push_back(root-&gt;value);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历">后序遍历</h3>
<ul>
<li>递归</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postOrderTraversal</span><span class="params">(TreeNode *node)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        function&lt;<span class="keyword">void</span>(TreeNode *)&gt;postOrderTraversalHelper = [&amp;](TreeNode *root)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!root) <span class="keyword">return</span>;</span><br><span class="line">            postOrderTraversal(root-&gt;left);</span><br><span class="line">            postOrderTraversal(root-&gt;right);</span><br><span class="line">            ans.push_back(root);</span><br><span class="line">        &#125;;</span><br><span class="line">        postOrderTraversal(node);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>非递归 &gt; two stack <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postOrderTraversal</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt; stk_, _stk;</span><br><span class="line">        stk_.push(root);</span><br><span class="line">        TreeNode *node = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stk_.empty()) &#123;</span><br><span class="line">            node = stk_.top();stk_.pop();</span><br><span class="line">            _stk.push(node);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">                stk_.push(node-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">                stk_.push(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!_stk.empty()) &#123;</span><br><span class="line">            ans.push_back(_stk.top());</span><br><span class="line">            _stk.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>one stack, 需要记录上一个输出的节点的指针， <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postOrderTraversal</span><span class="params">(TreeNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode *&gt;stk_;</span><br><span class="line">        TreeNode *last = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (root || !stk_.empty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (root) &#123;</span><br><span class="line">                stk_.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                TreeNode *node = stk_.top();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right &amp;&amp; last != node-&gt;right) &#123;</span><br><span class="line">                    root = node-&gt;right;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ans.push_back(node-&gt;value);</span><br><span class="line">                    last = node;</span><br><span class="line">                    stk_.pop();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>Morris Traversal O(n) time O(1) space</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nodes;</span><br><span class="line">        TreeNode* dummy = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">        dummy -&gt; left = root;</span><br><span class="line">        TreeNode* cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur -&gt; left) &#123;</span><br><span class="line">                TreeNode* pre = cur -&gt; left;</span><br><span class="line">                <span class="keyword">while</span> (pre -&gt; right &amp;&amp; (pre -&gt; right != cur)) &#123;</span><br><span class="line">                    pre = pre -&gt; right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!(pre -&gt; right)) &#123;</span><br><span class="line">                    pre -&gt; right = cur;</span><br><span class="line">                    cur = cur -&gt; left;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    reverseAddNodes(cur -&gt; left, pre, nodes);</span><br><span class="line">                    pre -&gt; right = <span class="literal">NULL</span>;</span><br><span class="line">                    cur = cur -&gt; right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur -&gt; right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nodes;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseNodes</span><span class="params">(TreeNode* start, TreeNode* end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* x = start;</span><br><span class="line">        TreeNode* y = start -&gt; right;</span><br><span class="line">        TreeNode* z;</span><br><span class="line">        <span class="keyword">while</span> (x != end) &#123;</span><br><span class="line">            z = y -&gt; right;</span><br><span class="line">            y -&gt; right = x;</span><br><span class="line">            x = y;</span><br><span class="line">            y = z;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reverseAddNodes</span><span class="params">(TreeNode* start, TreeNode* end, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nodes)</span> </span>&#123;</span><br><span class="line">        reverseNodes(start, end);</span><br><span class="line">        TreeNode* node = end;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            nodes.push_back(node -&gt; val);</span><br><span class="line">            <span class="keyword">if</span> (node == start) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node -&gt; right;</span><br><span class="line">        &#125;</span><br><span class="line">        reverseNodes(end, start);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>位操作</title>
    <url>/2020/08/11/BitManupulate/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><a id="more"></a></p>
<h1 id="位操作总结">位操作总结</h1>
<p>基本上位操作就那么几个:</p>
<h2 id="异或的特性">异或的特性</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x ^ <span class="number">0</span> = x</span><br><span class="line"></span><br><span class="line">x ^ <span class="number">11111</span>……<span class="number">1111</span> = ~x</span><br><span class="line"></span><br><span class="line">x ^ (~x) = <span class="number">11111</span>……<span class="number">1111</span></span><br><span class="line"></span><br><span class="line">x ^ x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">a ^ b = c =&gt; a ^ c = b =&gt; b ^ c = a (交换律) a ^ b ^ c = a ^ (b ^ c) = (a ^ b）^ c (结合律)</span><br></pre></td></tr></table></figure>
<h2 id="构造特殊的mask">构造特殊的Mask</h2>
<ul>
<li>将 <code>x</code> 最右边的 <code>n</code> 位清零， <code>x &amp; ( ~0 &lt;&lt; n )</code></li>
<li>获取 <code>x</code> 的第 <code>n</code> 位值(0 或者 1)，<code>(x &gt;&gt; n) &amp; 1</code></li>
<li>获取 <code>x</code> 的第 <code>n</code> 位的幂值，<code>x &amp; (1 &lt;&lt; (n - 1))</code></li>
<li>仅将第 <code>n</code> 位置为 <code>1</code>，<code>x | (1 &lt;&lt; n)</code></li>
<li>仅将第 <code>n</code> 位置为 <code>0</code>，<code>x &amp; (~(1 &lt;&lt; n))</code></li>
<li>将 <code>x</code> 最⾼位⾄第 <code>n</code> 位(含)清零，<code>x &amp; ((1 &lt;&lt; n) - 1)</code></li>
<li>将第 <code>n</code> 位⾄第 <code>0</code> 位(含)清零，<code>x &amp; (~((1 &lt;&lt; (n + 1)) - 1)</code></li>
</ul>
<h2 id="section"></h2>
<p><code>X &amp; 1 == 1</code> 判断是否是奇数(偶数) <code>X &amp; = (X - 1)</code> 将最低位(LSB)的 1 清零 <code>X &amp; -X</code> 得到最低位(LSB)的 1</p>
<p><code>X &amp; ~X = 0</code></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Bit Manupulate</tag>
      </tags>
  </entry>
  <entry>
    <title>Boyer Moore Majority Vote Algorithm</title>
    <url>/2019/11/22/BoyerMooreMajorityVoteAlgorithm/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://leetcode.com/problems/majority-element-ii/">MajorityElementII</a> Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.</p>
<p>Note: The algorithm should run in linear time and in O(1) space.</p>
<ul>
<li><p>Example 1: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: [3,2,3]</span><br><span class="line">Output: [3]</span><br></pre></td></tr></table></figure></p></li>
<li><p>Example 2: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: [1,1,1,3,3,2,2,2]</span><br><span class="line">Output: [1,2]</span><br></pre></td></tr></table></figure> <a id="more"></a></p></li>
</ul>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>给定一个数组，大小为 <code>n</code>，让找到所有出现多于<code>⌊ n/3 ⌋</code>次的元素</li>
<li>题目要求线性时间，以及 O(1) 的空间复杂度</li>
</ul>
<h3 id="boyer-moore-majority-vote-algorithm">Boyer-Moore majority vote algorithm</h3>
<p>该算法来自一篇论文<a href="http://www.cs.rug.nl/~wim/pub/whh348.pdf">Boyer-Moore Majority Vote Algorithm</a>，运行时间为O(n)，空间复杂度为O(1)，他只要求对输入遍历两次。虽然实现起来比较简单，但是理解起来还是需要花点时间。</p>
<ul>
<li>第一遍 &gt; 1. 我们需要定义两个变量：candidate 和 count &gt; 2. 对于每一个输入的元素，首先看 count，如果 count 为 0，将当前位置元素赋给 candidate &gt; 3. 比较当前位置的元素 与 candidate，如果相等：count+1，如果不等 count-1 &gt; 说白了，就是不一样的就可以抵消一个，最后剩下的 candidate 就是候选，最后在确认一次即可。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">candidate = <span class="number">0</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> input:</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">        candidate = value</span><br><span class="line">    <span class="keyword">if</span> candidate == value:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        count -= <span class="number">1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>当执行完毕后，candidate 即为 majority value 如果存在的话。</p>
</blockquote>
<ul>
<li>第二遍 确定一下 candidate 是不是 majority 元素。</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ 对象序列化</title>
    <url>/2019/11/22/C-Object-Serialization/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="背景">背景</h1>
<p>最近做的项目需要对C++对象进行序列化和反序列化，最主要的目的是将JSON和C++对象互转。</p>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sequence for</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, T... S, <span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">for_sequence</span><span class="params">(<span class="built_in">std</span>::integer_sequence&lt;T, S...&gt;, F&amp;&amp; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">unpack_t</span> = <span class="keyword">int</span>[];</span><br><span class="line">    (<span class="keyword">void</span>)<span class="keyword">unpack_t</span>&#123;(<span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>&gt;(f(<span class="built_in">std</span>::integral_constant&lt;T, S&gt;&#123;&#125;)), <span class="number">0</span>)..., <span class="number">0</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sample implementation of a json-like data structure. It is only there for the example to compile and actually produce a testable output</span></span><br><span class="line"><span class="keyword">namespace</span> Json &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Value</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ValueData</span> &#123;</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, Value&gt; subObject;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> <span class="built_in">string</span>;</span><br><span class="line">        <span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Value</span> &#123;</span></span><br><span class="line">        ValueData data;</span><br><span class="line"></span><br><span class="line">        Value&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="built_in">string</span> name) &#123;</span><br><span class="line">            <span class="keyword">return</span> data.subObject[<span class="built_in">std</span>::move(name)];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> Value&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="built_in">string</span> name) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = data.subObject.find(<span class="built_in">std</span>::move(name));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (it != data.subObject.end()) &#123;</span><br><span class="line">                <span class="keyword">return</span> it-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Value&amp; <span class="keyword">operator</span>=(<span class="built_in">std</span>::<span class="built_in">string</span> value) &#123;</span><br><span class="line">            data.<span class="built_in">string</span> = value;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Value&amp; <span class="keyword">operator</span>=(<span class="keyword">double</span> value) &#123;</span><br><span class="line">            data.number = value;</span><br><span class="line">            <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; T&amp; <span class="title">asAny</span><span class="params">(Value&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">const</span> T&amp; <span class="title">asAny</span><span class="params">(<span class="keyword">const</span> Value&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">int</span>&amp; asAny&lt;<span class="keyword">int</span>&gt;(Value&amp; value) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.data.number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span>&amp; asAny&lt;<span class="keyword">int</span>&gt;(<span class="keyword">const</span> Value&amp; value) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.data.number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; asAny&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="keyword">const</span> Value&amp; value) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.data.<span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>&amp; asAny&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(Value&amp; value) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.data.<span class="built_in">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Class, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PropertyImpl</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">PropertyImpl</span><span class="params">(T Class::*aMember, <span class="keyword">const</span> <span class="keyword">char</span>* aName)</span> : member</span>&#123;aMember&#125;, name&#123;aName&#125; &#123;&#125;</span><br><span class="line">    <span class="keyword">using</span> Type = T;</span><br><span class="line">    T Class::*member;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// One could overload this function to accept both a getter and a setter instead of a member.</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Class, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">property</span><span class="params">(T Class::*member, <span class="keyword">const</span> <span class="keyword">char</span>* name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PropertyImpl&lt;Class, T&gt;&#123;member, name&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// unserialize function</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">fromJson</span><span class="params">(<span class="keyword">const</span> Json::Value&amp; data)</span> </span>&#123;</span><br><span class="line">    T object;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We first get the number of properties</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> nbProperties = <span class="built_in">std</span>::tuple_size&lt;<span class="keyword">decltype</span>(T::properties)&gt;::value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We iterate on the index sequence of size `nbProperties`</span></span><br><span class="line">    for_sequence(<span class="built_in">std</span>::make_index_sequence&lt;nbProperties&gt;&#123;&#125;, [&amp;](<span class="keyword">auto</span> i)&#123;</span><br><span class="line">        <span class="comment">// get the property</span></span><br><span class="line">        <span class="keyword">constexpr</span> <span class="keyword">auto</span> property = <span class="built_in">std</span>::get&lt;i&gt;(T::properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get the type of the property</span></span><br><span class="line">        <span class="keyword">using</span> Type = <span class="keyword">typename</span> <span class="keyword">decltype</span>(property)::Type;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set the value to the member</span></span><br><span class="line">        object.*(property.member) = Json::asAny&lt;Type&gt;(data[property.name]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">Json::Value <span class="title">toJson</span><span class="params">(<span class="keyword">const</span> T&amp; object)</span> </span>&#123;</span><br><span class="line">    Json::Value data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We first get the number of properties</span></span><br><span class="line">    <span class="keyword">constexpr</span> <span class="keyword">auto</span> nbProperties = <span class="built_in">std</span>::tuple_size&lt;<span class="keyword">decltype</span>(T::properties)&gt;::value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We iterate on the index sequence of size `nbProperties`</span></span><br><span class="line">    for_sequence(<span class="built_in">std</span>::make_index_sequence&lt;nbProperties&gt;&#123;&#125;, [&amp;](<span class="keyword">auto</span> i)&#123;</span><br><span class="line">        <span class="comment">// get the property</span></span><br><span class="line">        <span class="keyword">constexpr</span> <span class="keyword">auto</span> property = <span class="built_in">std</span>::get&lt;i&gt;(T::properties);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set the value to the member</span></span><br><span class="line">        data[property.name] = object.*(property.member);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> animal &#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Dog</span> &#123;</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> barkType;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> color;</span><br><span class="line">        <span class="keyword">int</span> weight = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Dog&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> barkType == rhs.barkType &amp;&amp; color == rhs.color &amp;&amp; weight == rhs.weight;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">auto</span> properties = <span class="built_in">std</span>::make_tuple(property(&amp;Dog::barkType, <span class="string">&quot;barkType&quot;</span>), property(&amp;Dog::color, <span class="string">&quot;color&quot;</span>), property(&amp;Dog::weight, <span class="string">&quot;weight&quot;</span>));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    animal::Dog dog;</span><br><span class="line"></span><br><span class="line">    dog.color = <span class="string">&quot;green&quot;</span>;</span><br><span class="line">    dog.barkType = <span class="string">&quot;whaf&quot;</span>;</span><br><span class="line">    dog.weight = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    Json::Value jsonDog = toJson(dog); <span class="comment">// produces &#123;&quot;color&quot;:&quot;green&quot;, &quot;barkType&quot;:&quot;whaf&quot;, &quot;weight&quot;: 30&#125;</span></span><br><span class="line">    <span class="keyword">auto</span> dog2 = fromJson&lt;animal::Dog&gt;(jsonDog);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; (dog == dog2) &lt;&lt; __FILE_NAME__ &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// pass the test, both dog are equal!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>Construct Binary Tree from Preorder and Postorder Traversal</title>
    <url>/2020/05/24/ConstructBinaryTreeFromPreorderAndPostorderTraversal/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/">Construct Binary Tree from Preorder and Postorder Traversal</a> Return any binary tree that matches the given preorder and postorder traversals.</p>
<p>Values in the traversals pre and post are distinct positive integers.</p>
<p>Example 1: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]</span><br><span class="line">Output: [1,2,3,4,5,6,7]</span><br></pre></td></tr></table></figure></p>
<p>Note: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 &lt;= pre.length == post.length &lt;= 30</span><br><span class="line">pre[] and post[] are both permutations of 1, 2, ..., pre.length.</span><br><span class="line">It is guaranteed an answer exists. If there exists multiple answers, you can <span class="built_in">return</span> any of them.</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>给定两个数组，分别表示先序遍历和后序遍历</li>
<li>要求根据两个遍历结果构造出原来的二叉树</li>
</ul>
<h3 id="思路">思路</h3>
<h4 id="递归解法">递归解法</h4>
<ul>
<li>创建一个节点 <code>TreeNode[pre[preIndex]]</code> 作为根节点</li>
<li>由于后序遍历中根节点是最后访问的，因此构造结束的条件就是：<code>root-&gt;val == post[postIndex]</code></li>
<li>那么，如果还没有创建完二叉树，我们就递归的对于左子树和右子树调用构造函数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> preIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> postIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode *<span class="title">constructFromPrePost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; post)</span> </span>&#123;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode(pre[preIndex++]);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val != post[postIndex])</span><br><span class="line">            root-&gt;left = constructFromPrePost(pre, post);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;val != post[postIndex]) &#123;</span><br><span class="line">            root-&gt;right = constructFromPrePost(pre, post);</span><br><span class="line">        &#125;</span><br><span class="line">        postIndex++;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="非递归解法">非递归解法</h4>
<ul>
<li>使用栈，前序生成二叉树，将生成的结果 <code>push</code> 到 <code>stack</code> 中，然后使用后续 <code>pop</code> 出来</li>
<li><code>stack</code> 保存的是当前的树</li>
<li><code>node == new TreeNode(pre[i])</code> ，如果没有左子节点，就把它作为左子节点，否则就是右子节点。</li>
<li>如果在前序遍历和后序遍历碰到了相同的值，那么就说明当前子树构造结束，将其 <code>pop</code> 出来</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode * <span class="title">constructFromPrePost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;pre, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;post)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;TreeNode*&gt; stk_;</span><br><span class="line">        stk_.push_back(<span class="keyword">new</span> TreeNode(pre[<span class="number">0</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; pre.size(); i++) &#123;</span><br><span class="line">            TreeNode *node = <span class="keyword">new</span> TreeNode(pre[i]);</span><br><span class="line">            <span class="keyword">while</span> (stk_.back()-&gt;val == post[j]) &#123;</span><br><span class="line">                stk_.pop_back();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stk_.back()-&gt;left == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk_.back()-&gt;left = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stk_.back()-&gt;right = node;</span><br><span class="line">            &#125;</span><br><span class="line">            stk_.push_back(node);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stk_[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度">时间复杂度</h3>
<p>遍历次数：<code>O(n)</code>，因此是线性时间，每个元素只遍历一次</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p><code>O(n)</code> 表示栈的大小</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>CountDiv</title>
    <url>/2020/10/06/CountDiv/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://app.codility.com/demo/results/training37GVR9-XSW/">CountDiv</a> Write a function:</p>
<p>int solution(int A, int B, int K);</p>
<p>that, given three integers A, B and K, returns the number of integers within the range [A..B] that are divisible by K, i.e.:</p>
<p>{ i : A ≤ i ≤ B, i mod K = 0 }</p>
<p>For example, for A = 6, B = 11 and K = 2, your function should return 3, because there are three numbers divisible by 2 within the range [6..11], namely 6, 8 and 10.</p>
<p>Write an efficient algorithm for the following assumptions:</p>
<p>A and B are integers within the range [0..2,000,000,000]; K is an integer within the range [1..2,000,000,000]; A ≤ B. <a id="more"></a></p>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>暴力解法超时，说明需要更加聪明的剪枝</li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// you can use includes, for example:</span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// you can write to stdout for debugging purposes, e.g.</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;this is a debug message&quot; &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> A, <span class="keyword">int</span> B, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="keyword">while</span> (B % K &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        B--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (A % K &gt; <span class="number">0</span>)</span><br><span class="line">        A++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (B-A) / K + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度">时间复杂度</h3>
<p><code>O(1)</code></p>
]]></content>
      <categories>
        <category>Codility</category>
      </categories>
      <tags>
        <tag>Codility</tag>
      </tags>
  </entry>
  <entry>
    <title>CyclicRotation</title>
    <url>/2020/10/04/CyclicRotation/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://app.codility.com/demo/results/training23G6XA-48V/">CyclicRotation</a> An array A consisting of N integers is given. Rotation of the array means that each element is shifted right by one index, and the last element of the array is moved to the first place. For example, the rotation of array A = [3, 8, 9, 7, 6] is [6, 3, 8, 9, 7] (elements are shifted right by one index and 6 is moved to the first place).</p>
<p>The goal is to rotate array A K times; that is, each element of A will be shifted to the right K times.</p>
<p>Write a function:</p>
<p>vector<int> solution(vector<int> &amp;A, int K);</p>
<p>that, given an array A consisting of N integers and an integer K, returns the array A rotated K times.</p>
<p>For example, given</p>
<pre><code>A = [3, 8, 9, 7, 6]
K = 3</code></pre>
<p>the function should return [9, 7, 6, 3, 8]. Three rotations were made:</p>
<pre><code>[3, 8, 9, 7, 6] -&gt; [6, 3, 8, 9, 7]
[6, 3, 8, 9, 7] -&gt; [7, 6, 3, 8, 9]
[7, 6, 3, 8, 9] -&gt; [9, 7, 6, 3, 8]</code></pre>
<p>For another example, given</p>
<pre><code>A = [0, 0, 0]
K = 1</code></pre>
<p>the function should return [0, 0, 0]</p>
<p>Given</p>
<pre><code>A = [1, 2, 3, 4]
K = 4</code></pre>
<p>the function should return [1, 2, 3, 4]</p>
<p>Assume that:</p>
<p>N and K are integers within the range [0..100]; each element of array A is an integer within the range [−1,000..1,000]. In your solution, focus on correctness. The performance of your solution will not be the focus of the assessment.</p>
<a id="more"></a>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>给了超长的一段故事，让求数组循环右移以后的结果，肯定要求模</li>
<li>边界判断一下就行</li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="keyword">if</span> (K == <span class="number">0</span> || A.empty())</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m = A.size();</span><br><span class="line">    K = K % m;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span> <span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = (i + K) % m;</span><br><span class="line">        ans[idx] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度">时间复杂度</h3>
<p><code>O(N)</code></p>
]]></content>
      <categories>
        <category>Codility</category>
      </categories>
      <tags>
        <tag>Codility</tag>
      </tags>
  </entry>
  <entry>
    <title>探索 NSDictionary</title>
    <url>/2019/12/04/Dive-Into-NSDictionary/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="exposing-nsdictinoary">Exposing NSDictinoary</h1>
<h2 id="the-class">The Class</h2>
<p>相当多的类都是 class clusters，当然 NSDictionary 也不例外，曾经一段时间 NSDictinoary 使用了 CFDictionary 作为它的默认实现。然而，在 iOS 6以后事情改变了。。。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(lldb) po [[NSDictionary new] class]</span><br><span class="line">__NSDictionaryI</span><br></pre></td></tr></table></figure>
<p>和 __NSArrayM 一样， __NSDictionaryI 也是在 CoreFoundation Framework 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface __NSDictionaryI : NSDictionary</span><br><span class="line">&#123;</span><br><span class="line">    NSUIngeter _used:58;</span><br><span class="line">    NSUIngeter _szidx:6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="the-storage">The Storage</h2>
<h3 id="instance-creation">Instance Creation</h3>
<p>想要理解 __NSDictionaryI 在哪里保存内容，我们来看看对象创建的过程，只有一个类方法负责创建实例：<code>__NSDictionaryI</code>。根据 class-dump 的输出，方法有如下的签名：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (id)__new:(const id *)arg1:(const id *)arg2:(unsigned long long)arg3:(_Bool)arg4:(_Bool)arg5;</span><br></pre></td></tr></table></figure></p>
<p>他需要5各参数，只有第一个是指名字，如果我们使用@selector 的方式来写的话，应该是这样 <code>@selector(__new:::::)</code>。前三个参数通过设置断点，然后看一下寄存器 x2、x3、x4的内容，看到他们是分别是：array 的 key、array 的 object、key（object） 的个数。注意和对外公布的 api 相比，参数的位置是互换的。</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (instancetype)dictionaryWithObjects:(const id [])objects forKeys:(const id &lt;NSCopying&gt; [])keys count:(NSUInteger)cnt;</span><br></pre></td></tr></table></figure></p>
<p>其实参数定义为<code>const id *</code>或者<code>const id []</code>没有太大的关系。剩下的就是两个BOOL 类型的参数。第四个参数是指 key 是否需要被拷贝。第五个参数决定了参数是否不需要被 retain。我们可以重写该函数：</p>
<p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (id)__new:(const id *)keys :(const id *)objects :(unsigned long long)count :(_Bool)copyKeys :(_Bool)dontRetain;</span><br></pre></td></tr></table></figure></p>
<h3 id="indexed-ivars">Indexed ivars</h3>
<p>除了函数<code>+ __new:::::</code>以外，<code>malloc</code> 和 <code>calloc</code> 并没有地方被调用。实际上，函数调用了 <code>__CFAllocateObject2</code> 方法，并且传递了 <code>__NSDictionaryI</code> 作为第一个参数，然后用需要的大小作为第二个参数。<code>__CFAllocateObject2</code> 实际上调用了 <code>class_createInstance</code> ，然后把同样的参数传给他。</p>
<p>class_createInstance(Class cls, size_t extraBytes) 调用了 _class_createInstanceFromZone 并且传个 nil 作为 zone 的参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">_class_createInstanceFromZone(Class cls, size_t extraBytes, void *zone)</span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    size_t size &#x3D; cls-&gt;alignedInstanceSize() + extraBytes;</span><br><span class="line">    ...</span><br><span class="line">    id obj &#x3D; (id)calloc(1, size);</span><br><span class="line">    ...</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>extreBytes 参数，calloc 函数调用确保了所有的 ivar 都是 0.</p>
<p>indexed ivars就是在普通的 ivar 后面<img src="/images/14919793823550/14919859011959.jpg" /></p>
<p>剩下的就是分配内存了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void *object_getIndexedIvars(id obj)</span><br></pre></td></tr></table></figure>
<p><img src="/images/14919793823550/14919866880631.jpg" /></p>
<p>关于 indexed ivar 有一些比较好玩的事情。 * 每一个实例都可以有不同数量的 extraBytes指向他 * 存取速度很快。 * 可以对 class-dump 这样的工具隐藏实现细节。</p>
<p>但是：在 arc 环境下是不能直接编译 class_createInstance，需要增加 -fno-objc-arc 标志位。。运行时没有保存 indexed ivars 信息。</p>
<h2 id="key-访问一个对象">key &amp; 访问一个对象</h2>
<h3 id="c-code">C Code</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- (id)objectForKey:(id)aKey</span><br><span class="line">&#123;</span><br><span class="line">    NSUInteger sizeIndex &#x3D; _szidx;</span><br><span class="line">    NSUInteger size &#x3D; __NSDictionarySizes[sizeIndex];</span><br><span class="line"></span><br><span class="line">    id *storage &#x3D; (id *)object_getIndexedIvars(dict);</span><br><span class="line"></span><br><span class="line">    NSUInteger fetchIndex &#x3D; [aKey hash] % size;</span><br><span class="line"></span><br><span class="line">    for (int i &#x3D; 0; i &lt; size; i++) &#123;</span><br><span class="line">        id fetchedKey &#x3D; storage[2 * fetchIndex];</span><br><span class="line"></span><br><span class="line">        if (fetchedKey &#x3D;&#x3D; nil) &#123;</span><br><span class="line">            return nil;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (fetchedKey &#x3D;&#x3D; aKey || [fetchedKey isEqual:aKey]) &#123;</span><br><span class="line">            return storage[2 * fetchIndex + 1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fetchIndex++;</span><br><span class="line"></span><br><span class="line">        if (fetchIndex &#x3D;&#x3D; size) &#123;</span><br><span class="line">            fetchIndex &#x3D; 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nil;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码是从汇编反推出来的。</p>
<p><img src="/images/14919793823550/14919872407257.jpg" /></p>
]]></content>
      <categories>
        <category>瞎逼逼</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>NSDictionary</tag>
      </tags>
  </entry>
  <entry>
    <title>FishHook 学习笔记</title>
    <url>/2019/12/25/Dynamic-Library/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>0x0 什么是dyld dyld 是加载Mach-O的库，入口是<code>_dyld_start</code>,</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>瞎逼逼</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>FishHook</tag>
      </tags>
  </entry>
  <entry>
    <title>DynamicProgramming</title>
    <url>/2020/06/04/DynamicProgramming/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="动态规划套路">动态规划套路</h2>
<h4 id="有一个-mn-大小的矩阵迷宫每次移动只能向右或者向下文聪左上角到右下角有多少种不同的走法">有一个 m*n 大小的矩阵迷宫，每次移动只能向右或者向下，文聪左上角到右下角有多少种不同的走法</h4>
<h5 id="暴力解法">暴力解法</h5>
<ul>
<li>从<code>(1,1)-&gt;(m,n)</code>的不同路径中有大量的重复，比如<code>(1,1)-&gt;(i,j)</code>有 <code>k</code> 条不同的路径，那么对于任何一条固定的路线<code>(i,j)-&gt;(m,n)</code>的路径，都需要走 <code>k</code> 遍来模拟。</li>
<li>不关心具体的走法，只关心状态，也就是走法的数量</li>
<li>同理，如果知道<code>(i,j)-&gt;(m,n)</code>有 <code>k</code> 条不同的路径，那么<code>(1,1)-&gt;(i,j)-&gt;(m,n)</code>的不同路径总数是<code>k*s</code> ##### 动态规划</li>
<li>令<code>(i,j)</code>表示从<code>(1,1)-&gt;(i,j)</code>的不同路径数量，<code>f(i,j) = f(i-1,j) + f(i,j-1)</code></li>
<li>如果要求出 <code>f(i,j)</code> 只需要上一个结果即可， 也就是求解<code>f(i,j)</code> 需要求出子问题<code>f(i',j')</code> ##### 动态规划适用前提 ###### 无后效性</li>
<li>一旦确定<code>f(i,j)</code>，就不用关心如何计算出<code>f(i,j)</code></li>
<li>想要确定<code>f(i,j)</code>，只要知道<code>f(i-1,j)</code>和<code>f(i,j-1)</code> ###### 最优子结构</li>
<li><code>f(i,j)</code>的定义已经蕴含最优</li>
<li>大问题的最优解可以由若干小问题的最优解推出<code>(min, max, sum)</code> &gt; DP 适用的问题：可以将大问题拆成几个小问题，且无后效性，具有最优子结构的性质 ###### 记忆化递归</li>
<li>可以使用递归求解</li>
<li>有重复子问题，overlaping subproblem</li>
</ul>
<a id="more"></a>
<h2 id="套路一基本类型时间序列">套路一：基本类型（时间序列）</h2>
<h3 id="house-robber">House Robber</h3>
<ul>
<li>给一排房子，相邻的房子不能抢，问最多能抢的价值</li>
<li>房子只有抢和不抢两个状态</li>
<li>和时间相关的为第 <code>i</code> 轮</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0 --&gt; max profit of not rob the i-th house</span></span><br><span class="line">        <span class="comment">// 1 --&gt; max profit of robbing the i-th house</span></span><br><span class="line">        <span class="comment">// corner case</span></span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="title">dp</span><span class="params">(nums.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">0</span>))</span></span>;</span><br><span class="line">        <span class="comment">// if not rob 0 max profit is 0</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// if rob 0, max profit is nums[0]</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="comment">// if not rob the i-th roby, so the max profit will be the max value of rob/non-rob on last house</span></span><br><span class="line">            <span class="comment">// because if rob on a low price house will not be a good choice</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// if decide to rob i-th , i-1-th must not be robbed</span></span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(dp[nums.size() - <span class="number">1</span>][<span class="number">0</span>], dp[nums.size() - <span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="house-robber-ii">House Robber II</h3>
<ul>
<li>给一圈“首尾相连”的房子，相邻的房子不能抢，问最多能抢的价值</li>
<li>假定有 n 个房子，因为 0 和 n-1 为相邻的房子。因此可抢的范围为 <code>0 -&gt; n-2</code> 或者 <code>1 -&gt; n-1</code></li>
<li>因此结果就是两个中最大值。 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; houses)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (m &lt; <span class="number">2</span>) <span class="keyword">return</span> m ? nums[<span class="number">0</span>] : <span class="number">0</span>;</span><br><span class="line">        function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; robHelper = [&amp;](<span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">0</span>));</span><br><span class="line">            dp[l][<span class="number">1</span>] = nums[l];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]);</span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> max(dp[r][<span class="number">0</span>], dp[r][<span class="number">1</span>]);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max(robHelper(<span class="number">1</span>, m<span class="number">-1</span>), robHelper(<span class="number">0</span>, m<span class="number">-2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="best-time-to-buy-and-sell-stock-iii">Best Time to Buy and Sell Stock III</h3>
<ul>
<li>给定一系列每日股票的价格，每日只能买入、卖出、不操作。最多交易两次，问最大的收益 <img src="/images/best_time_to_buy_sell_stock.png" alt="BestTimeToBuySellStock.PNG" /></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    0 表示这一轮我已经持有第一股的最大收益</span></span><br><span class="line"><span class="comment">    1 表示这一轮我已经售出第一股的最大收益</span></span><br><span class="line"><span class="comment">    2 表示这一轮我已经持有第二股的最大收益</span></span><br><span class="line"><span class="comment">    3 表示这一轮我已经售出第二股的最大收益</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>], -val[i]);</span><br><span class="line">      dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>] + val[i]);</span><br><span class="line">      dp[i][<span class="number">2</span>] = max(dp[i<span class="number">-1</span>][<span class="number">2</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] - val[i]);</span><br><span class="line">      dp[i][<span class="number">3</span>] = max(dp[i<span class="number">-1</span>][<span class="number">3</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>] + val[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  ans = max&#123;dp[n][i]&#125; (i = <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h3 id="best-time-to-buy-and-sell-stock-with-cooldown">Best Time to buy and Sell Stock with cooldown</h3>
<ul>
<li>给定一系列股票的加个，每日只能买入、卖出、不操作。买入后要隔卖出，无总交易限制，问最大收益 <img src="/images/best_time_to_buy_sell_stock_cool_down.png" alt="BestTimeToBuySellStockCoolDown.PNG" /> <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    0 表示本轮刚持有股票的最大收益</span></span><br><span class="line"><span class="comment">    1 表示本轮持有一天以上的最大收益</span></span><br><span class="line"><span class="comment">    2 表示我已清空股票的最大收益</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">2</span>] - val[i];</span><br><span class="line">    dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">0</span>]);</span><br><span class="line">    dp[i][<span class="number">2</span>] = max(dp[i<span class="number">-1</span>][<span class="number">2</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>] + val[i]);</span><br><span class="line">&#125;</span><br><span class="line">ans = max&#123;dp[i][n]&#125; (n = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="wiggle-subsequence">Wiggle Subsequence</h3>
<ul>
<li>给定一个序列 <code>s</code>， 求其最长的<code>wiggle pattern subsequence (.... &gt;s[i] &lt; s[j] &gt; s[j+1]...)</code> <img src="/images/wiggle_subsequence.png" alt="wiggleSubsequence.PNG" /></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    0 以当前元素结尾且上升</span></span><br><span class="line"><span class="comment">    1 一当前元素结尾且下降</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &gt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">        dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nums[i] &lt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans = max(dp[N][i]) (i = <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="paint-fence">Paint Fence</h3>
<ul>
<li>给出 <code>cost[i]</code> 表示第 <code>i</code> 个房子喷涂第 <code>j</code> 中 漆的价格，相邻的房子不能涂同一种颜色，求喷涂所有房子的最小价格</li>
</ul>
<figure>
<img src="/images/paint_fence.png" alt="paintFence.PNG" /><figcaption aria-hidden="true">paintFence.PNG</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    dp[i][j] 表示第 i 间房子喷涂第 j 中颜色的代价</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    dp[i][j] = min(dp[i<span class="number">-1</span>][j], cost[j]) <span class="comment">// j = 1,2,...,k</span></span><br><span class="line">&#125;</span><br><span class="line">ans = min(dp[N][j]) (j = <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,...,k)</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>To Do or Not To Do</code> 很多不那么套路的 DP 题目，状态比较难以设计，某些题目会给你“行使某种策略的权利”，想买卖股票的题目，两个状态就分别为“行驶了某种权利”，“没有行使某种权利” 分别对应的价值</p>
</blockquote>
<h3 id="max-consecutive-one-ii">Max Consecutive One II</h3>
<ul>
<li>给定一个数组<code>(0/1)</code>，有最多一次从 <code>0</code> 翻转到 <code>1</code> 的权利，问最多可以有多少连续的 <code>1</code> <img src="/images/mac_consecutive_ones_ii.png" alt="maxConsecutive.PNG" /></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    0 表示以当前元素结尾且没有行使翻转权利的最长连续 1</span></span><br><span class="line"><span class="comment">    1 表示以当前元素结尾且已经行驶翻转权利的最长连续 1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    dp[i][<span class="number">0</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>] + nums[i], nums[i]);</span><br><span class="line">    dp[i][<span class="number">1</span>] = max(dp[i<span class="number">-1</span>][<span class="number">0</span>],dp[i<span class="number">-1</span>][<span class="number">1</span>]+nums[i]);</span><br><span class="line">&#125;</span><br><span class="line">ans = max(dp[i][j]) (<span class="keyword">for</span> all possible i,j = <span class="number">0</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<h2 id="套路二基本类型-ii时间序列加强版">套路二：基本类型 II（时间序列加强版）</h2>
<ul>
<li>给定一个序列（数组/字符串），其中每个元素可以认为一天，但今天的状态和之前的某一天有关，需要挑选。</li>
<li>套路</li>
</ul>
<blockquote>
<p>定义 dp[i] 表示第 i 轮的状态，一般这个状态要求和元素 i 直接有关系。 千方百计将 dp[i] 与之前的状态 dp[i'] 产生关系比如 sum,max,min, dp[i] 一定不能与大于 i 的轮次有关系，否则违反了 DP 的无后效性。 * 最终的结果是 dp[i] 中的某一个 <img src="/images/pattern_ii.png" alt="patternII" /></p>
</blockquote>
<h3 id="longest-increasing-subsequence">Longest Increasing Subsequence</h3>
<ul>
<li>给定一个数组 s，求最长的递增子序列的长度</li>
</ul>
<blockquote>
<p>状态定义： 照抄问题，dp[i]--&gt; s[1:i]里面以 s[i]为结尾的、最长的递增子序列的长度。 状态转移：寻找最优解的前驱状态 j，将 dp[i] 与 dp[j] 产生联系</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="comment">//i 表示 LIS 的最大元素，搜索该 LIS 的第二大元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; nums[j])</span><br><span class="line">            dp[i] = max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = max(dp[i]), <span class="keyword">for</span> i in <span class="number">1</span>,...N</span><br></pre></td></tr></table></figure>
<h3 id="largest-divisible-subset">Largest Divisible Subset</h3>
<ul>
<li>给定一个数组 <code>s</code>，求最大子集，使得里面的所有元素之间都可以相互整除。</li>
</ul>
<blockquote>
<p>状态定义：照抄问题，dp[i]--&gt; s[1:i] 以 s[i]为结尾，满足题目要求的最大子集的数目。 状态转移：寻找最优的前驱状态 j，将 dp[i] 与 dp[j] 产生联系</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(nums);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="comment">// i 表示该集合的最大元素，搜索该子集的第二大元素 j</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] % nums[j] == <span class="number">0</span>)</span><br><span class="line">            dp[i] = max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = max(dp[i]) <span class="keyword">for</span> i in <span class="number">1</span>,...,N</span><br></pre></td></tr></table></figure>
<h3 id="filling-bookcase-shelves">Filling Bookcase Shelves</h3>
<ul>
<li>给定 <code>N</code> 本书（宽高各异）的序列要求按照所给的顺序摆放，相邻的若干本书可以放一层，但同一层的高度不能超过 <code>w</code>。问这个书架最矮可以有多高 <img src="/images/book_shelf.png" alt="bookShelf" /></li>
<li>将数组 S 分成若干个子数组，最小化“每个数组的最大值之和”，输出该值</li>
</ul>
<blockquote>
<p>状态定义：照抄问题 dp[i]--&gt;将数组S[1,...N] 分成若干个子数组，最小化“每个子数组的最大值之和”，保存该值 状态转移：寻找最优的前驱状态 j，将 dp[i] 与 dp[j] 产生联系 第 i 本书所在的这一层可能有多高？取决于上一层的最后一本书放在那里</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">    <span class="comment">// i 表示本层最后一本书，搜索上一层最后一本的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i<span class="number">-1</span>; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (totalWidth[j+<span class="number">1</span>:i] &lt;= W)</span><br><span class="line">            dp[i] = min(dp[i], dp[j] + maxHeight[j+<span class="number">1</span>:i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">ans = dp[N];</span><br></pre></td></tr></table></figure>
<h2 id="套路三双序列类型">套路三：双序列类型</h2>
<ul>
<li>给出两个序列 <code>s</code> 和 <code>t</code>（数组/字符串），对他们搞事情</li>
<li>套路</li>
</ul>
<blockquote>
<p>定义 dp[i][j]: 表示针对 s[1:i] 和 t[1:j] 的子问题求解答 千方百计将 dp[i][j] 与之前的状态之间转移 dp[i-1][j], dp[i][j-1] , dp[i-1][j-1] 最终的结果是 dp[m][n]</p>
</blockquote>
<h3 id="longest-common-subsequences">Longest Common subsequences</h3>
<ul>
<li>求字符串 s 和 t 的 length of LCS</li>
</ul>
<blockquote>
<p>状态定义：照抄问题 dp[i][j]--&gt; s[1:i] t[1:j]的 length of LCS 状态转移：外面两大层循环编译 i 和 j，核心从 s[i] 与 t[j] 的关系作为突破口，往 dp[i-1][j], dp[i][j-1], dpp[i-1][j] 转移</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    s:XXXXXi</span></span><br><span class="line"><span class="comment">    t:YYYj</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = max(dp[i<span class="number">-1</span>][j], dp[i][j<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="shortest-common-supersequence">Shortest Common Supersequence</h3>
<ul>
<li>求字符串 <code>s</code> 和 <code>t</code> 的 <code>length of SCS</code></li>
</ul>
<blockquote>
<p>状态定义：照抄问题 dp[i][j]--&gt; s[1:i] 和 t[1:j] 的 length of SCS 状态转移：外面两层大循环遍历 i 和 j ：核心从 s[i] 与 t[j] 的关系作为突破口，拼命往 dp[i-1][j], dp[i][j-1], dp[i-1][j-1] 转移 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j]) &#123;</span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = min(dp[i<span class="number">-1</span>][j] + <span class="number">1</span>, dp[i][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="edit-distance">Edit Distance</h3>
<ul>
<li>求字符串 <code>s</code> 和 <code>t</code> 的 <code>min edit distance</code></li>
</ul>
<blockquote>
<p>状态定义：照抄问题 dp[i][j]--&gt; s[1:i] 和 t[1:j] 的 min edit distance 状态转移：外面两层大循环遍历 i 和 j ：核心从 s[i] 与 t[j] 的关系作为突破口，拼命往 dp[i-1][j], dp[i][j-1], dp[i-1][j-1] 转移</p>
</blockquote>
<h2 id="套路四第一类区间类型">套路四：第一类区间类型</h2>
<h2 id="套路五第二类取件类型">套路五：第二类取件类型</h2>
<h2 id="套路六背包入门">套路六：背包入门</h2>
<h2 id="状态压缩">状态压缩</h2>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>Find K-th Smallest Pair Distance</title>
    <url>/2020/07/04/FindKtheSmallestPairDistance/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://leetcode.com/problems/find-k-th-smallest-pair-distance/">Find K-th Smallest Pair Distance</a> Given an integer array, return the k-th smallest distance among all the pairs. The distance of a pair (A, B) is defined as the absolute difference between A and B.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input:</span><br><span class="line">nums &#x3D; [1,3,1]</span><br><span class="line">k &#x3D; 1</span><br><span class="line">Output: 0</span><br><span class="line">Explanation:</span><br><span class="line">Here are all the pairs:</span><br><span class="line">(1,3) -&gt; 2</span><br><span class="line">(1,1) -&gt; 0</span><br><span class="line">(3,1) -&gt; 2</span><br><span class="line">Then the 1st smallest distance pair is (1,1), and its distance is 0.</span><br><span class="line">Note:</span><br><span class="line">2 &lt;&#x3D; len(nums) &lt;&#x3D; 10000.</span><br><span class="line">0 &lt;&#x3D; nums[i] &lt; 1000000.</span><br><span class="line">1 &lt;&#x3D; k &lt;&#x3D; len(nums) * (len(nums) - 1) &#x2F; 2.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>给定数组，让在所有的距离对中求第 k 个最小的距离，然后给出距离对的定义是 (a,b) --&gt; a 和 b 的差值</li>
</ul>
<h3 id="理解例子">理解例子</h3>
<ul>
<li><code>&#123;1,3,1&#125;</code> 数组，可能有的距离对的个数为 n * (n - 1) / 2</li>
<li>所有的距离对为：(1, 3) (1, 1) (3, 1) 他们的距离值为: 2, 0 ,2</li>
<li>因此排在第 1 位的最小的距离对为 (1,1) 结果为 0</li>
</ul>
<h3 id="思路">思路</h3>
<ul>
<li>首先想到的就是暴力解法，我们得知道所有可能的距离对，然后计算每个对的差值，求第 k 个。</li>
<li>转念一想，其实没必要把距离对求出来，只要求出所有可能的差值就行。</li>
<li>但差值可能有好几个，模式点像桶排序，O(n)时间就可完成排序，那么就得知道需要多少个桶。</li>
<li>所以对输入数据进行排序后，最大的值，就知道了，也就知道桶的个数了。</li>
<li>每个桶里放差值的个数即可，就能知道排在第几位的桶有多少个，也就能回答问题</li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">smallestDistancePair</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">int</span> n = nums.back();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = nums.size();</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">freq</span><span class="params">(n+<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; m; j++)</span><br><span class="line">                freq(nums[j]-nums[i])++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            k -= freq[i];</span><br><span class="line">            <span class="keyword">if</span> (k &lt;= <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="时间复杂度">时间复杂度</h4>
<p>\(\)</p>
<h4 id="空间复杂度">空间复杂度</h4>
<p>因此空间复杂度也为 \(\)</p>
<h3 id="优化">优化</h3>
<ul>
<li>提交后通过了，但是所有的性能指标是在最后的最后，还是优化一下符合要求</li>
<li>桶排序的内存要求比较高，另外，在求所有元素对的地方耗费太多时间，那个地方也是优化点。</li>
<li>这道题目的步骤大概可以分为两个，首先的知道距离对的内容，然后就是找 k 个满足条件的距离对</li>
<li>距离对的内容，可以使用 dp 来解决，那么 dp 的状态转换方程应该怎么写呢？</li>
</ul>
<h4 id="思路-1">思路</h4>
<ul>
<li>由于题目让求排在第 k 位的最小的距离对。之前的 lower_bound 是查找≥某个数的第一个位置， upper_bound 是求＞某个数的第一个位置。因此这道题应该是让查：差值，这个差值还得满足至少有 k 个差值是小于等于它的。</li>
<li>因此如果要使用折半查找的数据内容是表示 以上内容的，就可以方便的使用折半查找了。</li>
<li>假定内容是升序排列，假定 <code>d_ij</code> 表示 对于<code>(i,j)</code> 距离对且 <code>i &lt; j</code>，那么 <code>d_id = nums[j] - nums[i]</code></li>
<li>如果 i 位置不变的话，<code>d_ij &lt;= num</code> 就等价于 <code>nums[j] &lt;= nums[i] + num</code></li>
<li>那么也就是说要去找最小的 <code>j</code> 保证 <code>nums[j] &gt; nums[i] + num</code></li>
<li>计数也可以使用双指针，在线性时间下完成 &gt; * 假定两个起点 l1 &lt; l2，满足 nums[j1] &gt; nums[i1] + num 和 nums[j2] &gt; nums[i2] + num ---&gt; j2 &gt; j1</li>
</ul>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>Find the Duplicated Number</title>
    <url>/2020/06/27/FindTheDuplicatedNumber/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="http://bookshadow.com/weblog/2015/09/28/leetcode-find-duplicate-number/">Find the Duplicated Number</a> Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.</p>
<p>Example 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: [1,3,4,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>
<p>Example 2: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: [3,1,3,4,2]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure> Note:</p>
<p>You must not modify the array (assume the array is read only). You must use only constant, O(1) extra space. Your runtime complexity should be less than O(n2). There is only one duplicate number in the array, but it could be repeated more than once.</p>
<a id="more"></a>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>给定一个大小为 <code>n+1</code> 的数组，其中每一个数字都是在 <code>1--N</code> 的区间内, 证明至少有一个重复数字是存在的，假定只有唯一的一个重复数字，找到他</li>
<li>不能修改数组, 排序也就不能用了。</li>
<li>常量空间</li>
<li>运行时间要比 N^2要小，那就只剩下 O(n) O(nlogn) O(logn) 的算法可用。</li>
</ul>
<h3 id="理解例子">理解例子</h3>
<ul>
<li><code>2 -&gt; 4 -&gt; 3</code> = <code>342</code></li>
<li><code>5 -&gt; 6 -&gt; 4</code> = <code>465</code></li>
<li><code>342 + 465 = 807</code></li>
<li>答案 : <code>7 -&gt; 0 -&gt; 8</code></li>
</ul>
<h3 id="思路">思路</h3>
<ul>
<li>证明至少存在一个重复数字，如果元素是<code>[1,n]</code> 那么就存在 <code>n</code> 个不同的数字，分别将每一个位置都占据了，当数字个数为 <code>n+1</code> 时，那么最少有一个数字是重复的</li>
<li>由于数组的 <code>n+1</code> 个元素的取值范围为 <code>1..n</code>，假定映射关系为 <code>f</code>，那么就存在一个函数 <code>f(i) --&gt;</code> 可以取到 <code>nums[i]</code>，重复的情况就是说存在另一个数字 <code>j</code>，在<code>i != j</code>的前提下，存在 <code>f(i) == f(j)</code>， 那么剩下的问题就是如何将 <code>f</code> 表示出来</li>
<li>就是说使用函数 f。遍历整个数组，总会存在一个位置导致没有办法结束，走入无限循环，也就是类似链表存在环。</li>
<li>证明过程：<a href="http://bookshadow.com/weblog/2015/09/28/leetcode-find-duplicate-number/">证明过程</a></li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findDubplicated</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">            <span class="keyword">if</span> (slow == fast)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> find = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            find = nums[find];</span><br><span class="line">            <span class="keyword">if</span> (slow == find)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> find;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>FrogJump</title>
    <url>/2020/10/11/FrogJump/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://app.codility.com/demo/results/training5TVBTN-APV/">FrogJump</a> A small frog wants to get to the other side of the road. The frog is currently located at position X and wants to get to a position greater than or equal to Y. The small frog always jumps a fixed distance, D.</p>
<p>Count the minimal number of jumps that the small frog must perform to reach its target.</p>
<p>Write a function:</p>
<p>int solution(int X, int Y, int D);</p>
<p>that, given three integers X, Y and D, returns the minimal number of jumps from position X to a position equal to or greater than Y.</p>
<p>For example, given:</p>
<p>X = 10 Y = 85 D = 30 the function should return 3, because the frog will be positioned as follows:</p>
<p>after the first jump, at position 10 + 30 = 40 after the second jump, at position 10 + 30 + 30 = 70 after the third jump, at position 10 + 30 + 30 + 30 = 100 Write an efficient algorithm for the following assumptions:</p>
<p>X, Y and D are integers within the range [1..1,000,000,000]; X ≤ Y.</p>
<a id="more"></a>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>这到底是主要是考察数据长度，需要将数据提升精度才能得出正确结果</li>
<li>ceil 向上取整</li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// you can use includes, for example:</span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line"><span class="comment">// ceil在图文件 cmath 中</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="comment">// you can write to stdout for debugging purposes, e.g.</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;this is a debug message&quot; &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> X, <span class="keyword">int</span> Y, <span class="keyword">int</span> D)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="keyword">double</span> ans = (<span class="keyword">double</span>(Y) - <span class="keyword">double</span>(X)) / <span class="keyword">double</span>(D);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ceil</span>(ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度">时间复杂度</h3>
<p><code>O(N)</code></p>
]]></content>
      <categories>
        <category>Codility</category>
      </categories>
      <tags>
        <tag>Codility</tag>
      </tags>
  </entry>
  <entry>
    <title>FrogRiverOne</title>
    <url>/2020/10/04/FrogRiverOne/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://app.codility.com/demo/results/trainingUR22B7-7R8/">FrogRiverOne</a> A small frog wants to get to the other side of a river. The frog is initially located on one bank of the river (position 0) and wants to get to the opposite bank (position X+1). Leaves fall from a tree onto the surface of the river.</p>
<p>You are given an array A consisting of N integers representing the falling leaves. A[K] represents the position where one leaf falls at time K, measured in seconds.</p>
<p>The goal is to find the earliest time when the frog can jump to the other side of the river. The frog can cross only when leaves appear at every position across the river from 1 to X (that is, we want to find the earliest moment when all the positions from 1 to X are covered by leaves). You may assume that the speed of the current in the river is negligibly small, i.e. the leaves do not change their positions once they fall in the river.</p>
<p>For example, you are given integer X = 5 and array A such that:</p>
<p>A[0] = 1 A[1] = 3 A[2] = 1 A[3] = 4 A[4] = 2 A[5] = 3 A[6] = 5 A[7] = 4 In second 6, a leaf falls into position 5. This is the earliest time when leaves appear in every position across the river.</p>
<p>Write a function:</p>
<p>int solution(int X, vector<int> &amp;A);</p>
<p>that, given a non-empty array A consisting of N integers and integer X, returns the earliest time when the frog can jump to the other side of the river.</p>
<p>If the frog is never able to jump to the other side of the river, the function should return −1.</p>
<p>For example, given X = 5 and array A such that:</p>
<p>A[0] = 1 A[1] = 3 A[2] = 1 A[3] = 4 A[4] = 2 A[5] = 3 A[6] = 5 A[7] = 4 the function should return 6, as explained above.</p>
<p>Write an efficient algorithm for the following assumptions:</p>
<p>N and X are integers within the range [1..100,000]; each element of array A is an integer within the range [1..X].</p>
<a id="more"></a>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>说了一大段故事，就是要求在计算 1..X 都出现过的时候，X下标的位置</li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// you can use includes, for example:</span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="comment">// you can write to stdout for debugging purposes, e.g.</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;this is a debug message&quot; &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="keyword">int</span> X, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; memo_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">        memo_.insert(A[i]);</span><br><span class="line">        <span class="keyword">if</span> (memo_.size() == X) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度">时间复杂度</h3>
<p><code>O(NlogN)</code></p>
]]></content>
      <categories>
        <category>Codility</category>
      </categories>
      <tags>
        <tag>Codility</tag>
      </tags>
  </entry>
  <entry>
    <title>Gray Code Conversion</title>
    <url>/2020/05/22/GrayCode-Conversion/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="来自维基百科">来自维基百科</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        The purpose of this function is to convert an unsigned</span></span><br><span class="line"><span class="comment">        binary number to reflected binary Gray code.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        The operator &gt;&gt; is shift right. The operator ^ is exclusive or.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">binaryToGray</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (num &gt;&gt; <span class="number">1</span>) ^ num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        The purpose of this function is to convert a reflected binary</span></span><br><span class="line"><span class="comment">        Gray code number to a binary number.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">grayToBinary</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> mask;</span><br><span class="line">    <span class="keyword">for</span> (mask = num &gt;&gt; <span class="number">1</span>; mask != <span class="number">0</span>; mask = mask &gt;&gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        num = num ^ mask;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>Groking The coding Interview</title>
    <url>/2020/11/16/GrokingTheCodeInterview/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="滑动窗口">滑动窗口</h2>
<p><a href="https://leetcode.com/problems/add-two-numbers/">AddTwoNumbers</a> You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p>
<p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
<p>Example:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">Output: 7 -&gt; 0 -&gt; 8</span><br><span class="line">Explanation: 342 + 465 = 807.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li><code>2</code> 个 <code>非空</code>链表，长度可能不相等</li>
<li>每个链表为<code>逆序</code></li>
<li>返回两个链表的和</li>
<li>每个元素应该为正数</li>
</ul>
<h3 id="理解例子">理解例子</h3>
<ul>
<li><code>2 -&gt; 4 -&gt; 3</code> = <code>342</code></li>
<li><code>5 -&gt; 6 -&gt; 4</code> = <code>465</code></li>
<li><code>342 + 465 = 807</code></li>
<li>答案 : <code>7 -&gt; 0 -&gt; 8</code></li>
</ul>
<h3 id="思路">思路</h3>
<ul>
<li>将每一个链表变成整形，然后相加，结果分解成链表不大合适，还得处理越界的情况</li>
<li>比较合理的办法：是一边遍历一边生成链表</li>
<li>每一个生成的节点为两个数的和，有可能产生进位: 如 <code>7+8=15</code></li>
<li>一个节点的结果为：<code>sum = 前一个节点的进位+两个节点的和</code>，<code>res = sum % 10</code>;</li>
<li>一个节点的结果几种情况
<ul>
<li><code>last_carry + left + right &lt; 10</code></li>
<li><code>last_carry + left + right &gt;= 10</code></li>
<li><code>只要有进位，就一定会有一个新的节点出现</code></li>
</ul></li>
</ul>
<h3 id="代码">代码</h3>
<h4 id="非递归">非递归</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode *head = &amp;dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2 || carry) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (l1 ? l1-&gt;val : <span class="number">0</span>) + (l2 ? l2-&gt;val : <span class="number">0</span>) + carry;</span><br><span class="line">            head-&gt;next = <span class="keyword">new</span> ListNode (sum % <span class="number">10</span>);</span><br><span class="line">            head = head-&gt;next;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (l2) l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">var</span> val: <span class="type">Int</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">var</span> next: <span class="type">ListNode?</span></span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">init</span>(<span class="number">_</span> val: <span class="type">Int</span>) &#123;</span><br><span class="line">     <span class="keyword">self</span>.val = val</span><br><span class="line">     <span class="keyword">self</span>.next = <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">addTwoNumbers</span><span class="params">(<span class="number">_</span> l1: ListNode?, <span class="number">_</span> l2: ListNode?)</span></span> -&gt; <span class="type">ListNode?</span> &#123;</span><br><span class="line">    	<span class="keyword">var</span> l1 = l1</span><br><span class="line">        <span class="keyword">var</span> l2 = l2</span><br><span class="line">        <span class="keyword">var</span> prev = <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">var</span> carry = <span class="number">0</span></span><br><span class="line">        <span class="keyword">let</span> head = prev</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> l1 != <span class="literal">nil</span> || l2 != <span class="literal">nil</span> || carry != <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">let</span> cur = <span class="type">ListNode</span>(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">let</span> sum = (l2 == <span class="literal">nil</span> ? <span class="number">0</span> : l2!.val) + (l1 == <span class="literal">nil</span> ? <span class="number">0</span> : l1!.val) + carry</span><br><span class="line">            cur.val = sum % <span class="number">10</span></span><br><span class="line">            carry = sum / <span class="number">10</span></span><br><span class="line">            prev.next = cur</span><br><span class="line">            prev = cur</span><br><span class="line">            l1 = l1 == <span class="literal">nil</span> ? l1: l1?.next</span><br><span class="line">            l2 = l2 == <span class="literal">nil</span> ? l2: l2?.next</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="递归">递归</h4>
<p>这道题比较简单，递归模式也比较好想到 加法需要三个值，两个操作符（来自两个链表）以及一个进位标记。 因此递归模式为：</p>
<ul>
<li>递归出口：两个链表都已经到达末尾，并且没有进位</li>
<li>递归实现：
<ul>
<li>当前节点的结果为：和/10</li>
<li>当前节点的next节点为：对于两个链表next节点的计算的结果</li>
</ul></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2, <span class="keyword">int</span> carry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1 &amp;&amp; !l2 &amp;&amp; !carry) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = (l1?l1-&gt;val:<span class="number">0</span>) + (l2?l2-&gt;val:<span class="number">0</span>) + carry;</span><br><span class="line">        ListNode *ans = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">        ans-&gt;next = addTwoNumbers(l1?l1-&gt;next:<span class="literal">nullptr</span>, l2?l2-&gt;next:<span class="literal">nullptr</span>, sum / <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addTwoNumbers(l1, l2, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度">时间复杂度</h3>
<p>遍历次数：<code>max(len(l1), len(l2)) + 1</code>，因此是线性时间 \(\)</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p>额外申请了和一个链表，因此空间复杂度也为 \(\)</p>
]]></content>
      <categories>
        <category>Groking The Coding Interview</category>
      </categories>
      <tags>
        <tag>educative.io</tag>
      </tags>
  </entry>
  <entry>
    <title>单例如何释放</title>
    <url>/2019/12/04/How-To-Release-Singleton-iOS/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="ios-weak关键字">iOS weak关键字</h1>
<p>weak 关键字的运用在 iOS 当中属于基础知识，在面试的时候问 weak 的用处，就像两个 iOS 程序员见面寒暄问候一样普通了。</p>
<p>weak 的常见场景是在 delegate，block，NSTimer 中使用，以避免循环引用所带来的内存泄漏，这是教科书式的用法。</p>
<p>编程语言是工具，语言特性只是工具的特性，工具怎么用在于使用者。weak 关键字的方便之处绝不局限于避免循环引用，适当脑洞，可以在其他场景下带来一些有趣的应用。</p>
<p>weak 的用处用一句话可归纳为：弱引用，在对象释放后置为 nil，避免错误的内存访问。用更通俗的话来表述是：weak 可以在不增加对象的引用计数的同时，又使得指针的访问是安全的。</p>
<a id="more"></a>
<h2 id="weak-singleton">weak singleton</h2>
<p>之前见过一篇文章介绍了一个新 pattern 叫 「weak singleton」。这种特殊的单例有一个有意思的特性：在所有使用该单例的对象都释放后，单例对象本身也会自己释放。我所见过的大部分单例使用场景，被创建都单例最后都会一直存活着，比如注册登录模块所需要共享状态所创建的 XXLoginManager，即使在用户注册成功进入主界面之后也不会被显式的释放，这在一定程度上会带来内存使用的浪费。所谓的「weak singleton」代码很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+ (id)sharedInstance</span><br><span class="line">&#123;</span><br><span class="line">    static __weak ASingletonClass *instance;</span><br><span class="line">    ASingletonClass *strongInstance &#x3D; instance;</span><br><span class="line">    @synchronized(self) &#123;</span><br><span class="line">        if (strongInstance &#x3D;&#x3D; nil) &#123;</span><br><span class="line">            strongInstance &#x3D; [[[self class] alloc] init];</span><br><span class="line">            instance &#x3D; strongInstance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return strongInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>「weak singleton」这个漂亮名字背后其实只是简单而巧妙的利用了 weak 特性，sharedInstance 中的 weak 就像是一个智能管家，在无人使用 instance 之后就置为 nil 销毁，当 sharedInstance 再次被调用时，instance 又会重新被创建。</p>
<h2 id="ps-还有另一个方式可以释放单例">PS: 还有另一个方式可以释放单例</h2>
<p>主要思路是单例是靠 <code>dispatch_once_t</code> 类型的 <code>token</code> 来确保初始化，只执行一次，来实现单例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static dispatch_once_t * once_token_factory;</span><br><span class="line">+ (ZDocUIFactory *)sharedInstance&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    once_token_factory &#x3D; &amp;onceToken;</span><br><span class="line">    static id factory &#x3D; nil;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        factory &#x3D; [[ZDocUIFactory alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return factory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)destoryFactory&#123;</span><br><span class="line">    *once_token_factory &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>单例</tag>
      </tags>
  </entry>
  <entry>
    <title>LinkedList</title>
    <url>/2020/06/30/LinkedList/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="链表总结">链表总结</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> v) : value(v), next(<span class="literal">nullptr</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="常见题型">常见题型</h3>
<h4 id="给定链表删除所有重复元素使得每一个元素只出现一次">给定链表，删除所有重复元素，使得每一个元素只出现一次</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">deleteDuplicates</span><span class="params">(ListNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="function">ListNode <span class="title">dummy</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">        ListNode *pre = &amp;dummy, pre-&gt;next = root;</span><br><span class="line">        <span class="keyword">while</span> (root) &#123;</span><br><span class="line">            <span class="keyword">while</span>(root &amp;&amp; root-&gt;value == pre-&gt;next-&gt;value)</span><br><span class="line">                root = root-&gt;next;</span><br><span class="line">            pre-&gt;next-&gt;next = root;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur &amp;&amp; cur-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;value == cur-&gt;next-&gt;value)</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="给定链表删除所有的重复元素">给定链表，删除所有的重复元素</h4>
<ul>
<li>树是递归定义的，因此可以用递归求解</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplicates</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span> (head-&gt;next &amp;&amp; head-&gt;value == head-&gt;next-&gt;value) &#123;</span><br><span class="line">            <span class="keyword">while</span> (head &amp;&amp; head-&gt;next &amp;&amp; head-&gt;value == head-&gt;next-&gt;value) &#123;</span><br><span class="line">                head = head-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> deleteDuplicates(head-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        head-&gt;next = deleteDuplicates(head-&gt;next);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="翻转链表">翻转链表</h4>
<ul>
<li><p>非递归 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *cur = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span> (head) &#123;</span><br><span class="line">            ListNode *next = head-&gt;next;</span><br><span class="line">            head-&gt;next = cur;</span><br><span class="line">            cur = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
<li><p>递归 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode *node = reverseList(head-&gt;next);</span><br><span class="line">        head-&gt;next-&gt;next = head;</span><br><span class="line">        head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p></li>
</ul>
<h4 id="merge-two-lists">Merge Two Lists</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">mergeTwoList</span><span class="params">(ListNode *l1, ListNode *l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line"></span><br><span class="line">        ListNode *cur = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            cur = l1;</span><br><span class="line">            cur-&gt;next = mergeTwoLists(cur-&gt;next, l2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur = l2;</span><br><span class="line">            cur-&gt;next = mergeTwoLists(l1, cur-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LongestSubstringWithoutRepeatingCharacters</title>
    <url>/2019/11/22/LongestSubstringWithoutRepeatingCharacters/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/">Longest Substring Without Repeating Characters</a> Given a string, find the length of the longest substring without repeating characters.</p>
<p>Example 1: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">&quot;abcabcbb&quot;</span></span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is <span class="string">&quot;abc&quot;</span>, with the length of 3.</span><br></pre></td></tr></table></figure> Example 2: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">&quot;bbbbb&quot;</span></span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is <span class="string">&quot;b&quot;</span>, with the length of 1.</span><br></pre></td></tr></table></figure> Example 3: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">&quot;pwwkew&quot;</span></span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is <span class="string">&quot;wke&quot;</span>, with the length of 3.</span><br><span class="line">             Note that the answer must be a substring, <span class="string">&quot;pwke&quot;</span> is a subsequence and not a substring.</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>给定一个字符串，求<code>最长</code>的<code>无重复字符</code>的<code>子串</code></li>
<li>子串：没有重复的字符</li>
<li>子串长度：<code>右边-左边</code></li>
</ul>
<h3 id="理解例子">理解例子</h3>
<h4 id="例子-1">例子 1</h4>
<ul>
<li>输入：<code>abcabcbb</code></li>
<li>输出：<code>3</code></li>
<li>最长的子串：abc/bca/cab 长度为 3</li>
</ul>
<h3 id="思路">思路</h3>
<ul>
<li>题目要求计算最长子串长度，并且是无重复的子串。</li>
<li>字符串的长度的计算：<code>当前位置-开始位置</code></li>
<li>那么随后的问题就是如何计算开始位置。</li>
<li>如果没有重复子串出现过，那么开始位置就是0，如果重复子串出现过，那么开始位置就是这个位置的下一个位置。</li>
<li>需要一个数据结构来记录每一个字符上一次出现的位置</li>
</ul>
<h4 id="流程">流程</h4>
<ul>
<li>遍历整个字符串</li>
<li>针对每一个字符，在合适的时候更新<code>left</code>，那么剩下的问题就是何时更新<code>left</code></li>
<li>针对每一个字符，计算并保存最大的长度</li>
<li>遍历完成后返回最大的长度</li>
<li>时间复杂度：线性时间 \(\)</li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">pos_map</span><span class="params">(<span class="number">256</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            start = max(pos_map[s[i]]+<span class="number">1</span>, start);</span><br><span class="line">            pos_map[s[i]] = i;</span><br><span class="line">            ans = max(ans, i - start+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度">时间复杂度</h3>
<p>如一开始分析：时间复杂度：线性时间 \(\)</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p>额外申请了和一个链表，因此空间复杂度也为 \(\)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>Longest Valid Parentheses</title>
    <url>/2020/04/20/LongestValidParentheses/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://leetcode.com/problems/longest-valid-parentheses/">Longest Valid Parentheses</a> Given a string containing just the characters '(' and ')', find the length of the longest valid (well-formed) parentheses substring.</p>
<p>Example 1: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">&quot;(()&quot;</span></span><br><span class="line">Output: 2</span><br><span class="line">Explanation: The longest valid parentheses substring is <span class="string">&quot;</span></span><br><span class="line"><span class="string">()&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>Example 2: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: <span class="string">&quot;)()())&quot;</span></span><br><span class="line">Output: 4</span><br><span class="line">Explanation: The longest valid parentheses substring is <span class="string">&quot;()()&quot;</span></span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>给定字符串，只包含：<code>(</code> , <code>)</code></li>
<li>要求找出最长的合法的括号对长度</li>
</ul>
<h3 id="理解例子">理解例子</h3>
<ul>
<li><code>(()</code> = <code>2</code></li>
<li>第一个 <code>(</code> 不能与后面的组成合法括号对，所以最长为 2</li>
<li><code>)()())</code> = <code>4</code></li>
<li>因为只有中间的两对为合法括号对，因此为 4</li>
</ul>
<h3 id="思路">思路</h3>
<ul>
<li>括号配对一般都用栈 : <code>stack</code></li>
<li>既然是计数，就得知道从哪个地方开始，匹配的括号肯定是以 <code>(</code> 作为初始值，但要求最长就肯定得知道什么时候连续匹配被截断</li>
<li>如果有匹配的 <code>()</code> 那么就会以<code>(</code>为计数的起点计数。</li>
<li>如果没有匹配的 <code>()</code> 像 <code>)</code> 计数就得从头开始</li>
<li>需要保存到目前为止的最大值</li>
</ul>
<h3 id="代码">代码</h3>
<h3 id="栈">栈</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestValidParentheses</span><span class="params">(<span class="built_in">string</span>&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk_;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i]==<span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                stk_.push(i);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (stk_.empty()) &#123;</span><br><span class="line">                    start = i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> curLen = stk_.empy() ? i - start + <span class="number">1</span> : i - stk.top();</span><br><span class="line">                ans = max(ans, curLen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度">时间复杂度</h3>
<p>遍历次数：<code>O(n)</code>，因此是线性时间，每个元素只遍历一次</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p><code>O(n)</code> 表示栈的大小</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>LowerBound</title>
    <url>/2020/04/25/LowerBound/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="lowerbound">LowerBound</h2>
<p>Lower Bound 是使用二分查找的办法求 大于等于 i 的第一个位置 <a id="more"></a></p>
<h2 id="代码">代码</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lowerBound</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.size();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= i) &#123;</span><br><span class="line">                r = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度">时间复杂度</h3>
<p>O(logn)</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p>O(1)</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac_NSTextView_中英混输情况下_inline_上下抖动</title>
    <url>/2020/10/05/Mac-NSTextView-%E4%B8%AD%E8%8B%B1%E6%B7%B7%E8%BE%93%E6%83%85%E5%86%B5%E4%B8%8B-inline-%E4%B8%8A%E4%B8%8B%E6%8A%96%E5%8A%A8/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="问题由来">问题由来</h1>
<p>今天在做项目的时候，发现自定义的 <code>NSTextView</code> 出现了几种情况比较蛋疼</p>
<ul>
<li><p>对齐问题，英文对齐，中文偏移</p></li>
<li><p>在中英文混输的情况下，会出现之前的文字上下抖动的情况，可以拿出来钉钉试试</p></li>
</ul>
<blockquote>
<p>先在输入框中输入中文（<code>啊</code>），空格上屏后，再输入一个英文字符 <code>a</code></p>
</blockquote>
<blockquote>
<p>不断地尝试删除 <code>a</code>，再输入 <code>a</code></p>
</blockquote>
<blockquote>
<p>你会看到 <code>啊</code> 会随着你的输入和删除上下做轻微的抖动，感觉在拍抖音，给个背景音乐很应景</p>
</blockquote>
<h1 id="自己的项目">自己的项目</h1>
<p>出现了同样的问题，而且更严重的是，同样的输入框，在作为用户签名的时候，中文会有明显的偏移 &gt; 英文对齐，中文上偏</p>
<h1 id="解决">解决</h1>
<p>尝试了很多办法，其实比较简单，让自定义的 <code>layoutManager</code> 和 <code>textContainer</code> 去适配一下。 关键代码如下</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">textStorage.addLayoutManager(layoutManager)</span><br><span class="line">layoutManager.addTextContainer(textContainer)</span><br><span class="line">layoutManager.typesetterBehavior = .behavior_10_2_WithCompatibility</span><br></pre></td></tr></table></figure>
<p>前后比较一下，所有问题都消失了</p>
]]></content>
      <categories>
        <category>Mac Develop</category>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Mac Develop</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Majority Element</title>
    <url>/2020/06/04/MajorityElement/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://leetcode.com/problems/majority-element/">Majority Element</a> Given an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p>Example 1: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure> Example 2: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: [2,2,1,1,1,2,2]</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure> <a id="more"></a></p>
<h2 id="解题报告">解题报告</h2>
<h3 id="哈希表">哈希表</h3>
<ul>
<li>对每一个元素计数，找到大于 n/2 的元素返回即可</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; map_;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num:numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (++map_[num] &gt; numbers.size() / <span class="number">2</span>)</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="排序">排序</h3>
<ul>
<li>因为满足需求的个数是至少 n / 2， 因此只需要找到排序后处于一半位置的元素就是答案。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        nth_element(numbers.begin(), numbers.begin() + numbers.size() / <span class="number">2</span>, numbers.end());</span><br><span class="line">        <span class="keyword">return</span> numbers[numbers.size()/<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="divide-and-conquer">Divide and Conquer</h3>
<ul>
<li>递归的找两部分的 majority，最后合并结果，递归出口就是单个元素</li>
<li><code>algorithm</code> 中有个 count 函数，类似于 find，主要是使用一对迭代器和一个值作为参数，返回值出现的次数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">        function&lt;<span class="keyword">int</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="keyword">int</span> ,<span class="keyword">int</span> )&gt; majorityElementHelper = [&amp;](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; element, <span class="keyword">int</span> l, <span class="keyword">int</span> r)&#123;</span><br><span class="line">            <span class="keyword">if</span> (l == r) <span class="keyword">return</span> element[l];</span><br><span class="line">            <span class="keyword">int</span> m = l + (r-l)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> lm = majorityElementHelper(elements, l, m);</span><br><span class="line">            <span class="keyword">int</span> rm = majorityElementHelper(elements, m+<span class="number">1</span>, r);</span><br><span class="line">            <span class="keyword">if</span> (lm == rm) <span class="keyword">return</span> lm;</span><br><span class="line">            <span class="keyword">return</span> count(nums.begin() + l, nums.begin() + r + <span class="number">1</span>, lm) &gt; count(nums.begin() + l, nums.begin() + r + <span class="number">1</span>, rm) ? lm : rm;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> majorityElementHelper(numbers,<span class="number">0</span>, numbers.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="moore-voting-algorithm">Moore Voting Algorithm</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>, majority;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num:numbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!count) &#123;</span><br><span class="line">                majority = num;</span><br><span class="line">            &#125;</span><br><span class="line">            count += (num == majority) <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="位操作">位操作</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;numbers)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> majority = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>, mask = <span class="number">1</span>; i &lt; <span class="number">32</span>; i++, mask &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> bits = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> num : numbers) &#123;</span><br><span class="line">                <span class="keyword">if</span> (num &amp; mask) &#123;</span><br><span class="line">                    bits++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (bits &gt; numbers.size() / <span class="number">2</span>) &#123;</span><br><span class="line">                majority |= mask;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Medium</tag>
      </tags>
  </entry>
  <entry>
    <title>MaxCounter</title>
    <url>/2020/10/06/MaxCounter/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://app.codility.com/demo/results/training7GBQ3S-T9U/">MaxCounters</a> You are given N counters, initially set to 0, and you have two possible operations on them:</p>
<p>increase(X) − counter X is increased by 1, max counter − all counters are set to the maximum value of any counter. A non-empty array A of M integers is given. This array represents consecutive operations:</p>
<p>if A[K] = X, such that 1 ≤ X ≤ N, then operation K is increase(X), if A[K] = N + 1 then operation K is max counter. For example, given integer N = 5 and array A such that:</p>
<pre><code>A[0] = 3
A[1] = 4
A[2] = 4
A[3] = 6
A[4] = 1
A[5] = 4
A[6] = 4</code></pre>
<p>the values of the counters after each consecutive operation will be:</p>
<pre><code>(0, 0, 1, 0, 0)
(0, 0, 1, 1, 0)
(0, 0, 1, 2, 0)
(2, 2, 2, 2, 2)
(3, 2, 2, 2, 2)
(3, 2, 2, 3, 2)
(3, 2, 2, 4, 2)</code></pre>
<p>The goal is to calculate the value of every counter after all operations.</p>
<p>Write a function:</p>
<p>vector<int> solution(int N, vector<int> &amp;A);</p>
<p>that, given an integer N and a non-empty array A consisting of M integers, returns a sequence of integers representing the values of the counters.</p>
<p>Result array should be returned as a vector of integers.</p>
<p>For example, given:</p>
<pre><code>A[0] = 3
A[1] = 4
A[2] = 4
A[3] = 6
A[4] = 1
A[5] = 4
A[6] = 4</code></pre>
<p>the function should return [3, 2, 2, 4, 2], as explained above.</p>
<p>Write an efficient algorithm for the following assumptions:</p>
<p>N and M are integers within the range [1..100,000]; each element of array A is an integer within the range [1..N + 1].</p>
<a id="more"></a>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>根据他给的规则，填充即可。</li>
<li>但他有个恶心的地方就是有个规则是将数组的全部内容设置为最大值。</li>
<li>如果嵌套循环 O(N^2) 肯定超时，那肯定是需要记下来最大的值。</li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// you can use includes, for example:</span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// you can write to stdout for debugging purposes, e.g.</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;this is a debug message&quot; &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">solution</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ans</span><span class="params">(N, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> curMax = <span class="number">0</span>, baseValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = A[i]<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (A[i] &gt;=<span class="number">1</span> &amp;&amp; A[i] &lt;= N)&#123;</span><br><span class="line">            ans[idx] = max(baseValue, ans[idx]) + <span class="number">1</span>;</span><br><span class="line">            curMax = max(curMax, ans[idx]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (A[i] == N+<span class="number">1</span>) &#123;</span><br><span class="line">            baseValue = curMax;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans[i] &lt; baseValue) &#123;</span><br><span class="line">            ans[i] = baseValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度">时间复杂度</h3>
<p><code>O(N)</code></p>
]]></content>
      <categories>
        <category>Codility</category>
      </categories>
      <tags>
        <tag>Codility</tag>
      </tags>
  </entry>
  <entry>
    <title>MedianOfTwoSortedArrays</title>
    <url>/2019/11/23/MedianOfTwoSortedArrays/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/">Median of Two Sorted Arrays</a> There are two sorted arrays nums1 and nums2 of size m and n respectively.</p>
<p>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</p>
<p>You may assume nums1 and nums2 cannot be both empty.</p>
<p>Example 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">The median is 2.0</span><br></pre></td></tr></table></figure>
<p>Example 2: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">The median is (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure> <a id="more"></a></p>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>两个数组：m &amp; n （已排好序）</li>
<li>找到两个数组的中间节点</li>
<li>时间复杂度要求：\(\)</li>
</ul>
<h3 id="理解例子">理解例子</h3>
<h4 id="例子-1">例子 1</h4>
<ul>
<li>nums1：<code>[1, 3]</code></li>
<li>nums2：<code>[2]</code></li>
<li>中间的元素为 2， 因为总共3个元素：1，2，3；</li>
</ul>
<h4 id="例子-2">例子 2</h4>
<ul>
<li>nums1：<code>[1, 2]</code></li>
<li>nums2：<code>[3，4]</code></li>
<li>中间的元素为 2.5， 因为总共4个元素：<code>[1，2，3，4]</code>；（2+3）/2 = 2.5</li>
</ul>
<h3 id="思路">思路</h3>
<ul>
<li>从例子来看，把两个数组的元素分别插入到一个新的数组，然后再遍历找到居中的元素，时间复杂度为\(\)。</li>
<li>要求时间复杂度为 \(\)，这个算是比较强烈的提示（对n个元素折半查找-<code>BinarySearch</code>就是 \(\)）</li>
<li>那么剩下的问题就是如何折半，哪里到哪里折半，怎么调整lr.</li>
<li>其实最终的找到的点：左半部分小于右半部分。第一个数组的左半部分小于第二个数组的右半部分，第二个数组的左半部分小于第二个数组的右半部分。并且是合并后数组中间的部分。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> result)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">0</span>, r = vec.size();</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">     <span class="keyword">int</span> mid = (r + l)/<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">if</span> (vec[mid] == result) <span class="keyword">return</span> mid; <span class="comment">// found the result</span></span><br><span class="line">     <span class="keyword">if</span> (vec[mid] &gt; result) &#123; <span class="comment">// the index is on the left side of mid</span></span><br><span class="line">         r = mid;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         l = mid+<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> result)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">if</span> (vec[mid] == result) <span class="keyword">return</span> mid;</span><br><span class="line">     <span class="keyword">if</span> (vec[mid] &gt; result) &#123;</span><br><span class="line">         <span class="keyword">return</span> binarySearch(vec, l, mid, result);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> binarySearch(vec, mid+<span class="number">1</span>, r, result);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>假定合并后的数组为C</li>
<li>从第一个数组取m1个元素，第二个元素取m2个元素，来构成前k个元素，来满足第k/k+1个元素就是中位数的候选数。其中k = m1 + m2 = (m + n + 1)/2。加 1 是为了不用考虑奇偶。</li>
<li>找到的元素为 \(\),根据总数奇数和偶数。</li>
<li></li>
</ul>
<h4 id="流程">流程</h4>
<ul>
<li>如果某一个为空，则返回另一个数组的中间元素即可</li>
<li></li>
<li>遍历完成后返回最大的长度</li>
<li>时间复杂度：线性时间 \(\)</li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMediaSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> findMediaSortedArrays(nums2, nums1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度">时间复杂度</h3>
<p>如一开始分析：时间复杂度：线性时间 \(\)</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p>额外申请了和一个链表，因此空间复杂度也为 \(\)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>Minimum Number of Flips to Convert Binary Matrix to Zero Matrix</title>
    <url>/2019/12/11/MinimumNumberofFlipsToConvertBinaryMatrixToZero/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://leetcode.com/problems/minimum-number-of-flips-to-convert-binary-matrix-to-zero-matrix/">Minimum Number of Flips to Convert Binary Matrix to Zero Matrix</a> Given a m x n binary matrix mat. In one step, you can choose one cell and flip it and all the four neighbours of it if they exist (Flip is changing 1 to 0 and 0 to 1). A pair of cells are called neighboors if they share one edge.</p>
<p>Return the minimum number of steps required to convert mat to a zero matrix or -1 if you cannot.</p>
<p>Binary matrix is a matrix with all cells equal to 0 or 1 only.</p>
<p>Zero matrix is a matrix with all cells equal to 0.</p>
<p>Example 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: mat = [[0,0],[0,1]]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: One possible solution is to flip (1, 0) <span class="keyword">then</span> (0, 1) and finally (1, 1) as shown.</span><br></pre></td></tr></table></figure>
<p>Example 2:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: mat = [[0]]</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: Given matrix is a zero matrix. We don<span class="string">&#x27;t need to change it.</span></span><br></pre></td></tr></table></figure>
<p>Example 3:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Input: mat = [[1,1,1],[1,0,1],[0,0,0]]</span><br><span class="line">Output: 6</span><br><span class="line">Example 4:</span><br><span class="line"></span><br><span class="line">Input: mat = [[1,0,0],[1,0,0]]</span><br><span class="line">Output: -1</span><br><span class="line">Explanation: Given matrix can<span class="string">&#x27;t be a zero matrix</span></span><br></pre></td></tr></table></figure>
<p>Constraints:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">m == mat.length</span><br><span class="line">n == mat[0].length</span><br><span class="line">1 &lt;= m &lt;= 3</span><br><span class="line">1 &lt;= n &lt;= 3</span><br><span class="line">mat[i][j] is 0 or 1.</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>给定一个数组 m * n</li>
<li>数字只有 <code>0</code> 或者 <code>1</code></li>
<li>flip 时必须：五个相邻数字（自己、上、下、左、右）。</li>
<li>目标状态为全部为 0</li>
</ul>
<h3 id="理解例子">理解例子</h3>
<h4 id="例子-1">例子 1</h4>
<ul>
<li>S：<code>[[0, 0], [0, 1]]</code></li>
<li>结果：3</li>
</ul>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">0</th>
<th style="text-align: center;">0</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">0</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<h3 id="思路">思路</h3>
<ul>
<li>看到题目应该就会反映到会使用<code>BFS</code>来解决问题：（每次拓展上下左右和自己）</li>
<li>每次拓展的时候回尝试将周边的数字进行翻转</li>
<li>终止状态：找到全0、全部遍历完毕，并且记录步数。</li>
<li>因为只有0/1两个数字。因此可以考虑使用状态压缩来将二维数组进行降维。</li>
<li>考虑将例子中的二维数组：<code>[[0,0],[0,1]]</code> ---&gt; <code>[0001]</code>,这样时间复杂度就会缩短。</li>
</ul>
<h4 id="划分">划分</h4>
<ul>
<li>可以把划分想象成两个部分，左边和右边。</li>
<li>左边：是从 0...j 进行 k-1 次的划分。右边： 一次划分（）。</li>
<li><code>dp_[i][k] = min&#123;dp_[i][k], dp_[j][k-1] + dp_change[j][i]&#125;</code></li>
<li><code>dp_change[j][i]</code> 表示从j到i 的最小更换次数。</li>
</ul>
<h4 id="更改字符">更改字符</h4>
<ul>
<li>如果划分确定后，如何更改字符就比较好确定了</li>
<li>回文字符串应该从中间开始构建，并且向两边拓展</li>
<li>如果前后两个字符相等<code>(str[i] == str[j]): dp_change[i][j] = dp_change[i+1][j-1]</code></li>
<li>如果前后两个字符不等<code>(str[i] != str[j]): dp_change[i][j] = 1 + dp_change[i+1][j-1]</code></li>
<li><code>dp_change[i][j] = (str[i] != str[j]) + dp_change[i+1][j-1]</code></li>
</ul>
<p>解决了以上两个问题，那完整的问题，就解决了</p>
<h4 id="流程">流程</h4>
<ul>
<li>异常判断</li>
<li>针对所有的位置，尝试所有的分割，</li>
</ul>
<h4 id="伪代码">伪代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">palindromePartition</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMediaSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> findMediaSortedArrays(nums2, nums1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度">时间复杂度</h3>
<p>如一开始分析：时间复杂度：线性时间 \(\)</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p>额外申请了和一个链表，因此空间复杂度也为 \(\)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>MissingInteger</title>
    <url>/2020/10/06/MissingInteger/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://app.codility.com/demo/results/trainingD8SCXY-ZS4/">MissingInteger</a> This is a demo task.</p>
<p>Write a function:</p>
<p>int solution(vector<int> &amp;A);</p>
<p>that, given an array A of N integers, returns the smallest positive integer (greater than 0) that does not occur in A.</p>
<p>For example, given A = [1, 3, 6, 4, 1, 2], the function should return 5.</p>
<p>Given A = [1, 2, 3], the function should return 4.</p>
<p>Given A = [−1, −3], the function should return 1.</p>
<p>Write an efficient algorithm for the following assumptions:</p>
<p>N is an integer within the range [1..100,000]; each element of array A is an integer within the range [−1,000,000..1,000,000].</p>
<a id="more"></a>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>给个无序数组，大于 0</li>
<li>返回从 1 开始数，缺失的第一个数。</li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// you can use includes, for example:</span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="comment">// you can write to stdout for debugging purposes, e.g.</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;this is a debug message&quot; &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; memo_;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++)</span><br><span class="line">        <span class="keyword">if</span>(A[i] &gt; <span class="number">0</span>) memo_[A[i]] = i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这块有个坑，如果边界为 memo_.size()，1, 3, 6, 4, 1, 2 会出错</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; memo_.size() + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (memo_.find(i) == memo_.end()) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> memo_.size() + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度">时间复杂度</h3>
<p><code>O(N)</code></p>
]]></content>
      <categories>
        <category>Codility</category>
      </categories>
      <tags>
        <tag>Codility</tag>
      </tags>
  </entry>
  <entry>
    <title>莫里斯遍历二叉树</title>
    <url>/2019/12/03/Moris-Traversal-Binary-Tree/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="问题">问题</h2>
<ol type="1">
<li>遍历二叉树</li>
<li>O(1)的时间复杂度</li>
<li>二叉树的形状不能破坏</li>
</ol>
<a id="more"></a>
<h2 id="常规遍历">常规遍历</h2>
<p>常规遍历使用递归，一般需要O(n)的空间复杂度和O(n)的时间复杂度。</p>
<p>You may assume nums1 and nums2 cannot be both empty.</p>
<p>Example 1:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">The median is 2.0</span><br></pre></td></tr></table></figure>
<p>Example 2: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">The median is (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure></p>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>两个数组：m &amp; n （已排好序）</li>
<li>找到两个数组的中间节点</li>
<li>时间复杂度要求：\(\)</li>
</ul>
<h3 id="理解例子">理解例子</h3>
<h4 id="例子-1">例子 1</h4>
<ul>
<li>nums1：<code>[1, 3]</code></li>
<li>nums2：<code>[2]</code></li>
<li>中间的元素为 2， 因为总共3个元素：1，2，3；</li>
</ul>
<h4 id="例子-2">例子 2</h4>
<ul>
<li>nums1：<code>[1, 2]</code></li>
<li>nums2：<code>[3，4]</code></li>
<li>中间的元素为 2.5， 因为总共4个元素：<code>[1，2，3，4]</code>；（2+3）/2 = 2.5</li>
</ul>
<h3 id="思路">思路</h3>
<ul>
<li>从例子来看，把两个数组的元素分别插入到一个新的数组，然后再遍历找到居中的元素，时间复杂度为\(\)。</li>
<li>要求时间复杂度为 \(\)，这个算是比较强烈的提示（对n个元素折半查找-<code>BinarySearch</code>就是 \(\)）</li>
<li>顺着思路想：折半查找的问题就是如何使用折半查找找到需要的数，</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> result)</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> l = <span class="number">0</span>, r = vec.size();</span><br><span class="line">  <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">     <span class="keyword">int</span> mid = (r + l)/<span class="number">2</span>;</span><br><span class="line">     <span class="keyword">if</span> (vec[mid] == result) <span class="keyword">return</span> mid; <span class="comment">// found the result</span></span><br><span class="line">     <span class="keyword">if</span> (vec[mid] &gt; result) &#123; <span class="comment">// the index is on the left side of mid</span></span><br><span class="line">         r = mid;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         l = mid+<span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归版本</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> result)</span></span>&#123;</span><br><span class="line">     <span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">     <span class="keyword">if</span> (vec[mid] == result) <span class="keyword">return</span> mid;</span><br><span class="line">     <span class="keyword">if</span> (vec[mid] &gt; result) &#123;</span><br><span class="line">         <span class="keyword">return</span> binarySearch(vec, l, mid, result);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> binarySearch(vec, mid+<span class="number">1</span>, r, result);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>假定合并后的数组为C</li>
<li>从第一个数组取m1个元素，第二个元素取m2个元素，来构成前k个元素，来满足第k/k+1个元素就是中位数的候选数。其中k = m1 + m2 = (m + n + 1)/2。</li>
<li>找到的元素为 \(\),根据总数奇数和偶数。</li>
<li>对左边的数组，在左边数组的区间内进行二分搜索， ，</li>
</ul>
<h4 id="流程">流程</h4>
<ul>
<li>如果某一个为空，则返回另一个数组的中间元素即可</li>
<li></li>
<li>遍历完成后返回最大的长度</li>
<li>时间复杂度：线性时间 \(\)</li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMediaSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> findMediaSortedArrays(nums2, nums1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度">时间复杂度</h3>
<p>如一开始分析：时间复杂度：线性时间 \(\)</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p>额外申请了和一个链表，因此空间复杂度也为 \(\)</p>
]]></content>
      <categories>
        <category>Binary Tree</category>
      </categories>
  </entry>
  <entry>
    <title>OddOccurrencesInArray</title>
    <url>/2020/06/29/OddOccurrencesInArray/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://app.codility.com/demo/results/trainingFNUJ23-65K/">OddOccurrencesInArray</a> A non-empty array A consisting of N integers is given. The array contains an odd number of elements, and each element of the array can be paired with another element that has the same value, except for one element that is left unpaired.</p>
<p>For example, in array A such that:</p>
<p>A[0] = 9 A[1] = 3 A[2] = 9 A[3] = 3 A[4] = 9 A[5] = 7 A[6] = 9 the elements at indexes 0 and 2 have value 9, the elements at indexes 1 and 3 have value 3, the elements at indexes 4 and 6 have value 9, the element at index 5 has value 7 and is unpaired. Write a function:</p>
<p>int solution(vector<int> &amp;A);</p>
<p>that, given an array A consisting of N integers fulfilling the above conditions, returns the value of the unpaired element.</p>
<p>For example, given array A such that:</p>
<p>A[0] = 9 A[1] = 3 A[2] = 9 A[3] = 3 A[4] = 9 A[5] = 7 A[6] = 9 the function should return 7, as explained in the example above.</p>
<p>Write an efficient algorithm for the following assumptions:</p>
<p>N is an odd integer within the range [1..1,000,000]; each element of array A is an integer within the range [1..1,000,000,000]; all but one of the values in A occur an even number of times. <a id="more"></a></p>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>数组内有多个元素，只有一个是出现一次，其余的都是成对出现。求该单一数字是什么</li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">        ans ^= A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Codility</category>
      </categories>
      <tags>
        <tag>Medium</tag>
        <tag>Codility</tag>
      </tags>
  </entry>
  <entry>
    <title>Palindrome Paritioning III</title>
    <url>/2019/12/04/ParlindromPartition-III/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://leetcode.com/contest/weekly-contest-165/problems/palindrome-partitioning-iii/">Palindrome Partitioning III</a> You are given a string s containing lowercase letters and an integer k. You need to :</p>
<p>First, change some characters of s to other lowercase English letters. Then divide s into k non-empty disjoint substrings such that each substring is palindrome. Return the minimal number of characters that you need to change to divide the string.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: s = <span class="string">&quot;abc&quot;</span>, k = 2</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: You can split the string into <span class="string">&quot;ab&quot;</span> and <span class="string">&quot;c&quot;</span>, and change 1 character <span class="keyword">in</span> <span class="string">&quot;ab&quot;</span> to make it palindrome.</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: s = <span class="string">&quot;aabbc&quot;</span>, k = 3</span><br><span class="line">Output: 0</span><br><span class="line">Explanation: You can split the string into <span class="string">&quot;aa&quot;</span>, <span class="string">&quot;bb&quot;</span> and <span class="string">&quot;c&quot;</span>, all of them are palindrome.</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: s = <span class="string">&quot;leetcode&quot;</span>, k = 8</span><br><span class="line">Output: 0</span><br></pre></td></tr></table></figure>
<p>Constraints:</p>
<p>1 &lt;= k &lt;= s.length &lt;= 100. s only contains lowercase English letters.</p>
<a id="more"></a>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>给定字符串s，和整数k</li>
<li>改变s中的一些字符</li>
<li>将s划分问k个非空回文子串</li>
<li>求最小的更改字符的次数</li>
<li>强烈提示：字符串长度最长100 --&gt; 时间复杂度最多10^6 （也就是n^3）</li>
</ul>
<h3 id="理解例子">理解例子</h3>
<h4 id="例子-1">例子 1</h4>
<ul>
<li>S：<code>abc</code></li>
<li>K：<code>2</code></li>
<li>结果：1</li>
<li>将S划分为两个部分：<code>ab</code>、<code>c</code>，修改ab中的一个字符即可变成回文</li>
</ul>
<h4 id="例子-2">例子 2</h4>
<ul>
<li>S：<code>aabbc</code></li>
<li>K：<code>3</code></li>
<li>结果：0</li>
<li>将S划分为：aa、bb、c，所有的都是回文，不需要更改。</li>
</ul>
<h3 id="思路">思路</h3>
<ul>
<li>强烈提示：数据规模 -- 10^2，也就是说期望的时间复杂度为 n^3 or n^2 * k</li>
<li>计数问题，一般可以用动态规划解决。</li>
<li>题目要求k次划分，如何划分需要解决，使用动态规划一般和 <code>k-1</code> 有关系。</li>
<li>划分后，针对子串如何更换，也需要解决，并且求最小值。</li>
<li>所以就两个子问题：1. 如何划分。2.如何更换。</li>
<li><code>dp_[i][k]</code>,表示0...i的字符，进行k次划分的最小交换次数</li>
</ul>
<h4 id="划分">划分</h4>
<ul>
<li>可以把划分想象成两个部分，左边和右边。</li>
<li>左边：是从 0...j 进行 k-1 次的划分。右边： 一次划分（）。</li>
<li><code>dp_[i][k] = min&#123;dp_[i][k], dp_[j][k-1] + dp_change[j][i]&#125;</code></li>
<li><code>dp_change[j][i]</code> 表示从j到i 的最小更换次数。</li>
</ul>
<h4 id="更改字符">更改字符</h4>
<ul>
<li>如果划分确定后，如何更改字符就比较好确定了</li>
<li>回文字符串应该从中间开始构建，并且向两边拓展</li>
<li>如果前后两个字符相等<code>(str[i] == str[j]): dp_change[i][j] = dp_change[i+1][j-1]</code></li>
<li>如果前后两个字符不等<code>(str[i] != str[j]): dp_change[i][j] = 1 + dp_change[i+1][j-1]</code></li>
<li><code>dp_change[i][j] = (str[i] != str[j]) + dp_change[i+1][j-1]</code></li>
</ul>
<p>解决了以上两个问题，那完整的问题，就解决了</p>
<h4 id="流程">流程</h4>
<ul>
<li>异常判断</li>
<li>针对所有的位置，尝试所有的分割，</li>
</ul>
<h4 id="伪代码">伪代码</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">palindromePartition</span><span class="params">(<span class="built_in">string</span> &amp;str, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMediaSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = nums1.size();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = nums2.size();</span><br><span class="line">        <span class="keyword">if</span> (m &gt; n) <span class="keyword">return</span> findMediaSortedArrays(nums2, nums1);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度">时间复杂度</h3>
<p>如一开始分析：时间复杂度：线性时间 \(\)</p>
<h3 id="空间复杂度">空间复杂度</h3>
<p>额外申请了和一个链表，因此空间复杂度也为 \(\)</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>Hard</tag>
      </tags>
  </entry>
  <entry>
    <title>PassingCars</title>
    <url>/2020/10/07/PassingCars/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://app.codility.com/demo/results/trainingB4JZ2Q-S4C/">PassingCars</a></p>
<p>A non-empty array A consisting of N integers is given. The consecutive elements of array A represent consecutive cars on a road.</p>
<p>Array A contains only 0s and/or 1s:</p>
<p>0 represents a car traveling east, 1 represents a car traveling west. The goal is to count passing cars. We say that a pair of cars (P, Q), where 0 ≤ P &lt; Q &lt; N, is passing when P is traveling to the east and Q is traveling to the west.</p>
<p>For example, consider array A such that:</p>
<p>A[0] = 0 A[1] = 1 A[2] = 0 A[3] = 1 A[4] = 1 We have five pairs of passing cars: (0, 1), (0, 3), (0, 4), (2, 3), (2, 4).</p>
<p>Write a function:</p>
<p>int solution(vector<int> &amp;A);</p>
<p>that, given a non-empty array A of N integers, returns the number of pairs of passing cars.</p>
<p>The function should return −1 if the number of pairs of passing cars exceeds 1,000,000,000.</p>
<p>For example, given:</p>
<p>A[0] = 0 A[1] = 1 A[2] = 0 A[3] = 1 A[4] = 1 the function should return 5, as explained above.</p>
<p>Write an efficient algorithm for the following assumptions:</p>
<p>N is an integer within the range [1..100,000]; each element of array A is an integer that can have one of the following values: 0, 1. <a id="more"></a></p>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>给定一个数组表示汽车行进方向</li>
<li>要求计算能经过多少汽车，0 和 1 相遇才会加 1</li>
<li>前缀和，从端开始计算，碰到 0，就需要把经过的汽车都加上</li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// you can use includes, for example:</span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="comment">// you can write to stdout for debugging purposes, e.g.</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;this is a debug message&quot; &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m = A.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">prefixSum</span> <span class="params">(m, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> prefix = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">        prefix += A[i];</span><br><span class="line">        prefixSum[i] = prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = m<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (A[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            ans += prefixSum[m<span class="number">-1</span>] - prefixSum[i];</span><br><span class="line">            <span class="keyword">if</span> (ans &gt; <span class="number">1000000000</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度">时间复杂度</h3>
<p><code>O(N)</code></p>
]]></content>
      <categories>
        <category>Codility</category>
      </categories>
      <tags>
        <tag>Codility</tag>
      </tags>
  </entry>
  <entry>
    <title>PermCheck</title>
    <url>/2020/10/06/PermCheck/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://app.codility.com/demo/results/training4EJWRG-YUE/">PermCheck</a> A non-empty array A consisting of N integers is given.</p>
<p>A permutation is a sequence containing each element from 1 to N once, and only once.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">For example, array A such that:</span><br><span class="line"></span><br><span class="line">    A[0] = 4</span><br><span class="line">    A[1] = 1</span><br><span class="line">    A[2] = 3</span><br><span class="line">    A[3] = 2</span><br><span class="line">is a permutation, but array A such that:</span><br><span class="line"></span><br><span class="line">    A[0] = 4</span><br><span class="line">    A[1] = 1</span><br><span class="line">    A[2] = 3</span><br><span class="line">is not a permutation, because value 2 is missing.</span><br></pre></td></tr></table></figure>
<p>The goal is to check whether array A is a permutation.</p>
<p>Write a function:</p>
<p>int solution(vector<int> &amp;A);</p>
<p>that, given an array A, returns 1 if array A is a permutation and 0 if it is not.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">For example, given array A such that:</span><br><span class="line"></span><br><span class="line">    A[0] = 4</span><br><span class="line">    A[1] = 1</span><br><span class="line">    A[2] = 3</span><br><span class="line">    A[3] = 2</span><br><span class="line">the <span class="keyword">function</span> should <span class="built_in">return</span> 1.</span><br><span class="line"></span><br><span class="line">Given array A such that:</span><br><span class="line"></span><br><span class="line">    A[0] = 4</span><br><span class="line">    A[1] = 1</span><br><span class="line">    A[2] = 3</span><br><span class="line">the <span class="keyword">function</span> should <span class="built_in">return</span> 0.</span><br></pre></td></tr></table></figure>
<p>Write an efficient algorithm for the following assumptions:</p>
<p>N is an integer within the range [1..100,000]; each element of array A is an integer within the range [1..1,000,000,000].</p>
<a id="more"></a>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>给定一个数组，让求数组元素是否为 排列</li>
<li>排列一定是所有数都包含了，那么如果缺某一个肯定就不对，重复也肯定是错误的,那么当所有元素都插入进去，最大元素一定是和 总体个数一样。</li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// you can use includes, for example:</span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="comment">// you can write to stdout for debugging purposes, e.g.</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;this is a debug message&quot; &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; map_;</span><br><span class="line">    <span class="keyword">int</span> maxValue = INT_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i: A) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map_.count(i))</span><br><span class="line">            map_[i]++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        maxValue = max(i, maxValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxValue == map_.size();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度">时间复杂度</h3>
<p><code>O(N)</code></p>
]]></content>
      <categories>
        <category>Codility</category>
      </categories>
      <tags>
        <tag>Codility</tag>
      </tags>
  </entry>
  <entry>
    <title>PermMissingElement</title>
    <url>/2020/10/11/PermMissingElement/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://app.codility.com/demo/results/trainingQ23U3S-QHV/">PermMissingElement</a> An array A consisting of N different integers is given. The array contains integers in the range [1..(N + 1)], which means that exactly one element is missing.</p>
<p>Your goal is to find that missing element.</p>
<p>Write a function:</p>
<p>int solution(vector<int> &amp;A);</p>
<p>that, given an array A, returns the value of the missing element.</p>
<p>For example, given array A such that:</p>
<p>A[0] = 2 A[1] = 3 A[2] = 1 A[3] = 5 the function should return 4, as it is the missing element.</p>
<p>Write an efficient algorithm for the following assumptions:</p>
<p>N is an integer within the range [0..100,000]; the elements of A are all distinct; each element of array A is an integer within the range [1..(N + 1)].</p>
<a id="more"></a>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>需要求一个无序数组中唯一的缺失元素</li>
<li>类似于每个元素都出现两次，只有一个元素只出现一次的题目</li>
<li>缺失的元素让它只出现一次即可</li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// you can use includes, for example:</span></span><br><span class="line"><span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// you can write to stdout for debugging purposes, e.g.</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;this is a debug message&quot; &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="keyword">if</span> (A.empty())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = A.size() + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.size(); i++) &#123;</span><br><span class="line">        ans = (ans ^ A[i] ^ (i+<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="时间复杂度">时间复杂度</h3>
<p><code>O(N)</code></p>
]]></content>
      <categories>
        <category>Codility</category>
      </categories>
      <tags>
        <tag>Codility</tag>
      </tags>
  </entry>
  <entry>
    <title>Range Sum Query</title>
    <url>/2020/07/11/RangeSumQuery/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="range-sum-query-immutable">Range Sum Query Immutable</h2>
<p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p>
<p>Example: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Given nums = [-2, 0, 3, -5, 2, -1]</span><br><span class="line"></span><br><span class="line">sumRange(0, 2) -&gt; 1</span><br><span class="line">sumRange(2, 5) -&gt; -1</span><br><span class="line">sumRange(0, 5) -&gt; -3</span><br><span class="line">Note:</span><br><span class="line">You may assume that the array does not change.</span><br><span class="line">There are many calls to sumRange <span class="keyword">function</span>.</span><br></pre></td></tr></table></figure> <a id="more"></a></p>
<h3 id="思路">思路</h3>
<ul>
<li>比较简单的 Range Sum Query，只要知道前缀和就可以计算出不变数组的任意区间的和。</li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        v_.push_back(nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num:nums) &#123;</span><br><span class="line">            v_.push_back(v_.back() + num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// O(n)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v_[j+<span class="number">1</span>] - v_[i]; <span class="comment">// O(1)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="range-sum-query-2d---immutable">Range Sum Query 2D - Immutable</h2>
<p>Given a 2D matrix matrix, find the sum of the elements inside the rectangle defined by its upper left corner (row1, col1) and lower right corner (row2, col2).</p>
<p>Range Sum Query 2D The above rectangle (with the red border) is defined by (row1, col1) = (2, 1) and (row2, col2) = (4, 3), which contains sum = 8.</p>
<p>Example:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Given matrix = [</span><br><span class="line">  [<span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">5</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">7</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">5</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">sumRegion(<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>) -&gt; <span class="number">8</span></span><br><span class="line">sumRegion(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>) -&gt; <span class="number">11</span></span><br><span class="line">sumRegion(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>) -&gt; <span class="number">12</span></span><br></pre></td></tr></table></figure>
<p>Note: You may assume that the matrix does not change. There are many calls to sumRegion function. You may assume that row1 ≤ row2 and col1 ≤ col2.</p>
<h3 id="思路-1">思路</h3>
<ul>
<li>参考之前Range Sum Query 的思想，肯定是要提前计算出需要的数据，最后计算和相当于查表。</li>
<li>那么 2D 数组如何计算使用类似的思想呢</li>
<li>矩形区域的和相当于多个矩形区域进行叠加后减去重复计算的区域，如下图所示，小矩形区域可以看做三个以左上角（0，0）为顶点的矩形区域与大的矩形区域的操作后的结果 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> a <span class="number">2</span>D <span class="built_in">array</span> sum[row+<span class="number">1</span>][col+<span class="number">1</span>]</span><br><span class="line">sums[i+<span class="number">1</span>][j+<span class="number">1</span>] represents the sum of area from matrix[<span class="number">0</span>][<span class="number">0</span>] to matrix[i][j]</span><br><span class="line">(notice: we add additional blank row sums[<span class="number">0</span>][col+<span class="number">1</span>]=&#123;<span class="number">0</span>&#125; <span class="keyword">and</span> blank column sums[row+<span class="number">1</span>][<span class="number">0</span>]=&#123;<span class="number">0</span>&#125; to remove the edge <span class="keyword">case</span> checking), so, we can have the following definition</span><br><span class="line">+-----+-+-------+     +--------+-----+     +-----+---------+     +-----+--------+</span><br><span class="line">|     | |       |     |        |     |     |     |         |     |     |        |</span><br><span class="line">|     | |       |     |        |     |     |     |         |     |     |        |</span><br><span class="line">+-----+-+       |     +--------+     |     |     |         |     +-----+        |</span><br><span class="line">|     | |       |  =  |              |  +  |     |         |  -  |              |</span><br><span class="line">+-----+-+       |     |              |     +-----+         |     |              |</span><br><span class="line">|               |     |              |     |               |     |              |</span><br><span class="line">|               |     |              |     |               |     |              |</span><br><span class="line">+---------------+     +--------------+     +---------------+     +--------------+</span><br><span class="line"></span><br><span class="line">   sums[i][j]      =    sums[i<span class="number">-1</span>][j]    +     sums[i][j<span class="number">-1</span>]    -   sums[i<span class="number">-1</span>][j<span class="number">-1</span>]   +</span><br><span class="line"></span><br><span class="line">                        matrix[i<span class="number">-1</span>][j<span class="number">-1</span>]</span><br></pre></td></tr></table></figure></li>
<li>因此使用同样的思路计算区域如下</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">+---------------+   +--------------+   +---------------+   +--------------+   +--------------+</span><br><span class="line">|               |   |         |    |   |   |           |   |         |    |   |   |          |</span><br><span class="line">|   (r1,c1)     |   |         |    |   |   |           |   |         |    |   |   |          |</span><br><span class="line">|   +------+    |   |         |    |   |   |           |   +---------+    |   +---+          |</span><br><span class="line">|   |      |    | = |         |    | - |   |           | - |      (r1,c2) | + |   (r1,c1)    |</span><br><span class="line">|   |      |    |   |         |    |   |   |           |   |              |   |              |</span><br><span class="line">|   +------+    |   +---------+    |   +---+           |   |              |   |              |</span><br><span class="line">|        (r2,c2)|   |       (r2,c2)|   |   (r2,c1)     |   |              |   |              |</span><br><span class="line">+---------------+   +--------------+   +---------------+   +--------------+   +--------------+</span><br></pre></td></tr></table></figure>
<h3 id="代码-1">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumMatrix</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; sum;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumMatrix(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> m = matrix.size();</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">int</span> n = m &gt; <span class="number">0</span> ? matrix[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        sum = <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                sum[i][j] = sum[i<span class="number">-1</span>][j<span class="number">-1</span>] + sum[i][j<span class="number">-1</span>] - sum[i<span class="number">-1</span>][j<span class="number">-1</span>] + matrix[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRegion</span><span class="params">(<span class="keyword">int</span> row1, <span class="keyword">int</span> col1, <span class="keyword">int</span> row2, <span class="keyword">int</span> col2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sums[row2+<span class="number">1</span>][col2+<span class="number">1</span>] - sums[row2+<span class="number">1</span>][col1] - sums[row1][col2+<span class="number">1</span>] + sums[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="range-sum-query-mutable">Range Sum Query Mutable</h2>
<p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p>
<p>The update(i, val) function modifies nums by updating the element at index i to val.</p>
<p>Example: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Given nums = [1, 3, 5]</span><br><span class="line">-</span><br><span class="line">sumRange(0, 2) -&gt; 9</span><br><span class="line">update(1, 2)</span><br><span class="line">sumRange(0, 2) -&gt; 8</span><br></pre></td></tr></table></figure> Note:</p>
<p>The array is only modifiable by the update function. You may assume the number of calls to update and sumRange function is distributed evenly.</p>
<h3 id="fenwick-tree-binary-index-tree">Fenwick Tree (Binary Index Tree)</h3>
<p>树状数组，我们需要两个数组来存储，原始数组和 bit 数组 * 假定 i 为左子节点，那么其父节点的坐标为 (i + lowbit(i)) * 假定 i 为右子节点，那么其父节点的坐标为 (i - lowbit(i)) * update(int i, int delta) --&gt; 更新前缀和数组中每一个受影响前缀和，从 i 到 最后一个位置 O (n) * query(int) --&gt; 直接返回 idx + 1 的前缀和 O(1) * 求 i 到 j 的前缀和 就可用 query(j+1) - query(i) 来计算 * 求和的基本思想，给定要求和的位置 i，可以用二级制表示法来分段求和，以 13 为例 13 = 2^3 + 2 ^2 + 2 ^ 0; * 因此 prefixSum(13) = Range(1, 8) + Range(9, 12) + Range(13) // Range(i, j) 表示 i 到 j 的数字求和 * arr = [1, 7, 3, 0, 5, 8, 3, 2, 6, 2, 1, 1, 4, 5] prefixSum(13) = RANGE(1, 8) + RANGE(9, 12) + RANGE(13, 13) = 29 + 10 + 4 = 43</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FenwickTree</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sum_;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x &amp; (-x);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    FenwickTree(<span class="keyword">int</span> n) : sum(n+<span class="number">1</span>, <span class="number">0</span>) &#123; &#125;</span><br><span class="line">    <span class="comment">// 更新一个值，坐标 为 i，需要修改 bit 数组中涵盖了 原始数组 arr[i] 的值 --&gt;  下标 i 以及所有的父节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; sum.size()) &#123;</span><br><span class="line">            sum_[i] += delta;</span><br><span class="line">            i += lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间求和，假定求 i --&gt; j 的数值之和，可以求 0 --&gt; i-1 , 0 --&gt; j，再相减</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += sum_[i];</span><br><span class="line">            i -= lowbit(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 区间求和 和 更新数组 都是 O(logn)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums_;</span><br><span class="line">    FenwickTree tree_;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums): nums_(move(nums)), tree_(nums.size()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums_.size(); i++) &#123;</span><br><span class="line">            tree_.update(i+<span class="number">1</span>, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        tree_.update(i, val - nums[i]);</span><br><span class="line">        nums_[i] -= val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumQuery</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tree_.query(j+<span class="number">1</span>) - tree_.query(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="segment-tree">Segment Tree</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SegmentNode</span>&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> start;</span><br><span class="line">    <span class="keyword">int</span> end;</span><br><span class="line">    <span class="keyword">int</span> sum;</span><br><span class="line">    SegmentNode *left;</span><br><span class="line">    SegmentNode *right;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SegmentNode(<span class="keyword">int</span> start, <span class="keyword">int</span> end, <span class="keyword">int</span> sum, SegmentNode *left = <span class="literal">nullptr</span>, SegmentNode *right = <span class="literal">nullptr</span>):</span><br><span class="line">     start(start), end(end), sum(sum), left(left), right(right);</span><br><span class="line">    SegmentNode(<span class="keyword">const</span> SegmentNode&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    SegmentNode&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> SegmentNode&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    ~SegmentNode() &#123;</span><br><span class="line">        <span class="keyword">delete</span> left;</span><br><span class="line">        <span class="keyword">delete</span> right;</span><br><span class="line">        left = right = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
      </tags>
  </entry>
  <entry>
    <title>RectangleStrip</title>
    <url>/2020/11/08/RectanglesStrip/</url>
    <content><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="题目">题目</h2>
<p><a href="https://app.codility.com/cert/view/certJHBUBX-XQBV55HYNW9SZYBB/details/">RectangleStrip</a> There are N rectangles numbered from 0 to N-1. The K-th rectangle has size A[K] × B[K].</p>
<p>We want to arrange as many rectangles as possible into a strip. The rectangles can be arranged into a strip if they all share a side of the same length (which becomes the height of the strip). Note that rectangles can be rotated.</p>
<p>Write a function:</p>
<p>int solution(vector &amp;A, vector &amp;B);</p>
<p>that, given two arrays A and B of N integers each, returns the maximum number of rectangles that can be arranged into a strip.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Examples:</span><br><span class="line"></span><br><span class="line">1. Given A = [2, 3, 2, 3, 5] and B = [3, 4, 2, 4, 2], the <span class="keyword">function</span> should <span class="built_in">return</span> 3. Choosing the 0th, 2nd and 4th rectangles we can obtain the following strip of height 2 (note that the 0th rectangle was rotated):</span><br><span class="line"></span><br><span class="line">(3 × 2), (2 × 2), (5 × 2)</span><br><span class="line"></span><br><span class="line">We can also choose the 0th, 1st and 3rd rectangles to obtain a strip of height 3. Here we have rotated 1st and 3rd rectangles:</span><br><span class="line"></span><br><span class="line">(2 × 3), (4 × 3), (4 × 3)</span><br><span class="line"></span><br><span class="line">2. Given A = [2, 3, 1, 3] and B = [2, 3, 1, 3], the <span class="keyword">function</span> should <span class="built_in">return</span> 2. We can choose the 1st and 3rd rectangles:</span><br><span class="line"></span><br><span class="line">(3 × 3), (3 × 3)</span><br><span class="line"></span><br><span class="line">3. Given A = [2, 10, 4, 1, 4] and B = [4, 1, 2, 2, 5], the <span class="keyword">function</span> should <span class="built_in">return</span> 3. We can choose the 0th, 2nd and 4th rectangles to obtain a strip of height 4:</span><br><span class="line"></span><br><span class="line">(2 × 4), (2 × 4), (5 × 4)</span><br></pre></td></tr></table></figure>
<p>Write an efficient algorithm for the following assumptions:</p>
<p>N is an integer within the range [1..100,000]; arrays A and B both consist of N integers; each element of arrays A, B is an integer within the range [1..1,000,000,000].</p>
<a id="more"></a>
<h2 id="解题报告">解题报告</h2>
<h3 id="理解题意">理解题意</h3>
<ul>
<li>题目给了两个数组，分别表示可能的长或者宽</li>
<li>求出可以最多组成多少个矩形, 要么是同样的长，要么是同样的宽，</li>
<li>矩形可以旋转</li>
</ul>
<h3 id="理解例子">理解例子</h3>
<ul>
<li>[2, 3, 2, 3, 5] * [3, 4, 2, 4, 2]</li>
<li>可以形成 [3*2], [2*2], [5*2] 三个矩形</li>
</ul>
<h3 id="思路">思路</h3>
<ul>
<li>这个问题其实没那么复杂，既然两个数组的元素要组成矩形，那就肯定得把两个数组元素组合起来考虑</li>
<li>组成的元组为 {2,3}, {3,4}, {2,2}, {3,4}, {2,5}</li>
<li>最终的结果为 {2,3}, { }, {2,2}, { }, {2,5}</li>
<li>将其他的例子也做同样的类比，可以发现，其中使用的为出现次数最多的数字，即上面为 2，因此需要统计词频，</li>
<li>在元组中出现最高频的数字记录下来，即为结果</li>
</ul>
<h3 id="代码">代码</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// you can use includes, for example:</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="comment">// you can write to stdout for debugging purposes, e.g.</span></span><br><span class="line"><span class="comment">// cout &lt;&lt; &quot;this is a debug message&quot; &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solution</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;B)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write your code in C++14 (g++ 6.2.0)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> m = A.size();</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; freqs;</span><br><span class="line">    <span class="keyword">int</span> maxFreq = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n: A)</span><br><span class="line">        freqs[n]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> n: B)</span><br><span class="line">        freqs[n]++;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &gt; vec;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        vec.push_back(<span class="built_in">make_pair</span>(A[i], B[i]));</span><br><span class="l