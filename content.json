{"pages":[{"title":"404 Not Found","text":"ACE_xW","link":"/404/index.html"},{"title":"关于我们","text":"ACE_xW 简介 联系方式 Blog: http://bapuqln.github.io GitHub: https://github.com/bapuqln","link":"/about/index.html"},{"title":"ARM 汇编","text":"ARM 汇编 Layout label: instruction ;comment &gt;label 字母、下划线和 $ 组成. &gt;comment 所有在;后面的都认为是注释 &gt;instruction 指令 1234567 .textstart: MOV r1, #20 ;puts the value 20 into register r1 MOV r2, #22 ;puts the value 22 into register r2 ADD r0, r1, r2 ;adds r1 and r2, r0 contains 42end: b end ;infinite loop, always jump back to end Instruction Format &lt;op&gt;{cond}{flags} Rd, Rn, Operand2 例如: ADD r0, r1, r2 三个字母的指令 {cond} 可选，两个字母的状态码(condition code) {flags} 可选，附加标志位 Rd 目标寄存器 Rn 第一个寄存器 Operand2 第二个寄存器或者操作数 Condition Code 在指令后面添加，允许指令在特定条件下执行。 AL - always 无条件执行，因此可以不用写 ADDAL 和 ADD 是等价的 NV - never。 AL 的反义词，带有该标记的指令不会执行。已经废弃。 EQ - equal 当 Z 标志为被设置过后，才会执行，如果 Z 标志位被清除，该行指令被忽略. MOV r0, #42 ;Write the value 42 into the register r0MOV r1, #41 ;Write the value 41 into the register r1CMP r0, r1 ;Compare the registers r0 and r1, update CPSR register BEQ label ;This command will not be run, since Z = 0MOV r1, #42 ;Write the value 42 into the register r1CMP r0, r1 ;Compare r0 and r1, update the CPSRBEQ label ;This command will be run, since Z = 1 1234* NE - not equal &gt; EQ 的反义词，如果 Z 标志位被清除，则执行。如果 Z 标志位被设置过，该行指令被忽略 MOV r0, #42 ;Write the value 42 into the register r0MOV r1, #42 ;Write the value 42 into the register r1CMP r0, r1 ;Compare the registers r0 and r1, update CPSR register BNE label ;This command will not be run, since Z = 1MOV r1, #41 ;Write the value 42 into the register r1CMP r0, r1 ;Compare r0 and r1, update the CPSRBNE label ;This command will be run, since Z = 0 12345678910111213* VS - overflow set &gt; 如果 overflow(v) 位被设置，该条件为 true。两个32位有符号数相加，可能会出一个33位的有符号数* VC - overflow clear &gt; 如果 overflow(v) 位被清除，该条件为 true。 * MI - minus &gt; 如果 negative(N) 为被设置，该条件为 true MOV r0, #40MOV r1, #42SUBS r2, r0, r1 ; 40 – 42, the result is negative BMI destination ; this portion of code is never executed PL - plus 如果 negative(N) 位被清除，该条件为 true。(&lt;= 0) CS - Carry Set 当一个在32位无符号数上的操作超出了32位的范围的时候，carry set 标志位设为 true CC - Carry Clear 如果 Carry Flag(C) 被清除了，该条语句执行 HI - Higher 如果 Carry Flag(C) 被设置，并且结果非0(Z)，该语句执行 LS - Lower or Same 如果 Carry Flag(C) 被清除，并且结果为0(Z)，该语句执行 GE - Greater than or Equal 当有符号数，并且当 Negative(N) 和 Overflow(V) 相等的时候，该语句才有效 LT - Less Than 有符号数，并且当 Negative(V) 和 Overflow(V) 不相等的时候，该语句才有效。 LE - Less Than or Equal 像 LT， 如果 Negative(V) 和 Overflow(V) 不相等，或者 Zero(Z)标志位被设置了的时候，该语句才执行。 CODE MEANING FLAGS EQ Equal equals Zero Z NE Not Equal !Z VS Overflow V VC No overflow !V MI Minus/negative N PL Plus/positive or zero !N CS Carryset/unsigned higher or same C CC Carry clear/unsigned lower !C HI Unsigned higher C and !Z LS Unsigned lower or same !C or Z GE Signed greater than or equal N == V LT Signed less than N != V GT Signed greater than !Z and (N == V) LE Signed less than or equal Z or (N != V) AL Always(default) Any Updating Condition Flags 默认情况下，指令不更新条件标志。 &gt; 当 S (ADDS, SBCS...) 标志位被设置后，指令才能更新标志位。 &gt; 例外：比较指令会自动更新 Objective-C MOV r0, # 80 00 00 0F ; r0 I 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 I I I IMOV r1, r0, LSL #1 ; r1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 I I I I 0","link":"/back/ARM%E6%B1%87%E7%BC%96.html"},{"title":"Clang学习笔记","text":"Clang 学习笔记 什么是 Clang Clang 是 LLVM 的前端，可以分析 C 语言家族的所有源代码。 Clang 是如何工作的 预处理：展开所有的宏，将代码解析成抽象语法树 Clang AST 几乎所有的编译器 &amp; 静态分析工具 都是用 AST 来表示原本的代码。 一般来说， Clang AST 由两个类组成：Decl &amp; bStmt。 &gt; FunctionDecl：函数原型或者函数定义 &gt; BinaryOperator：二元表达式，（a+b） &gt; CallExpr：函数调用，foo（x） 怎么使用 Clang Clang Plugin 使用 Clang Plugin，写出的代码本身就是插件。在使用 Clang Plugin 的时候，我们不可以保留不同文件之间的全局信息和其他横跨多个文件的上下文信息。插件的运行是通过传递命令行参数给 build system（Clang/Make），在源文件分析前后，我们不能进行任何的 custom task。插件的存在形式是一个动态链接库。 LibTooling(Clang Tool) 使用 LibTooling，代码本身就是一个正常的 C++ 程序，已正常的 main() 函数作为入口。LibTooling 一般用来把程序构建的过程和程序的分析过程分开。针对每个源程序都会生成分析代码以及对应的 AST，但同时还可以维护不同源代码文件的全局信息。由于程序有 main()函数，我们还可以在分析源代码前后运行其他的任务。 LibClang 当我们想要一个稳定的 API 的时候，LibClang 是一个很好的选择，Clang 变化很块，如果使用 Plugin 或者 LibTooling，我们可能需要更新代码以应对 Clang 的变化。但如果需要在 C++ 以外的地方调用 Clang 的 API 的时候，必须要使用 LibClang。 LibClang 不可以使用完整的 AST（只能使用高层次的 AST），而另外两个选择（Plugin 与 LibTooling）则可以。如果还是无法选择，推荐使用 LibTooling interface，简单好用。LibTooling能够像 Plugin 一样完整的使用 AST，同时还不会丢掉源代码的全局信息。另外设置 LibTooling 比 Plugin 更容易。 开始使用 Clang 编译安装 LLVM 12cd where-you-want-llvm-to-livesvn co http://llvm.org/svn/llvm-project/llvm/trunk llvm Clang 123cd where-you-want-llvm-to-livecd llvm/toolssvn co http://llvm.org/svn/llvm-project/cfe/trunk clang Compile-RT 123cd where-you-want-llvm-to-livecd llvm/projectssvn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt 构建 1234cd where you want to build llvmmkdir buildcd buildcmake -G &lt;generator&gt; [options] &lt;path to llvm sources&gt; LibTooling 假如我们要分析一个 C 语言文件如下： 12345678910#No header, because it needs additional effortsvoid do_math(int *x) { *x += 5;}int main(void) { int result = -1, val = 4; do_math(&amp;val); return result;} 我们想要对上述函数进行重构。 * 把函数名do_math 改为 addFive * 把所有的对 do_math 的调用都改为 addFive * 把返回值改为 val 从 main 函数开始 1234567891011121314int main(int argc, const char **argv) { // parse the command-line args passed to your code CommonOptionsParser op(argc, argv, StatSampleCategory); // create a new Clang Tool instance (a LibTooling environment) ClangTool Tool(op.getCompilations(), op.getSourcePathList()); // run the Clang Tool, creating a new FrontendAction (explained below) int result = Tool.run(newFrontendActionFactory&lt;ExampleFrontendAction&gt;().get()); errs() &lt;&lt; &quot;\\nFound &quot; &lt;&lt; numFunctions &lt;&lt; &quot; functions.\\n\\n&quot;; // print out the rewritten source code (&quot;rewriter&quot; is a global var.) rewriter.getEditBuffer(rewriter.getSourceMgr().getMainFileID()).write(errs()); return result;} 首先设置一个 ClangTool，将命令行参数：op.getCompilations() 以及源文件列表 op.getSourcePathList() 传给它，然后就运行这个工具就好了。 LibTooling 的优点在于，可以再工具运行前后做其他的事情，比如说打印出修改前后的代码以及统计函数的个数。 创建 FrontendAction 现在创建自己的 FrontendAction，创建的原因：想要分析 test.c 的 AST 表示。 123456789class ExampleFrontendAction : public ASTFrontendAction {public: ExampleFrontendAction() {} //Note that unique pointer is used. virtual std::unique_ptr&lt;ASTConsumer&gt; CreateASTConsumer(CompilerInstance &amp;CI, StringRef file) { return llvm::make_unique&lt;ExampleASTConsumer&gt;(&amp;CI); // pass CI pointer to ASTConsumer }}; 这里不是很复杂，我们创建了一个ASTFrontendAction的子类，改写了CreateASTConsumer函数以返回我们自己的ASTConsumer。我们还将指向CompileInstance的指针传入，因为这里面包含很多我们需要分析的上下文信息。 构建 ASTConsumer ASTConsumer 由Clang parser产生的AST。我们可以任意地重载ASTConsumer的成员函数，这样解析AST后我们的代码就可以被调用。首先，我们重载函数HandleTopLevelDecl，这在Clang解析完顶级的声明（像全局变量，函数定义等）后就可以被调用了。 1234567891011121314151617181920class ExampleASTConsumer : public ASTConsumer {private: ExampleVisitor *visitor; // doesn't have to be privatepublic: // override the constructor in order to pass CI explicit ExampleASTConsumer(CompilerInstance *CI) : visitor(new ExampleVisitor(CI)) // initialize the visitor { } // override this to call our ExampleVisitor on each top-level Decl virtual bool HandleTopLevelDecl(DeclGroupRef DG) { // a DeclGroupRef may have multiple Decls, so we iterate through each one for (DeclGroupRef::iterator i = DG.begin(), e = DG.end(); i != e; i++) { Decl *D = *i; visitor-&gt;TraverseDecl(D); // recursively visit each AST node in Decl &quot;D&quot; } return true; }}; 以上代码使用了ExampleVisitor（见下文），来访问整个源文件顶级声明（top-level declaration）的AST节点。对于test.c而言，两个FunctionDecl将会被访问，do_math()以及main()。 更好的 ASTConsumer 实现 重载HandleTopLevelDecl()意味着每当一个新的Decl出现的时候，函数中的代码就会被调用，而不是等到整个源文件被解析完成后。从parser的角度看，当访问do_math()的时候，它将完全不知道main()的存在，也就是说我们不能access到当前分析的函数之后的函数。 但是，这个功能很重要！ 不过，ASTConsumer还有一个更好的函数用来重载，HandelTranslationUnit()，该函数只有在整个文件都解析完才被调用。这样的话，一个translation单元就是一整个源文件。ASTContext类用来表示那个源文件的AST，并且包含许多很有用的成员（去读文档吧！）。 所以，下面的代码重载了HandelTranslationUnit(): 123456// override this to call our ExampleVisitor on the entire source file virtual void HandleTranslationUnit(ASTContext &amp;Context) { /* we can use ASTContext to get the TranslationUnitDecl, which is a single Decl that collectively represents the entire source file */ visitor-&gt;TraverseDecl(Context.getTranslationUnitDecl()); } 大多数情况下，我们都应该使用HandelTranslationUnit(), 尤其在使用RecursiveASTVisitor的时候。 创建一个 RecursiveASTVisitor 前面两部分只不过在设置架构，现在到了正文部分了。RecursiveASTVisitor是一个特别有用的类，使用它可以访问任意类型的AST节点，比如FunctionDecl以及Stmt, 只要重载那个函数（比如VisitFunctionDecl以及VisitStmt）就可以了。当然，其它AST类也同样适用这样的规则。Clang提供了一个官方的文档，虽然很短，但是很全面。 像Visit..(表示Visit任意节点的函数，如VisitStmt）这样的函数，我们必须返回true以继续遍历AST或者返回false以终止遍历，退出Clang。我们不可以直接调用Visit..，而是应该调用TraverseDecl（正如我们前面的那个例子一样），调用Visit..函数则是在背后调用的。 由于我们只需要改写函数定义和一些statement，我们只需要重载VisitFunctionDecl和VisitStmt。下面是部分代码： 12345678910111213141516171819202122232425262728293031class ExampleVisitor : public RecursiveASTVisitor&lt;ExampleVisitor&gt; {private: ASTContext *astContext; // used for getting additional AST infopublic: explicit ExampleVisitor(CompilerInstance *CI): astContext(&amp;(CI-&gt;getASTContext())) { // initialize private members rewriter.setSourceMgr(astContext-&gt;getSourceManager(), astContext-&gt;getLangOpts()); } virtual bool VisitFunctionDecl(FunctionDecl *func) { numFunctions++; string funcName = func-&gt;getNameInfo().getName().getAsString(); if (funcName == &quot;do_math&quot;) { rewriter.ReplaceText(func-&gt;getLocation(), funcName.length(), &quot;add5&quot;); errs() &lt;&lt; &quot;** Rewrote function def: &quot; &lt;&lt; funcName &lt;&lt; &quot;\\n&quot;; } return true; } virtual bool VisitStmt(Stmt *st) { if (ReturnStmt *ret = dyn_cast&lt;ReturnStmt&gt;(st)) { rewriter.ReplaceText(ret-&gt;getRetValue()-&gt;getLocStart(), 6, &quot;val&quot;); errs() &lt;&lt; &quot;** Rewrote ReturnStmt\\n&quot;; } if (CallExpr *call = dyn_cast&lt;CallExpr&gt;(st)) { rewriter.ReplaceText(call-&gt;getLocStart(), 7, &quot;add5&quot;); errs() &lt;&lt; &quot;** Rewrote function call\\n&quot;; } return true; }}; 以上的代码引入了Rewriter类，可以让我们对源代码进行修改，这在代码重构或者小规模的代码修改里面很常见。我们还在main()函数的末尾用它打印出了修改后的代码。 使用Rewriter意味着我们需要找到正确SourceLocation来插入或者替换相关的代码。同时，我们还使用了dyn_cast，来检查Stmt st是一个ReturnStmt还是CallExpr。而errs()是一个stderr流，在LLVM/Clang里面打印debug信息 写一个更具体的Visit..函数 除了更一般化地重载VisitStmt，我们可以更具体化地重载VisitReturnStme以及VisitCallExpr。VisitReturnStme和VisitCallExpr都是Stmt的子类。这就是Clang AST和RecursiveASTVisitor的美妙之处：我们可以选择一般化或者是具体化，下面就是代码 1234567891011// this replaces the VisitStmt function abovevirtual bool VisitReturnStmt(ReturnStmt *ret) { rewriter.ReplaceText(ret-&gt;getLocStart(), 6, &quot;val&quot;); errs() &lt;&lt; &quot;** Rewrote ReturnStmt\\n&quot;; return true;}virtual bool VisitCallExpr(CallExpr *call) { rewriter.ReplaceText(call-&gt;getLocStart(), 7, &quot;add5&quot;); errs() &lt;&lt; &quot;** Rewrote function call\\n&quot;; return true;}","link":"/back/Clang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"},{"title":"Clang plugin with Xcode","text":"Creating and using Clang plugin with Xcode 环境设置 plugin 设置 Xcode 工程设置 warnning error Xcode 集成 与 error/warning 的交互 环境设置 需要 llvm/clang，源码 12345678910111213141516171819cd /optsudo mkdir llvmsudo chown `whoami` llvmcd llvmexport LLVM_HOME=`pwd```` 2. 根据本机的 clang 版本来编译,本机3.3.1 为例```C++git clone -b release_33 https://github.com/llvm-mirror/llvm.git llvmgit clone -b release_33 https://github.com/llvm-mirror/clang.git llvm/tools/clanggit clone -b release_33 https://github.com/llvm-mirror/clang-tools-extra.git llvm/tools/clang/tools/extragit clone -b release_33 https://github.com/llvm-mirror/compiler-rt.git llvm/projects/compiler-rt mkdir llvm_buildcd llvm_buildcmake ../llvm -DCMAKE_BUILD_TYPE:STRING=Releasemake -j`sysctl -n hw.logicalcpu` plugin 设置 创建 plugin 的文件夹 12cd $LLVM_HOMEmkdir toy_clang_plugin; cd toy_clang_plugin 基于 plugin 的例子结构如下 ToyClangPlugin.exports CMakeLists.txt ToyClangPlugin.cpp 文件内容 ToyClangPlugin.cpp 12345678910111213141516171819202122232425262728293031#include &quot;clang/Frontend/FrontendPluginRegistry.h&quot;#include &quot;clang/AST/AST.h&quot;#include &quot;clang/AST/ASTConsumer.h&quot;#include &quot;clang/Frontend/CompilerInstance.h&quot; using namespace clang; namespace{ class ToyConsumer : public ASTConsumer { }; class ToyASTAction : public PluginASTAction { public: virtual clang::ASTConsumer *CreateASTConsumer(CompilerInstance &amp;Compiler, llvm::StringRef InFile) { return new ToyConsumer; } bool ParseArgs(const CompilerInstance &amp;CI, const std::vector&lt;std::string&gt;&amp; args) { return true; } };} static clang::FrontendPluginRegistry::Add&lt;ToyASTAction&gt;X(&quot;ToyClangPlugin&quot;, &quot;Toy Clang Plugin&quot;); CMakeLists.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124cmake_minimum_required (VERSION 2.6)project (ToyClangPlugin) set( CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin )set( CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib )set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib ) set( LLVM_HOME /opt/llvm )set( LLVM_SRC_DIR ${LLVM_HOME}/llvm )set( CLANG_SRC_DIR ${LLVM_HOME}/llvm/tools/clang )set( LLVM_BUILD_DIR ${LLVM_HOME}/llvm_build )set( CLANG_BUILD_DIR ${LLVM_HOME}/llvm_build/tools/clang) add_definitions (-D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS)add_definitions (-D_GNU_SOURCE -DHAVE_CLANG_CONFIG_H) set (CMAKE_CXX_COMPILER &quot;${LLVM_BUILD_DIR}/bin/clang++&quot;)set (CMAKE_CC_COMPILER &quot;${LLVM_BUILD_DIR}/bin/clang&quot;) set (CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -fPIC -fno-common -Woverloaded-virtual -Wcast-qual -fno-strict-aliasing -pedantic -Wno-long-long -Wall -Wno-unused-parameter -Wwrite-strings -fno-exceptions -fno-rtti&quot;) set (CMAKE_MODULE_LINKER_FLAGS &quot;-Wl,-flat_namespace -Wl,-undefined -Wl,suppress&quot;) set (LLVM_LIBS LLVMJIT LLVMX86CodeGen LLVMX86AsmParser LLVMX86Disassembler LLVMExecutionEngine LLVMAsmPrinter LLVMSelectionDAG LLVMX86AsmPrinter LLVMX86Info LLVMMCParser LLVMCodeGen LLVMX86Utils LLVMScalarOpts LLVMInstCombine LLVMTransformUtils LLVMipa LLVMAnalysis LLVMTarget LLVMCore LLVMMC LLVMSupport LLVMBitReader LLVMOption) macro(add_clang_plugin name) set (srcs ${ARGN}) include_directories( &quot;${LLVM_SRC_DIR}/include&quot; &quot;${CLANG_SRC_DIR}/include&quot; &quot;${LLVM_BUILD_DIR}/include&quot; &quot;${CLANG_BUILD_DIR}/include&quot; ) link_directories( &quot;${LLVM_BUILD_DIR}/lib&quot; ) add_library( ${name} SHARED ${srcs} ) if (SYMBOL_FILE) set_target_properties( ${name} PROPERTIES LINK_FlAGS &quot;-exported_symbols_list ${SYMBOL_FILE}&quot;) endif() foreach (clang_lib ${CLANG_LIBS}) target_link_libraries( ${name} ${clang_lib} ) endforeach() foreach (llvm_lib ${LLVM_LIBS}) target_link_libraries( ${name} ${llvm_lib} ) endforeach() foreach (user_lib ${USER_LIBS}) target_link_libraries( ${name} ${user_lib} ) endforeach() endmacro(add_clang_plugin) set(SYMBOL_FILE ToyClangPlugin.exports) set (CLANG_LIBS clang clangFrontend clangAST clangAnalysis clangBasic clangCodeGen clangDriver clangFrontendTool clangLex clangParse clangSema clangEdit clangSerialization clangStaticAnalyzerCheckers clangStaticAnalyzerCore clangStaticAnalyzerFrontend) set (USER_LIBS pthread curses) add_clang_plugin(ToyClangPlugin ToyClangPlugin.cpp) set_target_properties(ToyClangPlugin PROPERTIES LINKER_LANGUAGE CXX PREFIX &quot;&quot;) ToyClangPlugin.exports 1__ZN4llvm8Registry* 现在我们能够基于 CMakeLists.txt 生成 Xcode-project， 123mkdir build; cd buildcmake -G Xcode ..open ToyClangPlugin.xcodeproj 运行 ALL_BUILD target ，然后就能看到动态库：lib/Debug/ToyClangPlugin.dylib RecuresiveASTVisitor Clang 的 AST 模块提供了RecuresiveASTVisitor，他能够让你编译整个 AST，我们只需要创建一个子类并且实现我们感兴趣的方法就行。为了测试一下，现在只是打印所有发现的类名。 12345678910111213141516171819class ToyClassVisitor : public RecursiveASTVisitor&lt;ToyClassVisitor&gt;{public: bool VisitObjCInterfaceDecl(ObjCInterfaceDecl *declaration) { printf(&quot;ObjClass: %s\\n&quot;, declaration-&gt;getNameAsString().c_str()); return true; }}; class ToyConsumer : public ASTConsumer{public: void HandleTranslationUnit(ASTContext &amp;context) { visitor.TraverseDecl(context.getTranslationUnitDecl()); }private: ToyClassVisitor visitor;}; 下面我们就来创建测试的文件并且看看 plugin 是如何工作的。 123456789#import &lt;Foundation/Foundation.h&gt; @interface ToyObject : NSObject @end @implementation ToyObject @end rebuild &amp; 运行 插件 12345/opt/llvm/toy_clang_plugin/build $ $LLVM_HOME/llvm_build/bin/clang ../test.m \\ -Xclang -load \\ -Xclang lib/Debug/ToyClangPlugin.dylib \\ -Xclang -plugin \\ -Xclang ToyClangPlugin 报警告 下面我们试试这个情况：类名是以小写字母开始。 在 ToyClassVisitor 中增加 ASTContext 123456789101112131415161718class ToyClassVisitor : public RecursiveASTVisitor&lt;ToyClassVisitor&gt;{private: ASTContext *context;public: void setContext(ASTContext &amp;context) { this-&gt;context = &amp;context; }// ...}; // ...void HandleTranslationUnit(ASTContext &amp;context) { visitor.setContext(context); visitor.TraverseDecl(context.getTranslationUnitDecl());} // ... 增加检测 1234567891011121314151617bool VisitObjCInterfaceDecl(ObjCInterfaceDecl *declaration){ checkForLowercasedName(declaration); return true;}// ...void checkForLowercasedName(ObjCInterfaceDecl *declaration){ StringRef name = declaration-&gt;getName(); char c = name[0]; if (isLowercase(c)) { DiagnosticsEngine &amp;diagEngine = context-&gt;getDiagnostics(); unsigned diagID = diagEngine.getCustomDiagID(DiagnosticsEngine::Warning, &quot;Class name should not start with lowercase letter&quot;); SourceLocation location = declaration-&gt;getLocation(); diagEngine.Report(location, diagID); }} 测一下 1234567@interface bad_ToyObject : NSObject @end @implementation bad_ToyObject @end rebuild &amp; run 12345678910/opt/llvm/toy_clang_plugin/build $ $LLVM_HOME/llvm_build/bin/clang ../test.m \\ -Xclang -load \\ -Xclang lib/Debug/ToyClangPlugin.dylib \\ -Xclang -plugin \\ -Xclang ToyClangPlugin ../test.m:11:12: warning: Class name should not start with lowercase letter@interface bad_ToyObject : NSObject ^1 warning generated. 报错误 试一下如果类名里面包含下划线 123456789101112131415161718void checkForUnderscoreInName(ObjCInterfaceDecl *declaration){ size_t underscorePos = declaration-&gt;getName().find('_'); if (underscorePos != StringRef::npos) { DiagnosticsEngine &amp;diagEngine = context-&gt;getDiagnostics(); unsigned diagID = diagEngine.getCustomDiagID(DiagnosticsEngine::Error, &quot;Class name with `_` forbidden&quot;); SourceLocation location = declaration-&gt;getLocation().getLocWithOffset(underscorePos); diagEngine.Report(location, diagID); }} bool VisitObjCInterfaceDecl(ObjCInterfaceDecl *declaration){ // disable this check temporary // checkForLowercasedName(declaration); checkForUnderscoreInName(declaration); return true;} 看看运行后的输出 12345678910/opt/llvm/toy_clang_plugin/build $ $LLVM_HOME/llvm_build/bin/clang ../test.m \\ -Xclang -load \\ -Xclang lib/Debug/ToyClangPlugin.dylib \\ -Xclang -plugin \\ -Xclang ToyClangPlugin ../test.m:11:15: error: Class name with `_` forbidden@interface bad_ToyObject : NSObject ^1 error generated. 我们试试两个监测都打开的时候的样子 12345678910111213/opt/llvm/toy_clang_plugin/build $ $LLVM_HOME/llvm_build/bin/clang ../test.m \\ -Xclang -load \\ -Xclang lib/Debug/ToyClangPlugin.dylib \\ -Xclang -plugin \\ -Xclang ToyClangPlugin ../test.m:11:12: warning: Class name should not start with lowercase letter@interface bad_ToyObject : NSObject ^../test.m:11:15: error: Class name with `_` forbidden@interface bad_ToyObject : NSObject ^1 warning and 1 error generated. Xcode 集成 很遗憾，Xcode 的 clang 并不支持插件，所以我们要这么做。 在 Xcode 中启用自定义编译工具 12sudo mv HackedClang.xcplugin `xcode-select -print-path`/../PlugIns/Xcode3Core.ideplugin/Contents/SharedSupport/Developer/Library/Xcode/Plug-inssudo mv HackedBuildSystem.xcspec `xcode-select -print-path`/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Specifications 这样就能在 build option 里面找到编译器了 在 OTHER_CFLAGS 中增加 1-Xclang -load -Xclang /opt/llvm/toy_clang_plugin/build/lib/Debug/ToyClangPlugin.dylib -Xclang -add-plugin -Xclang ToyClangPlugin 注意：这个地方使用 -add-plugin，因为我们想用自己的 ASTAction，而不是替换掉现存的 在 Module - CLANG_ENABLE_MODULES 设置为 NO 把之前新建的 test.m 增加到工程中。即可见到 增加交互 针对 warning &amp; error 增加 FixItHints 123456789101112131415161718192021222324252627282930313233343536373839404142void checkForLowercasedName(ObjCInterfaceDecl *declaration){ StringRef name = declaration-&gt;getName(); char c = name[0]; if (isLowercase(c)) { std::string tempName = name; tempName[0] = toUppercase(c); StringRef replacement(tempName); SourceLocation nameStart = declaration-&gt;getLocation(); SourceLocation nameEnd = nameStart.getLocWithOffset(name.size()); FixItHint fixItHint = FixItHint::CreateReplacement(SourceRange(nameStart, nameEnd), replacement); DiagnosticsEngine &amp;diagEngine = context-&gt;getDiagnostics(); unsigned diagID = diagEngine.getCustomDiagID(DiagnosticsEngine::Warning, &quot;Class name should not start with lowercase letter&quot;); SourceLocation location = declaration-&gt;getLocation(); diagEngine.Report(location, diagID).AddFixItHint(fixItHint); }} void checkForUnderscoreInName(ObjCInterfaceDecl *declaration){ StringRef name = declaration-&gt;getName(); size_t underscorePos = name.find('_'); if (underscorePos != StringRef::npos) { std::string tempName = name; std::string::iterator end_pos = std::remove(tempName.begin(), tempName.end(), '_'); tempName.erase(end_pos, tempName.end()); StringRef replacement(tempName); SourceLocation nameStart = declaration-&gt;getLocation(); SourceLocation nameEnd = nameStart.getLocWithOffset(name.size()); FixItHint fixItHint = FixItHint::CreateReplacement(SourceRange(nameStart, nameEnd), replacement); DiagnosticsEngine &amp;diagEngine = context-&gt;getDiagnostics(); unsigned diagID = diagEngine.getCustomDiagID(DiagnosticsEngine::Error, &quot;Class name with `_` forbidden&quot;); SourceLocation location = declaration-&gt;getLocation().getLocWithOffset(underscorePos); diagEngine.Report(location, diagID).AddFixItHint(fixItHint); }}","link":"/back/Creating_and_using_Clang_plugin_with_Xcode.html"},{"title":"LLVM &amp; Clang","text":"LLVM &amp; Clang LLVM DragonMediu LLVM（Low Level Virtual Machine） 是一个底层虚拟机，但是现在是一系列编译器和工具链的合集，而且是模块化和可重用的。 #### LLVM 的结构 传统的编译器分为三个阶段：前端，优化，后端 Untitled LLVM 也是三段式结构。 如果要支持一个新的硬件设备，只需要实现一个新的后端。要支持一个新的语言，只需要实现一个新的前端。 优化阶段 针对了统一的 LLVM IR，LLVM IR 主要有三种格式（完全等价） * 在内存中的编译中间语言 * 硬盘上存储的二进制中间语言（.bc） * 可读的中间格式（.ll） Demo - hello.c 1 生成一个二进制的 .bc 文件 生成一个 .ll 文件","link":"/back/LLVM_Clang.html"},{"title":"MVC、MVP、MVVM","text":"MVC. MVP. MVVM 架构模式 MVX 中的 Model 在大多数的iOS项目中，Model 层只是一个单纯的数据结构，大部分的模型都是这样的 12345678910struct User { enum Gender: String { case male = &quot;male&quot; case female = &quot;female&quot; } let name: String let email: String let age: Int let gender: Gender} 模型起到了定义一堆坑的作用，只是一个简单的模板，并没有参与到实际的业务逻辑，只是在模型层进行了一些抽象，将服务器端发回的JSON或者说NSDictionary 对象中的字段一一取出并填装到预先定义好的模型中。 可以将这种模型层中提供的对象理解为即开即用的NSDictionary实例，在使用时，可以直接从模型中取出属性，省去了从NSDictionary中抽出属性以及验证是否合法的过程. JSON -&gt; Model 使用 Swift 将 Dictionary 转换成模型，在笔者看来其实是一件比较麻烦的事情，主要原因是 Swift 作为一个号称类型安全的语言，有着使用体验非常差的 Optional 特性，从 Dictionary 中取出的值都是不一定存在的，所以如果需要纯手写这个过程其实还是比较麻烦的. 123456789extension User { init(json: [String: Any]) { let name = json[&quot;name&quot;] as! String let email = json[&quot;email&quot;] as! String let age = json[&quot;age&quot;] as! Int let gender = Gender(rawValue: json[&quot;gender&quot;] as! String)! self.init(name: name, email: email, age: age, gender: gender) }} 这里为 User 模型创建了一个 extension 并写了一个简单的模型转换的初始化方法，当我们从 JSON 对象中取值时，得到的都是 Optional 对象；而在大多数情况下，我们都没有办法直接对 Optional 对象进行操作，这就非常麻烦了。 麻烦的 Optional 在 Swift 中遇到无法立即使用的 Optional 对象时，我们可以会使用 ! 默认将字典中取出的值当作非 Optional 处理，但是如果服务端发回的数据为空，这里就会直接崩溃；当然，也可使用更加安全的 if let 对 Optional 对象进行解包（unwrap）。 123456789101112extension User { init?(json: [String: Any]) { if let name = json[&quot;name&quot;] as? String, let email = json[&quot;email&quot;] as? String, let age = json[&quot;age&quot;] as? Int, let genderString = json[&quot;gender&quot;] as? String, let gender = Gender(rawValue: genderString) { self.init(name: name, email: email, age: age, gender: gender) } return nil }} 上面的代码看起来非常的丑陋，而正是因为上面的情况在 Swift 中非常常见，所以社区在 Swift 2.0 中引入了 guard 关键字来优化代码的结构。 123456789101112extension User { init?(json: [String: Any]) { guard let name = json[&quot;name&quot;] as? String, let email = json[&quot;email&quot;] as? String, let age = json[&quot;age&quot;] as? Int, let genderString = json[&quot;gender&quot;] as? String, let gender = Gender(rawValue: genderString) else { return nil } self.init(name: name, email: email, age: age, gender: gender) }} 不过，上面的代码在笔者看来，并没有什么本质的区别，不过使用 guard 对错误的情况进行提前返回确实是一个非常好的编程习惯。 不关心空值的 Objective-C 为什么 Objective-C 中没有这种问题呢？主要原因是在 OC 中所有的对象其实都是 Optional 的，我们也并不在乎对象是否为空，因为在 OC 中向 nil 对象发送消息并不会造成崩溃，Objective-C 运行时仍然会返回 nil 对象。 OC 作为动态语言，这种设计思路其实还是非常优秀的，它避免了大量由于对象不存在导致无法完成方法调用造成的崩溃；同时，作为开发者，我们往往都不需要考虑 nil 的存在，所以使用 OC 时写出的模型转换的代码都相对好看很多。 1234567891011121314151617181920212223242526272829// User.htypedef NS_ENUM(NSUInteger, Gender) { Male = 0, Female = 1,};@interface User: NSObject@property (nonatomic, strong) NSString *email;@property (nonatomic, strong) NSString *name;@property (nonatomic, assign) NSUInteger age;@property (nonatomic, assign) Gender gender;@end// User.m@implementation User- (instancetype)initWithJSON:(NSDictionary *)json { if (self = [super init]) { self.email = json[@&quot;email&quot;]; self.name = json[@&quot;name&quot;]; self.age = [json[@&quot;age&quot;] integerValue]; self.gender = [json[@&quot;gender&quot;] integerValue]; } return self;}@end 元编程能力 从上面的代码，我们可以看出：Objective-C 和 Swift 对于相同功能的处理，却有较大差别的实现。这种情况的出现主要原因是语言的设计思路导致的；Swift 一直鼓吹自己有着较强的安全性，能够写出更加稳定可靠的应用程序，而安全性来自于 Swift 语言的设计哲学；由此看来静态类型、安全和动态类型、元编程能力（？）看起来是比较难以共存的。 OC 中对于 nil 的处理能够减少我们在编码时的工作量，不过也对工程师的代码质量提出了考验。我们需要思考 nil 的出现会不会带来崩溃，是否会导致行为的异常、增加应用崩溃的风险以及不确定性，而这也是 Swift 引入 Optional 这一概念来避免上述问题的初衷。 相比而言，笔者还是更喜欢强大的元编程能力，这样可以减少大量的重复工作并且提供更多的可能性，与提升工作效率相比，牺牲一些安全性还是可以接受的。 网络服务Service 层 现有的大多数应用都会将网路服务组织成单独的一层，所以有时候你会看到所谓的 MVCS 架构模式，它其实只是在 MVC 的基础上加上了一个服务层（Service），而在 iOS 中常见的 MVC 架构模式也都可以理解为 MVCS 的形式，当引入了 Service 层之后，整个数据的获取以及处理的流程是这样的： 大多数情况下服务的发起都是在 Controller 中进行的； 然后会在 HTTP 请求的回调中交给模型层处理 JSON 数据； 返回开箱即用的对象交还给 Controller 控制器； 最后由 View 层展示服务端返回的数据； 不过按理来说服务层并不属于模型层，为什么要在这里进行介绍呢？这是因为 Service 层其实与 Model 层之间的联系非常紧密；网络请求返回的结果决定了 Model 层该如何设计以及该有哪些功能模块，而 Service 层的设计是与后端的 API 接口的设计强关联的，这也是我们谈模型层的设计无法绕过的坑。 iOS 中的 Service 层大体上有两种常见的组织方式，其中一种是命令式的，另一种是声明式的。 命令式 命令式的 Service 层一般都会为每一个或者一组 API 写一个专门用于 HTTP 请求的 Manager 类，在这个类中，我们会在每一个静态方法中使用 AFNetworking 或者 Alamofire 等网络框架发出 HTTP 请求。 123456789101112131415161718192021222324252627import Foundationimport Alamofirefinal class UserManager { static let baseURL = &quot;http://localhost:3000&quot; static let usersBaseURL = &quot;\\(baseURL)/users&quot; static func allUsers(completion: @escaping ([User]) -&gt; ()) { let url = &quot;\\(usersBaseURL)&quot; Alamofire.request(url).responseJSON { response in if let jsons = response.result.value as? [[String: Any]] { let users = User.users(jsons: jsons) completion(users) } } } static func user(id: Int, completion: @escaping (User) -&gt; ()) { let url = &quot;\\(usersBaseURL)/\\(id)&quot; Alamofire.request(url).responseJSON { response in if let json = response.result.value as? [String: Any], let user = User(json: json) { completion(user) } } }} 在这个方法中，我们完成了网络请求、数据转换 JSON、JSON 转换到模型以及最终使用 completion 回调的过程，调用 Service 服务的 Controller 可以直接从回调中使用构建好的 Model 对象。 123456UserManager.user(id: 1) { user in self.nameLabel.text = user.name self.emailLabel.text = user.email self.ageLabel.text = &quot;\\(user.age)&quot; self.genderLabel.text = user.gender.rawValue} 声明式 使用声明式的网络服务层与命令式的方法并没有本质的不同，它们最终都调用了底层的一些网络库的 API，这种网络服务层中的请求都是以配置的形式实现的，需要对原有的命令式的请求进行一层封装，也就是说所有的参数 requestURL、method 和 parameters 都应该以配置的形式声明在每一个 Request 类中。 如果是在 Objective-C 中，一般会定义一个抽象的基类，并让所有的 Request 都继承它；但是在 Swift 中，我们可以使用协议以及协议扩展的方式实现这一功能。 123456789101112131415protocol AbstractRequest { var requestURL: String { get } var method: HTTPMethod { get } var parameters: Parameters? { get }}extension AbstractRequest { func start(completion: @escaping (Any) -&gt; Void) { Alamofire.request(requestURL, method: self.method).responseJSON { response in if let json = response.result.value { completion(json) } } }} 在 AbstractRequest 协议中，我们定义了发出一个请求所需要的全部参数，并在协议扩展中实现了 start(completion:) 方法，这样实现该协议的类都可以直接调用 start(completion:) 发出网络请求。 12345678910111213141516final class AllUsersRequest: AbstractRequest { let requestURL = &quot;http://localhost:3000/users&quot; let method = HTTPMethod.get let parameters: Parameters? = nil}final class FindUserRequest: AbstractRequest { let requestURL: String let method = HTTPMethod.get let parameters: Parameters? = nil init(id: Int) { self.requestURL = &quot;http://localhost:3000/users/\\(id)&quot; }} 我们在这里写了两个简单的 Request 类 AllUsersRequest 和 FindUserRequest，它们两个一个负责获取所有的 User 对象，一个负责从服务端获取指定的 User；在使用上面的声明式 Service 层时也与命令式有一些不同： 123456FindUserRequest(id: 1).start { json in if let json = json as? [String: Any], let user = User(json: json) { print(user) }} 因为在 Swift 中，我们没法将 JSON 在 Service 层转换成模型对象，所以我们不得不在 FindUserRequest 的回调中进行类型以及 JSON 转模型等过程；又因为 HTTP 请求可能依赖其他的参数，所以在使用这种形式请求资源时，我们需要在初始化方法传入参数。 命令式 vs 声明式 现有的 iOS 开发中的网络服务层一般都是使用这两种组织方式，我们一般会按照资源或者功能来划分命令式中的 Manager 类，而声明式的 Request 类与实际请求是一对一的关系。 这两种网络层的组织方法在笔者看来没有高下之分，无论是 Manager 还是 Request 的方式，尤其是后者由于一个类只对应一个 API 请求，在整个 iOS 项目变得异常复杂时，就会导致网络层类的数量剧增。 这个问题并不是不可以接受的，在大多数项目中的网络请求就是这么做的，虽然在查找实际的请求类时有一些麻烦，不过只要遵循一定的命名规范还是可以解决的。 小结 现有的 MVC 下的 Model 层，其实只起到了对数据结构定义的作用，它将服务端返回的 JSON 数据，以更方便使用的方式包装了一下，这样呈现给上层的就是一些即拆即用的『字典』。 单独的 Model 层并不能返回什么关键的作用，它只有与网络服务层 Service 结合在一起的时候才能发挥更重要的能力。 而网络服务 Service 层是对 HTTP 请求的封装，其实现形式有两种，一种是命令式的，另一种是声明式的，这两种实现的方法并没有绝对的优劣，遵循合适的形式设计或者重构现有的架构，随着应用的开发与迭代，为上层提供相同的接口，保持一致性才是设计 Service 层最重要的事情。 服务端的 Model 层 虽然文章是对客户端中 Model 层进行分析和介绍，但是在客户端大规模使用 MVC 架构模式之前，服务端对于 MVC 的使用早已有多年的历史，而移动端以及 Web 前端对于架构的设计是近年来才逐渐被重视。 因为客户端的应用变得越来越复杂，动辄上百万行代码的巨型应用不断出现，以前流水线式的开发已经没有办法解决现在的开发、维护工作，所以合理的架构设计成为客户端应用必须要重视的事情。 这一节会以 Ruby on Rails 中 Model 层的设计为例，分析在经典的 MVC 框架中的 Model 层是如何与其他模块进行交互的，同时它又担任了什么样的职责。 Model 层的职责 Rails 中的 Model 层主要承担着以下两大职责： 使用数据库存储并管理 Web 应用的数据； 包含 Web 应用所有的业务逻辑； 除了上述两大职责之外，Model 层还会存储应用的状态，同时，由于它对用户界面一无所知，所以它不依赖于任何视图的状态，这也使得 Model 层的代码可以复用。 Model 层的两大职责决定了它在整个 MVC 框架的位置： 因为 Model 是对数据库中表的映射，所以当 Controller 向 Model 层请求数据时，它会从数据库中获取相应的数据，然后对数据进行加工最后返回给 Controller 层。","link":"/back/MCV_MVVM_MVP.html"},{"title":"Metal 编程指南","text":"Metal Programming Guide Command organization and execution model (指令组织和执行模型) 在 Metal 框架中, MTLDevice 协议定义的接口描述了一个 GPU, 该协议提供了一系列方法可以查询设备属性, 创建设备相关对象(缓存和纹理) command queue 包含了一系列的 command buffers, command queue 用于管理其中的 command buffers 的执行顺序. command buffer 包含了多个被编码的指令, 这些指令在一个特定设备上运行. command encoder 可以将绘制, 计算, 位图传输指令放到一个 command buffer 中 command buffers 最终被提交到设备中去执行. MTLCommandQueue 协议为 command queue 定义了接口, 主要是创建 command buffer 对象的方法. MTLCommandBuffer 协议 为 command queue 定义了接口, 提供了创建 command encoder, 入队列执行, 检测状态以及其他操作. 该协议定义了几种 command encoder 的类型, 他们可以被用于将不同的 GPU 任务编码到 command buffer 中执行. MTLRenderCommandEncoder 协议 - 将图形渲染指令编码为一次渲染过程. MTLComputeCommandEncoder 协议 - 编码并行计算任务 MTLBlitCommandEncoder 协议 - 在缓存和纹理之间的拷贝以及 mipmap 的生成. 任一时刻, 只有一个 Encoder 是处于激活状态的, 他可以向一个 command buffer 提交 command. 对于同一个 command buffer 来说,必须是前一个 encoder 结束后, 新的 encoder 才可以被创建并且用于此 command buffer(MTLParallelRenderCommandEncoder 例外). 一点所有的指令编码结束, MTLCommandBuffer 对象自己就会提交,并且会被标记为准备执行状态. MTLCommandQueue 协议可以用来控制这些要被执行的 MTLCommandBuffer 对象. 一个 MTLDevice 对象代表了一个可以执行 command 的 GPU. MTLDevice 协议有创建新的 command queue , 从内存创建缓存, 创建纹理, 查询设备能力的方法. 使用 MTLCreateSystemDefaultDevice 来创建首选设备. 创建: command buffers 和 command encoder 基本不耗费什么系统资源. Command queue &amp; buffer &amp; texture &amp; sample state libraries &amp; compute state &amp; render pipeline state &amp; depth/stencil state, 这些对象系统鼓励重用. Command Queue command queue 接受的是: 有序的 command buffer(将要在 GPU 中执行) 列表. 在 command queue 中的 command buffers 会被确保按顺序执行. command queue 是线程安全的. MTLDevice 中有两个方法可以创建 command queue newCommandQueue newCommandQueueWithMaxCommandBufferCount 不要没事销毁和创建 commandQueue, 记得复用. Command buffer command buffer 在被 GPU 执行之前会包含多个被编码的 command, 不支持重用, 能做的就是提交执行后, 检查状态 他还是 app 中独立可以被追踪的任务单元. 创建 command buffer MTLCommandQueue 中定义了创建 commandBuffer 的方法. 一个 MTLCommandQueue 对象只能提交给创建他的 MTLCommandQueue. commandBuffers创建的 command buffer 对象持有他执行时需要的数据. 在特定场景下, 你需要的资源已经被持有了, 可以使用commandBufferWithUnretainedReferences方法.(该方法只有在极端需要性能 app 中, 并且能够保证在 command 执行完之前资源都保持存活的情况下才使用) Executing Command MTLCommandBuffer 协议中有下列的方法可以设定在 command queue 中的执行顺序. 一个 command buffer 一定要先提交然后在执行. enqueue 方法可以为一个 command buffer 在 command queue 中预定一个位置.但是并没有把 command buffer 提交执行.当这个 command buffer 最终提交的时候, 他会在之前做 enqueue 操作的 command buffer 之后执行. commit 方法会使 command buffer 尽快的被执行.但必须是等到之前 enqueue 的 command buffer 执行后. commit 会隐式的调用 enqueue. Registering Handler Blocks for Command Buffer Execution addScheduledHandler, 当 command buffer 被 schedule 的时候调用. waitUntilScheduled, 该方法同步的等待, 当 command buffer 被完全执行完或者其所有注册 addScheduledhandler 都结束的时候返回. addCompleteHandler, 当设备执行完 command buffer 的时候调用. waitUntilCompleted, 该方法同步的等待, 当设备执行完 command buffer并且所有注册 addCompleteHandler 都返回的时候. presentDrawable:, 便捷函数:在command buffer 被 schedule 的时候, 能够将可显示的资源(CAMetalDrawable 对象)展示出来 status, read-only 属性. command buffer 是在生命周期的哪个阶段. error, 如果没有异常,为 nil. 如果有错误, 可以看看 command buffer error codes. Command Encoder 1.Encoder 是一个一次性的 transient 的对象, 在激活状态的时候可以他就可以把一个 command 追加到 command buffer 中. 使用 endEncoding 来结束编码 command. 还想要编码 command, 只能在新建一个 encoder. Creating a Command Encoding Object renderCommandEncoderWithDescriptor, 创建一个 MTLRenderCommandEncoder 类型的 encoder 用来在TMLRenderPassDescriptor中做图形渲染. computeCommandEncoder, 创建一个 MTLComputeCommandEncoder 类型的 encoder 用来做并行计算. blitCommandEncoder, 创建了一个 MTLBlitCommandEncoder 类型的 encoder 用来做内存操作. parallelRenderCommandEncoderWithDescriptor, 创建了一个MTLParallelRenderCommandEncoder 类型的 encoder, 用来让多个 MTLRenderCommandEncoder 对象在不同的线程工作,并且保证渲染到同一个 attachment(共享的MTLRenderPassDescriptor) 中. Render Command Encoder 该 encoder 需要关联一个MTLRenderPassDescriptor对象，在这个descriptor对象中包含了颜色 、景深、模板attachment，这些attachment将被当做绘制命令的目标， 该 Encoder 有如下能力: 指定图形资源, 如缓存和纹理对象。 指定 MTLRenderPipelineState对象(包含 compiled rendering state 以及顶点和片段着色器) 指定 fixed-function 状态, 包括 viewport, 更多可以看 MTLRenderCommandEncoder 协议 Compute Command Encoder 参见 MTLComputeCommandEncoder 协议 Blit Command Encoder MTLBlitCommandEncoder 协议可以追加一个 command 用来做 MTLBuffer 和 MTLTexture 之前的内存拷贝操作. 还可以用固定颜色填充纹理生成一个 mipmaps Multiple Thread, Command Buffers, Command Encoder 大多数程序使用单一的线程来encoder 绘制指令到一个 command buffer 来绘制一帧画面.在每一帧结束的时候, 提交 command buffer, 这样就可以 shcedule 并且 开始 command 的执行. 如果需要并行的为 command buffer 编码, 这样就需要在同时创建多个command buffer, 在不同的线程 encoder 每一个 command buffer. 如果提前知道 command buffer 的执行顺序, 就可以按顺序 enqueue 每个 command buffer, 就不用等待执行编码和提交. Resource Objects: Buffers and Textures MTLBuffer 表示一块非格式化的内存可以存放任何类型的数据.通常用来存放顶点, 着色器, 计算状态数据. MTLTexture 表示一块有格式的图像数据, 有特定的纹理类型 &amp; 像素格式 MTLSampleState 用于纹理对象的查找计算. Buffers are Typeless Allocations of Memory 一个 MTLBuffer 表示了一段内存区域,他可以存放任何数据类型. Creating a Buffer Object 下面的 MTLDevice 方法创建并返回一个 MTLBuffer 对象 newBufferWithLenth:Options: 分配内存创建一个 MTLBuffer 对象 newBufferWithBytes:length:options: 通过从已有的存储器中拷贝到新分配的内存中 newBufferWithBytesNoCopy:length:options:deallocator: 该方法创建一个 MTLBuffer 对象，但不会为这个对象新分配内存，而是使用已经存在的内存。","link":"/back/Metal%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97.html"},{"title":"Mesh Transforms","text":"Mesh Transforms 先上源代码 本文很简单粗暴，在 layer 中引入了一些点，然后通过移动点来改变整体的形状。 CAMeshVertex CAMeshVertex 是相当简单的一个结构体 1234typedef struct CAMeshVertex { CGPoint from; CAPoint3D to;} CAMeshVertex; CAPoint3D 看上去和 CGPoint 很类似，只不过拓展了 z 轴 12345typedef struct CAPoint3D { CGFloat x; CGFloat y; CGFloat z;} CAPoint3D; CAMeshVertex 的想法是相当简单：他描述了平面点和3D 空间的映射， CAMeshFace 1234typedef struct CAMeshFace { unsigned int indices[4]; float w[4];} CAMeshFace;","link":"/back/Mesh_Transform.html"},{"title":"Selector 是什么","text":"selector 到底是什么 1234567891011static SEL sel_alloc(const char *name, bool copy){ selLock.assertWriting(); return (SEL)(copy ? strdup(name) : name); }const char *sel_getName(SEL sel) { if (!sel) return &quot;&lt;null selector&gt;&quot;; return (const char *)(const void*)sel;} 从 sel_alloc 可以看出来，SEL 就是直接使用当前的字符串，或者把当前的字符串拷贝一份，然后char * 强转为 SEL. 从 sel_getName 可以看出，SEL 类型可以强转为 char * 也就是说 SEL 就是字符串，那么@selector(XXX)\u0010就是字符串 XXX。然后从 class 里面取方法就是拿这个字符串跟 class 里面的 methodList 里面取 method 的 name（也就是 SEL）作对比，如果相等，就取到了。","link":"/back/Selector%E6%98%AF%E4%BB%80%E4%B9%88.html"},{"title":"Block学习","text":"#iOS Block 概要 ##1.Block 的种类 block 常见的类型有三种: __NSGlobalBlock__（全局）, __NSStackBlock__（栈）, __NSMallocBlock（堆）。 1234567891011121314int main(int argc, const char *argv[]){ @autorelease{ int i = 10; //ARC 情况下 ^{i;}; //创建 block 的时候都是在 `栈` 中 --&gt; StackBlock void (^block) = ^{i;}; //block为 strong 类型，并且捕获了外部变量，所以赋值的时候，自动进行了 copy -&gt; MallocBlock __weak void (^weakBlock) = ^{i;};\u0010 //如果是 weak 类型的 block，不会自动进行 copy -&gt; StackBlock void (^stackBlock) = ^{}; //如果 block 是 strong 类型，并且没有捕获外部变量、或者用到全局变量，静态变量，那么就会被转换成 GlobalStack. } } 综上所述：我们可以得到如下的结论：ARC 下 1.block 没有捕获外部变量，或者用到全局变量、静态变量，则为 __NSGlobalBlock__ 2.block 用到自动变量且用正常变量来接受这个 block，则是 MallocBlock 3.block 用到自动变量或者用 weak 变量来接受 block，则是 StackBlock 备注： 1.block 用到自动变量初创之时都是 StackBlock 类型，在 ARC 环境下赋值给正常变量时，系统会将 block 拷贝到堆上，StackBlock 变成了 MallocBlock 2.在 MRC 下，赋值给正常变量时，系统不会自动的将 block 拷贝到堆上。 ###2.Block 内外关系 123456static int a;//全局或者局部变量都一样- (void)test{ ^{ a; }} //不向 block 内传递任何东西，（\u0010全局或者局部变量作用域广，任何时候用到变量 a 都是同一个变量，block 用到的变量 a 也是同一个） 123456- (void)test{ static int a; ^{ a = 10; }} //向 block 内传递地址（局部静态变量作用域有限，block 记录了局部静态变量的地址，确保了 block 内外用到的变量 a 是同一个） 123456- (void)test{ int a; ^{ a; }} // 向 block 内传递 123456- (void)test{ __block int a; ^{ a = 10; }} //向 block 内传递构造的结构体 __Block_byref 综上所述：__block 修饰的基础类型和对象类型都会构造__Block_byref结构体再传递。 构造__Block_byref结构体在传递的方式会很复杂。 ###3.梳理 在 ARC 环境下， __NSGlobalBlock__ 几乎不出现，使用起来没什么需要注意。 __NSStackBlock__ 几乎不出现， 但他是 __NSMallocBlock__ 的前身。 __NSMallocBlock__ 比较重要 看得懂编译是一切的前提 ##1.看懂编译 编译选项：clang --rewrite-objc ### A.不带参数 123456int main(int argc, const char *argv[]){ @autorelease{ ^{} } return 0;} 编译结果： 12345678910111213141516171819202122232425262728293031323334353637struct __block_impl{ void *isa; int Flags; int Reverse; void *FuncPtr;};struct __main_block_impl_0{ struct __block_impl impl; struct __main_block_desc_0 *Desc; __main_block_desc_0(void *fp, struct __main_block_desc_0 *desc, int flags = 0){ impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct _main_block_impl_0 *__cself){}static struct _main_block_func_0{ size_t reserved; size_t Block_size;}__main_block_desc_0_DATA = {0, sizeof(struct __main_block_impl_0);}int main(int argc, const char* argv[]){ void(*test)()=( (void (*))&amp;__main_block_impl_0( (void *)__main_block_func_9, &amp;__main_block_desc_0_DATA) ); ); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr((__block_impl *)test); return 0;} __main_block_impl_0 就是 block 的一个 C++的实现，0 表示第几个block，其实就是一个结构体。 __block_impl 结构体中 1. isa指向所属类，就是 block 的类型。 2. flags，标志变量，在 block 内部操作中会用到。 3. Reserved，是保留变量。 4. FuncPtr，block 执行时调用的函数指针，它包含了 isa 指针，其实 block 也是一个对象。 __main_block_desc_0 结构体中 1. Reserved，为保留字段 2. Block_size 为 block 的大小，也就是sizeof(struct __main_block_impl_0) 在上面的代码中，定义__main_block_desc_0结构体时，同时创建了__main_block_desc_0_DATA，并给它赋值，以供main函数中对__main_block_0进行初始化。 __main_block_impl_0 的isa指向了__NSConcreteStackBlock 从main函数中看，__main_block_impl_0的FuncPtr指向了函数__main_block_func_0 __main_block_impl_0的Desc也指向了定义的__main_block_desc_0时就创建的__main_block_desc_0_DATA，其中记录了 block 结构体大小等信息。 ##2.Block 实际结构 在Block_private.h 中定义了对 block 的相关结构体的真实定义 1234567891011121314struct Block_descriptor{ unsigned long int reserved; unsigned long int size; void (*copy)(void *dst, void *src); void (*dispose)(void *)}struct Block_layout{ void *isa; int flags; int reserved; void (* invoke)(void *,...); struct Block_descriptor *descriptor;} invoke ,相当于上文中的 FuncPtr, block 执行时调用的函数指针，block 定义时内部的执行代码都在这个函数中。 Block_descriptor，block 的详细描述 copy/dispose,辅助拷贝/销毁函数，处理 block 范围外的变量时使用。 结论： block 就是一个里面存储了指向函数体中包含定义 block 时代码块的函数指针，以及block 外部上下文等信息的结构体。 B. 基础类型 12345678int main(int argc, const char *argv[]){ int any = 1; void (^test)() = ^{ NSLog(@&quot;%d&quot;, any); }; test(); return 0;} 编译结果： 1234567891011121314151617181920212223242526272829303132333435struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;};struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; int any; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _any, int flags=0) : any(_any) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; static void __main_block_func_0(struct __main_block_impl_0 *__cself){ int any = __cself-&gt;any; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_a_f8f541_mi_0, any); }static struct __main_block_desc_0 { size_t reserved; size_t Block_size;} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};int main (int argc, const char *argv[]){ int any = 1; void (*test)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, any)); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test); return 0;} ###C. 对象类型 12345678int main(int argc, const char *argv[]){ NSString *any = [NSString stringWithFormat:@&quot;1&quot;]\u0010; void (^test)() = ^{ NSLog(@&quot;%@&quot;, any); }; test(); return 0;} 编译结果： 123456789101112131415161718192021222324252627282930313233343536373839404142struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;};struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; NSString *any; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSString *_any, int flags=0) : any(_any) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct __main_block_impl_0 *__cself) { NSString *any = __cself-&gt;any; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_b_ca6e15_mi_2, any);}static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;any, (void*)src-&gt;any, 3/*BLOCK_FIELD_IS_OBJECT*/);}static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;any, 3/*BLOCK_FIELD_IS_OBJECT*/);}static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};int main (int argc, const char *argv[]){ NSString *any = ((NSString *(*)(id, SEL, NSString *, ...))(void *)objc_msgSend)((id)objc_getClass(&quot;NSString&quot;), sel_registerName(&quot;stringWithFormat:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_b_ca6e15_mi_0, (NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_b_ca6e15_mi_1); void (*test)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, any, 570425344)); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test); return 0;} ###D.__block 修饰基础类型 12345678int main(int argc, const char * argv[]) { __block int any = 1; void (^test)() = ^ { NSLog(@&quot;%d&quot;,any); }; test(); return 0;} 编译结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;};struct __Block_byref_any_0 { void *__isa;__Block_byref_any_0 *__forwarding; int __flags; int __size; int any;};struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_any_0 *any; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_any_0 *_any, int flags=0) : any(_any-&gt;__forwarding) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct __main_block_impl_0 *__cself) { __Block_byref_any_0 *any = __cself-&gt;any; // bound by ref NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_c_88a22a_mi_0, (any-&gt;__forwarding-&gt;any)); }static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;any, (void*)src-&gt;any, 8/*BLOCK_FIELD_IS_BYREF*/);}static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;any, 8/*BLOCK_FIELD_IS_BYREF*/);}static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};int main(int argc, const char *argv[]){ __attribute__((__blocks__(byref))) __Block_byref_any_0 any = {(void*)0,(__Block_byref_any_0 *)&amp;any, 0, sizeof(__Block_byref_any_0), 1}; void(*test)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_any_0 *)&amp;any, 570425344)); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test); return 0;} ###E. __block修饰对象类型 12345678int main(int argc, const char * argv[]) { __block NSString * any = [NSString stringWithFormat:@&quot;1&quot;]; void (^test)() = ^ { NSLog(@&quot;%@&quot;,any); }; test(); return 0;} 编译结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;};static void __Block_byref_id_object_copy_131(void *dst, void *src) { _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);}static void __Block_byref_id_object_dispose_131(void *src) { _Block_object_dispose(*(void * *) ((char*)src + 40), 131);}struct __Block_byref_any_0 { void *__isa;__Block_byref_any_0 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); NSString *any;};struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_any_0 *any; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_any_0 *_any, int flags=0) : any(_any-&gt;__forwarding) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct __main_block_impl_0 *__cself) { __Block_byref_any_0 *any = __cself-&gt;any; // bound by ref NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_d_a788e6_mi_1, (any-&gt;__forwarding-&gt;any)); }static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;any, (void*)src-&gt;any, 8/*BLOCK_FIELD_IS_BYREF*/);}static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;any, 8/*BLOCK_FIELD_IS_BYREF*/);}static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};int main(int argc, const char *argv[]){ __attribute__((__blocks__(byref))) __Block_byref_any_0 any = {(void*)0,(__Block_byref_any_0 *)&amp;any, 33554432, sizeof(__Block_byref_any_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSString *(*)(id, SEL, NSString *, ...))(void *)objc_msgSend)((id)objc_getClass(&quot;NSString&quot;), sel_registerName(&quot;stringWithFormat:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_d_a788e6_mi_0)}; void (*test)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_any_0 *)&amp;any, 570425344)); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test); return 0;} ##3. 结果分析 ###3.1 1. __main_block_func_0 为 block 具体实现函数 2. __main_block_desc_0 为 block 大小描述 + 拷贝函数 + 销毁函数 3. __main_block_impl_0 block 的一切都封装在内，包括前两个函数 + 捕获的参数。该结构体就是 block 在内存里的真实存在。 4. block 的调用((void (*)(__block_impl *)) ((__block_impl *)test) -&gt; FuncPtr)((__block_impl *)test); ###3.2 以 A 为例 block 的调用 12void (*test)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0,&amp;__main_block_desc_0_DATA)); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test); 调用__main_block_impl_0结构体的构造函数，生成__main_block_impl_0结构体的实例，获取实例地址，将这个地址转成函数地址。 (void (*)(__block_impl *))读取地址，强转成函数 ((__block_impl *)test)之类对象转换成父类，这个地方 test 指针真正的指向对象__main_block_impl_0,是一个子类对象，但是__main_block_impl_0包含了__block_impl结构体，所以读取子类对象的父类对象大小，就能取到了父类对象 ###3.3 对象类型编译结果 1. 拷贝__main_block_impl_0 -&gt; __Block_byref_any 123static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) { _Block_object_assign((void*)&amp;dst-&gt;any, (void*)src-&gt;any, 3/*BLOCK_FIELD_IS_OBJECT*/);} 销毁 __main_block_impl_0 -&gt; __Block_byref_any 123static void __main_block_dispose_0(struct __main_block_impl_0*src) { _Block_object_dispose((void*)src-&gt;any, 3/*BLOCK_FIELD_IS_OBJECT*/);} ###3.4 __block修饰编译结果有的","link":"/back/block%E5%AD%A6%E4%B9%A0.html"},{"title":"iOS 内存管理","text":"iOS 内存管理和 malloc 源代码解读 iOS 内存基本管理 在接触 iOS 开发的时候，我们知道引用计数器的概念，也知道 ARC 和 MRC，但其实这仅仅是对堆内存上对象的内存管理。 在内存管理方面，其实 iOS 和其他操作系统总体上来说是大同小异的，大的框架原理基本相似，小的细节有所创新和不同。 和其他操作系统上运行的进程类似，iOS App 进程的地址空间也分为代码区、数据区、栈区和堆区。进程开始时，会把 mach-o 文件中的各部分，按需加载到内存中。 对于一般的 iPhone 来说，实际物理内存都在1GB 左右，对于超大的内存需求，也和一般的操作系统一样，都由系统内核维护一套虚拟内存系统。但这里需要注意的是 iOS 的虚拟系统原则略有不同，最截然不同的地方就是当物理内存内存紧张情况时得处理。 当物理内存紧张时，iOS 会把可以通过重新映射来加载的内存直接清理出内存，对于不可再生的数据，iOS 需要 App 进程配合处理，由各进程发送内存警告要求配合释放内存。对于不能及时释放足够内存的，直接 kill 掉进程，必要时甚至是前台运行的 app。。 所以，iOS 在外存没有交换区，没有内存页换出的过程。 malloc 基本原理 在 iOS APP 进程地址空间各个区域中，最灵活的就要属堆区，它为进程动态分配内存，也是我们经常和内存打交道的地方。 通常，我们会在需要新对象的时候，进行[NSObject alloc]调用，而释放对象时需要 release（ARC 会自动帮你做到这些）。 而这些 alloc、release 方法的调用，最终会走到 libsystem_malloc.dylib 的 malloc() 和 free() 函数这里。libsystem_malloc.dylib 是 iOS 内核之外的一个内存库，我们 app 进程需要的内存，先会请求到这里，但最终libsystem_malloc.dylib也都会向 iOS 的系统内核发起申请，映射实际内存到 app 进程的地址空间。 从苹果公开的 malloc 的源代码上看，原理大概如此： malloc 内存分配基于 malloc zone，并将内存分配按大小分为 nano、tiny、small、large 几种类型。申请时按需进行最适分配。 malloc 在首次调用时，初始化 default zone，在 64 位情况下，会初始化 default zone 为 nano zone。同事初始化一个 scalable zone 作为 helper zone，nano zone 负责 nano 大小的分配，scalable zone 负责 tiny、small 和 large 内存的分配。每次 malloc 时，根据传入的 size 参数，优先交个 nano zone 做分配处理，如果大小不在 nano 范围，则转交给 helper zone 处理。 nano malloc 在支持64位的条件下，malloc 优先考虑 nano malloc，负责对 256B 以下小内存分配，单位是16B。 nano zone 分配内存的地址空间范围是 0x00006nnnnnnnnnnn （OSX 64位情况），将地址空间从大到小一次分为 magazine、band、slot 几个级别 magazine 范围对应于 CPU，CPU0 对应 Mag0、CPU1 对应 Mag1，以此类推； Band 范围为 2M，连续分配内存当内存不够时以 Band 为单位向内核请求。 Slot 则对应每个 Band 中 128K 大小的范围，每个 Band 都分为 16个 Slot，分别对应于 16B、32B、.... 256B大小，支持他们的内存分配。 分配过程 确定当前 CPU 对应的 mag 和通过 size 参数计算出来的 slot，去对应的 metadata 的链表中取已经被释放过得内存区块缓存。判断渠道检查指针地址是否有问题，没有问题就直接返回。 初次进行 nano malloc 时，nano zone 并没有缓存，会直接在 nano zone 范围的地址空间上直接分配连续地址内存。 如当前 band 中当前 slot 耗尽，则向系统申请新的 band （每个 band 固定大小2M，容纳了16个128K 的槽），连续地址分配内存的基地址、limit 地址以及当前分配到的地址由 meta data 结构维护起来，而这些 meta data 则以 mag、slot 为维度（mag 个数是处理器个数，slot 是16个）的二维数组形式，放在 nanozone_t 的 meta_data字段中。 当 app 通过 free() 释放内存时：malloc 库会检查指针地址，如果没有问题，则以链表形式将这些区块按大小存储起来。这些链表的头部放在 meta_data 数组中对应的 [mag][slot] 元素中。 其实从缓存获取空余内存和释放内存时都会对指向这片内存区域的指针进行检查，如果有类似地址不对齐、未释放、多次释放、所属地址与预期的 mag、slot 不匹配等情况都会以报错结束。 除了分配和释放、系统内存吃紧时，nano zone 需将 cache 的内存区块还给系统，这主要是通过对各个 slot 对应的 meta data 上挂着空闲的链表上内存区块回收来完成。 scalable zone 上内存分配简要分析 对于超出 nano 大小范围或者不支持 nano 分配的，直接会在 scalable zone 上分配。由于 scalable zone 上的内存分配比 nano 分配要复杂。下面只做简单介绍。 scalable zone 上分配的内存包括 tiny、small、large 三大类。其中 tiny 和 small 的分配、释放过程大致相同，large 类型有自己的方式管理。 而 tiny、small 的方式也遵循着 nano 分配中的原则，新内存从系统申请并分配，free 后按照大小以特定的形式缓存起来，供后续分配使用。这里的分配在 region 上进行，region 和 nano malloc 里的 band 概念即为相似，但不同的是地址空间未必连续，而且每个 region 都有自己的位图等描述信息。和 nano 一样每个 CPU 都有一个 magazine，除此之外还分配了一个 index 为 -1 的 magazine 作为后备之用。 以 tiny 的情况为例， 分配时： 确定当前线程所在处理器的 magazine index，找到对应的 magazine 结构。 优先查看上次最后释放的区块是否和此次请求的大小刚好相等（都是对齐后的 slot 大小），如果是则直接返回。 如果不是，则查找 free list 中当前请求大小区块的空闲缓存列表，如果有返回，并整理列表。 如果没有，则在 free list 找比当前申请区块大的，而且最接近的缓存，如果有返回，并把剩余大小放到 free list 中另外的链表上。（这里需要注意的是，在一般情况下，free list 分为64个槽，0-62 上挂载区块的大小都是按 16B 为单位递增，63为所有更大的内存区块挂载的地方） 上面几项都不行，就在最后一个 region 的尾部或者首部（如果支持 ALSR）找空闲区域分配。 如果还是不行，说明所有现有 region 都没有可用空间了，那么从一个后备 magazine 中取出一个可用 region，完整地拿过来放到当前 magazine，再走一遍上面的步骤。 如果这都不行，那只能向内核申请一块新的 region 区域，挂载到当前的 magazine 下并分配内存。 如果还是不行，那就没招了，系统也给不到内存，就返回报错。 free 时 检查指针指向的地址是否有问题。 如果 last free 指针上没有挂载内存区块，则当道 last free 上就 OK 了。 如果有 last free，置换内存，并把 last free 原有内存区块挂载到 free list 上。（在挂载的 free list 前，会根据 region 位图检查前后区块是否能合并成为更大的区块，如果能会合并成一个） 合并后所在的 region 如果空闲字节超过一定条件，则把 region 放到后备的 magazine 中（-1）。 如果整个 region 都是空的，则直接还给系统内核，一了百了。 而 large 的情况，malloc 以页为单位申请和分配内存，不区分 magazine，scalable zone 同意维护一个 hash table 管理已申请的内存。而且由于内存区域都比较庞大，置换村总量2G 的区块，氛围16个元素，每个最大为128M。large 相关的结构相对简单。 苹果 malloc 代码：","link":"/back/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"},{"title":"IMP是什么","text":"IMP 到底是什么 IMP 的定义可以再 objc.h 中找到 12typedef void (*IMP)(void /* id, SEL, ... */ ); typedef void (*IMP)(void); 其实就是参数为空，返回值为空的函数指针。 #1 IMP 能直接调用么 定义一个类： 1234567891011@interface TestClass : NSObject@end@implementation TestClass- (id)test:(NSInteger)arg { return nil;}@end 获取 IMP 并调用： 123456int main(int argc, char * argv[]) { IMP testIMP = class_getMethodImplementation([TestClass class], @selector(test:)); testIMP(); return 1;} #2 IMP 的返回值和参数怎么定？ 不对劲吧，参数没有传。怎么判断一个方法的具体参数呢： 1Method testMethod = class_getInstanceMethod([TestClass class], @selector(test:)); 而 Method 是： 12345struct objc_method { SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE;} 从调试窗口看到的： method_types是@24@0:8q16 [4], 内容都是一个字符跟一个数字成对出现, 第一对表示返回值和参数长度(其中@表示返回值为id, 24表示参数长度为24字节),后面三对代表三个参数(@0表示参数是id而参数的偏移为0, :8表示参数是selector偏移为8,q16表示参数为long long偏移为16), 完整的type encoding参见参考. 也就意味着test:方法的IMP的类型应该是id (*IMP)(id, SEL, long long), 其中参数的第一个id是self, 第二个SEL是当前IMP对应的selector, 第三个long long就是test:的arg参数. 更详细的介绍见参考.","link":"/back/imp%E6%98%AF%E4%BB%80%E4%B9%88.html"},{"title":"iOS 静态库转动态库","text":"iOS 静态库转动态库的方法 问题 由于二级制 __TEXT 段 60M 的上限问题，支付宝钱包也将个别的 SDK 转换成动态库。 在实际抓换的过程中，由于源代码保密的问题，第三方只能提供二级制的静态库，不能提供源代码。因为我们只能把静态库直接转成动态库 抓换方法 转换方法是基于动态库本身编译和链接的特点：在链接时会把依赖的静态库 symbol 复制到本库 步骤示意图：（S1 表示静态库，D1 表示动态库） 举例说明：将不依赖其他的静态库的静态库 AMapFoundationKit.framework 转换成动态库 AMapFoundationKit.framework 步骤一 可以从Xcode原生的动态库模版一个空的动态库，与静态库名称相同，即AMapFoundationKit。 步骤二 ####2.1 设置Framework搜索路径，在AMapFoundationKit -&gt; Build Settings -&gt; FRAMEWORK_SEARCH_PATHS设置成静态库的路径 2.2 将静态库拖到AMapFoundationKit -&gt; Build Phases -&gt; Link Binary With Libraries 2.3 2.3 将静态库Headers中的所有头文件拖到AMapFoundationKit -&gt; Build Phases -&gt; Headers -&gt; Public，不用Copy文件。同时删除模版生成的AMapFoundationKit.h。 2.4 将静态库中的所有资源拖到AMapFoundationKit -&gt; Build Phases -&gt; Copy Bundle Resources 2.5 定义Link时load all symbols，将AMapFoundationKit -&gt; Build Settings -&gt; OTHER_LDFLAGS中添加-all_load 2.6 关闭Version System，AMapFoundationKit -&gt; Build Settings -&gt; VERSIONING_SYSTEM设置为None 2.7 创建触发编译的空文件（不用写任何函数），因为无编译文件将不会生成macho文件。 2.8 将静态库framework的所有系统库的依赖添加进来，可根据编译时symbol未找到symbol报错，依次添加到AMapFoundationKit -&gt; Build Phases -&gt; Link Binary With Libraries 步骤三 执行编译 步骤四 获取编译后的产物，即动态库AMapFoundationKit.framework","link":"/back/iOS%E9%9D%99%E6%80%81%E5%BA%93%E8%BD%AC%E5%8A%A8%E6%80%81%E5%BA%93.html"},{"title":"依赖注入","text":"iOS 依赖注入（DI） 依赖注入DI: Dependency Injection是控制反转IoC: Inversion of Control的实现方式之一，另外一种是依赖查找DL: Dependency Lookup 什么是依赖注入(Dependency injection) 在StackOverflow上有个问题：如何向一个5岁的小孩解释依赖注入 “When you go and get things out of the refrigerator for yourself, you can cause problems. You might leave the door open, you might get something Mommy or Daddy doesn’t want you to have. You might even be looking for something we don’t even have or which has expired. What you should be doing is stating a need, “I need something to drink with lunch,” and then we will make sure you have something when you sit down to eat.” 映射到面向对象开发中的就是：高层类（5岁小孩）应该依赖底层基础设施（家长）来提供必要的服务。 依赖倒置解决了高层次模块依赖于低层次模块和细节的问题 Dependency Injection是一个将行为从依赖中分离的技术。允许开发者定义一个方法函数依赖于外部其他各种交互，而不需要编码如何获得这些外部交互的实例。这样就在各种组件之间解耦，从而获得干净的代码，相比依赖的硬编码，一个组建只有在运行时才调用其所需要的其他组件，因此在代码运行时，通过特定的框架和容器，将其所需要的其他依赖组件进行注入，主动推入。 依赖注入可以看成是控制反转（inversion of control）的一个特例。反转的是依赖，而不是其他。“Inversion of Control Containers and the Dependency Injection pattern” 依赖注入与IOC模式类似于工厂模式，是一种解决调用者和被调用者依赖耦合关系的模式。他解决了对象之间的依赖关系，使得对象只依赖于IOC/DI 容器，实现松散耦合，然后在对象创建时，由IOC/DI容器将其依赖的对象注入其内部。 DI 解决的问题 所有的对象都必须创建；或者说：使用对象之前必须创建，但是现在我们可以不必一定遵循这个定律了，我们可以从DI容器中直接获得一个对象然后直接使用，无需事先创建它们。 依赖注入 参考文章：依赖注入 1234567891011121314- (NSNumber *)nextReminderId{ NSNumber *currentReminderId = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;currentReminderId&quot;]; if (currentReminderId) { // 增加前一个 reminderId currentReminderId = @([currentReminderId intValue] + 1); } else { // 如果还没有，设为 0 currentReminderId = @0; } // 将 currentReminderId 更新到 model 中 [[NSUserDefaults standardUserDefaults] setObject:currentReminderId forKey:@&quot;currentReminderId&quot;]; return currentReminderId;} 构造器注入 构造器注入，即将某个依赖对象传入到构造器中 (在 Objective- C中指 designated 初始化方法) 并存储起来，以便在后续过程中使用： 1234567891011121314@interface Example ()@property (nonatomic, strong, readonly) NSUserDefaults *userDefaults;@end@implementation Example- (instancetype)initWithUserDefaults:(NSUserDefaults *userDefaults){ self = [super init]; if (self) { _userDefaults = userDefaults; } return self;}@end 1234567891011- (NSNumber *)nextReminderId{ NSNumber *currentReminderId = [self.userDefaults objectForKey:@&quot;currentReminderId&quot;]; if (currentReminderId) { currentReminderId = @([currentReminderId intValue] + 1); } else { currentReminderId = @0; } [self.userDefaults setObject:currentReminderId forKey:@&quot;currentReminderId&quot;]; return currentReminderId;} 属性注入 对于属性注入，nextReminderId 的代码看起来和 self.userDefaults 的做法是一致的。只是这次不是将依赖对象传递给初始化方法，而是采用属性赋值方式 1234@interface Example@property (nonatomic, strong) NSUserDefaults *userDefaults;- (NSNumber *)nextReminderId;@end 方法注入 如果依赖对象只在某一个方法中被使用，则可以利用方法参数做注入： 1234567891011- (NSNumber *)nextReminderIdWithUserDefaults:(NSUserDefaults *)userDefaults{ NSNumber *currentReminderId = [userDefaults objectForKey:@&quot;currentReminderId&quot;]; if (currentReminderId) { currentReminderId = @([currentReminderId intValue] + 1); } else { currentReminderId = @0; } [userDefaults setObject:currentReminderId forKey:@&quot;currentReminderId&quot;]; return currentReminderId;} Demo Demo场景 Demo 中使用依赖注入的方式来为不同的 BioAuthDemoObject 提供不同的对象属性。 Demo结构 基类有相同的方法，只有在运行的时候，才会调用传入的实现 #参考 Dependency Injection, iOS and You 关于IOS依赖注入(DI)那些事 依赖注入 iOS控制反转(IoC)与依赖注入(DI)的实现 objection typhoon Objection 与 Typhoon 的协议绑定对比","link":"/back/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.html"},{"title":"如何分析Crash日志","text":"iOS Crash Log 解析 #1 简介 Crash Log 是用来分析 Crash 问题的主要手段。 #2 示例 下面的 Crash Log 取自于天猫客户端，Log 中不重要的部分已经被略去： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Incident Identifier: C7F427F7-FDF8-41C3-9659-3C54756B1547CrashReporter Key: TODOHardware Model: iPhone8,2Process: Tmall4iPhone [1313]Path: /var/containers/Bundle/Application/5F09E0C7-C766-42D8-B2C7-31E335F73349/Tmall4iPhone.app/Tmall4iPhoneIdentifier: Unknown|com.taobao.tmallVersion: 5.24.1 (5.24.1)Code Type: ARM-64Parent Process: ??? [1]Date/Time: 2016-10-07 03:16:35 +0000OS Version: iPhone OS 10.0.1 (14A403)Report Version: 104Exception Type: SIGSEGVException Codes: SEGV_ACCERR at 0x110Triggered by Thread: 42Thread 0:0 libsystem_kernel.dylib 0x0000000186bf016c _mach_msg_trap :8 (in libsystem_kernel.dylib)1 CoreFoundation 0x0000000187bedcec ___CFRunLoopServiceMachPort :192 (in CoreFoundation)2 CoreFoundation 0x0000000187beb908 ___CFRunLoopRun :1132 (in CoreFoundation)3 CoreFoundation 0x0000000187b1a048 _CFRunLoopRunSpecific :444 (in CoreFoundation)4 GraphicsServices 0x000000018959d198 _GSEventRunModal :180 (in GraphicsServices)5 UIKit 0x000000018daf3818 -[UIApplication _run] :684 (in UIKit)6 UIKit 0x000000018daee550 _UIApplicationMain :208 (in UIKit)7 Tmall4iPhone 0x000000010006bf7c main main.m:27 (in Tmall4iPhone)8 libdyld.dylib 0x0000000186afc5b8 _start :4 (in libdyld.dylib)Thread 42 Crashed:0 CFNetwork 0x00000001883cd970 __ZN15TCPIOConnection12copyPropertyEPK10__CFString :44 (in CFNetwork)1 CFNetwork 0x00000001882a49c4 __ZN14SPDYConnection20_onqueue_closeStreamEP10SPDYStream :236 (in CFNetwork)2 CFNetwork 0x00000001882a48b4 ____ZN14SPDYConnection19startEnqueuedStreamEP10SPDYStream_block_invoke_2 :28 (in CFNetwork)3 libdispatch.dylib 0x0000000186ac9200 __dispatch_call_block_and_release :24 (in libdispatch.dylib)4 libdispatch.dylib 0x0000000186ac91c0 __dispatch_client_callout :16 (in libdispatch.dylib)5 libdispatch.dylib 0x0000000186ad7444 __dispatch_queue_serial_drain :928 (in libdispatch.dylib)6 libdispatch.dylib 0x0000000186acc9a8 __dispatch_queue_invoke :652 (in libdispatch.dylib)7 libdispatch.dylib 0x0000000186ad938c __dispatch_root_queue_drain :572 (in libdispatch.dylib)8 libdispatch.dylib 0x0000000186ad90ec __dispatch_worker_thread3 :124 (in libdispatch.dylib)9 libsystem_pthread.dylib 0x0000000186cd12c8 __pthread_wqthread :1288 (in libsystem_pthread.dylib)10 libsystem_pthread.dylib 0x0000000186cd0db4 _start_wqthread :4 (in libsystem_pthread.dylib)Thread State: lr:0x00000001882a49c4 x6:0x0000000170ade8b0 x7:0x0000000000000450 x4:0x0000000000000001 x5:0x0000000000000010 x2:0x0000021aaf85c0e0 x3:0xfffffff0001fc088 x0:0x0000000000000000 x1:0x00000001ab457998 cpsr:0x0000000080000000 x10:0x0000000000077234 x16:0xfffffff100000000 x15:0xfffffff500000000 x18:0x0000000000000000 x17:0x003000000000f49f x12:0xffc0000800000000 x11:0x0000000000049198 x14:0xfffffffd00000001 fp:0x000000016e5b2c50 x13:0x0000000800000000 sp:0x000000016e5b2b70 x19:0x00000001701574a0 x21:0x00000001ab457998 x9:0x0000000000000000 x8:0x00000001a6bcc000 x20:0x0000000000000000 pc:0x00000001883cd970 x28:0xffffffffffffffff x27:0x000000016e5b30e0 x26:0x0000000000000014 x25:0x0000000000000000 x24:0x0000000000000000 x23:0x00000001746f2580 x22:0xdc990b23045700adBinary Images:0x0000000100064000 - 0x0000000103517fff Tmall4iPhone arm64 &lt;d21caba7463b3a38a7ee3ae16448f4b6&gt; /var/containers/Bundle/Application/5F09E0C7-C766-42D8-B2C7-31E335F73349/Tmall4iPhone.app/Tmall4iPhone0x000000018823b000 - 0x00000001885aafff CFNetwork arm64 &lt;ca09941bfd353bb8b6b679a0f14cad1e&gt; /System/Library/Frameworks/CFNetwork.framework/CFNetwork #3 关注点 Identifier: Unknown|com.taobao.tmall, 在这里区分是线上版本还是线下开发版本. Version: 5.24.1 (5.24.1), 应用版本号. Code Type: ARM-64, 代码架构, 目前有ARM/ARM-64两种. OS Version: iPhone OS 10.0.1 (14A403), 系统版本及build号, 用来查找系统库文件, 用于疑难问题的排查. Exception Type: SIGSEGV, 异常类型常见的有SIGSEGV/SIGABRT/SIGTRAP/SIGBUS/SIGILL等. Exception Codes: SEGV_ACCERR at 0x110, 非法访问0x110这个没有访问权限的地址. Triggered by Thread: 42, 挂的线程是Thread 42, 待会看调用栈的时候, 看Thread 42的调用栈就好. 12345SIGSEGV 访问了非法的地址(地址还没有从系统映射到当前进程的内存空间), 一般是野指针导致, 而野指针一般由于多线程操作对象导致.SIGABRT 一般是Exception或者其他的代码主动退出的问题.SIGTRAP 代码里面触发了调试指令, 该指令可能由编译器提供的trap方法触发, 如'__builtin_trap()'SIGBUS 一般由于地址对齐问题导致, 单纯的OC代码挺难触发的, 主要是系统库方法或者其他c实现的方法导致SIGILL 表示执行了非法的cpu指令, 但是一般是由于死循环导致 那么我们来看 Thread 42 123Thread 42 Crashed:0 CFNetwork 0x00000001883cd970 __ZN15TCPIOConnection12copyPropertyEPK10__CFString :44 (in CFNetwork)1 CoreFoundation 0x0000000187bedcec ___CFRunLoopServiceMachPort :192 (in CoreFoundation) 这里我们取了两条调用栈记录, 这里的每条调用记录都叫做frame, 每条有一个编号0和1, 这个编号代表的是frame number, 它是当前frame在整个调用栈中的索引. 先看frame #0, frame #0是当前调用的方法的信息, 0 CFNetwork 0x00000001883cd970 __ZN15TCPIOConnection12copyPropertyEPK10__CFString :44 (in CFNetwork), CFNetwork代表当前frame调用的方法所在的镜像(可执行文件或动态库)的名称, 0x00000001883cd970代表当前执行的指令在内存中的地址(也就是crash的指令的地址), __ZN15TCPIOConnection12copyPropertyEPK10__CFString :44 是前面那个地址符号化后的方法名称, :44表示挂的指令相对于符号化出来的方法的首地址的偏移量. 再看frame #1, frame #1是调用frame #0方法的地方, 1 CoreFoundation 0x0000000187bedcec ___CFRunLoopServiceMachPort :192 (in CoreFoundation), 镜像名和地址不多说, 这里要说说偏移量:192, 除了frame #0的方法地址是取的pc寄存器的内容(存放的当前指令的地址), 而其他frame实际上存的都是历史记录, 而为了省内存和cpu, frame中并不会保存所有的寄存器的值, 只存了lr寄存器的内容(存放的是方法调用完后要返回的地址), 而返回地址是调用方法的地址的下一个指令地址. 因此偏移量192(lr), 对应的调用处的地址是188(pc). 其他frame的看法参见frame #1. Thread State:, 后面跟的内容是在frame #0挂的时候的所有寄存器的值, 寄存器中可能存放的是一个指令的地址/一个指向对象的指针/一个数值. 寄存器的值结合汇编代码, 可以推断具体是对某个方法调用的参数或者类的成员变量导致的野指针. 后续会有详细的问题分析实战文章做介绍. Binary Images: 表示当前运行时所加载的所有的镜像的名称/uuid/加载地址等信息. 看一条示例: 10x0000000100064000 - 0x0000000103517fff Tmall4iPhone arm64 &lt;d21caba7463b3a38a7ee3ae16448f4b6&gt; /var/containers/Bundle/Application/5F09E0C7-C766-42D8-B2C7-31E335F73349/Tmall4iPhone.app/Tmall4iPhone 000000100064000 - 0x0000000103517fff表示镜像Tmall4iPhone在内存中的加载地址的起始范围, 这个在符号化和调试疑难问题时是一个很重要的参考. Tmall4iPhone是镜像名称, arm64是架构, d21caba7463b3a38a7ee3ae16448f4b6是镜像的uuid, /var/containers/Bundle/Application/5F09E0C7-C766-42D8-B2C7-31E335F73349/Tmall4iPhone.app/Tmall4iPhone是镜像在用户手机上地址. 注1: uuid可以通过dwarfdump --uuid Tmall4iPhone 查看, 确定镜像是否相同.","link":"/back/%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90Crash%E6%97%A5%E5%BF%97.html"},{"title":"深入理解 autorelease","text":"深入理解 autorelease 先上一段代码，分别实现了包含 autorelease pool 不包含 autorelease pool 的函数 123456789void autoreleasepool() { @autoreleasepool { NSObject *a = [[NSObject alloc] init]; }}void noautoreleasepool() { NSObject *a = [[NSObject alloc] init];} 编译后再用hopper disassembler 反编译，然后看 autorelasepool函数的汇编代码。 123456789101112131415161718192021222324252627282930 _autoreleasepool:0000000100006b80 stp x29, x30, [sp, #0xfffffff0]! ; XREF=_main+240000000100006b84 mov x29, sp0000000100006b88 sub sp, sp, #0x100000000100006b8c bl imp___stubs__objc_autoreleasePoolPush0000000100006b90 adrp x8, #0x100008000 ; imp___got_dyld_stub_binder0000000100006b94 add x8, x8, #0xc30 ; @selector(alloc)0000000100006b98 adrp x9, #0x100008000 ; imp___got_dyld_stub_binder0000000100006b9c add x9, x9, #0xc40 ; objc_cls_ref_NSObject0000000100006ba0 ldr x9, [x9] ; objc_cls_ref_NSObject0000000100006ba4 ldr x1, [x8] ; @selector(alloc)0000000100006ba8 str x0, [sp]0000000100006bac mov x0, x90000000100006bb0 bl imp___stubs__objc_msgSend0000000100006bb4 adrp x8, #0x100008000 ; imp___got_dyld_stub_binder0000000100006bb8 add x8, x8, #0xc38 ; @selector(init)0000000100006bbc ldr x1, [x8] ; @selector(init)0000000100006bc0 bl imp___stubs__objc_msgSend0000000100006bc4 movz x8, #0x00000000100006bc8 add x9, sp, #0x80000000100006bcc str x0, [sp, #0x8]0000000100006bd0 mov x0, x90000000100006bd4 mov x1, x80000000100006bd8 bl imp___stubs__objc_storeStrong0000000100006bdc ldr x0, [sp]0000000100006be0 bl imp___stubs__objc_autoreleasePoolPop0000000100006be4 mov sp, x290000000100006be8 ldp x29, x30, [sp], #0x100000000100006bec ret ; endp 再看 noautoreleasepool 函数的反汇编代码： 1234567891011121314151617181920212223242526 _noautoreleasepool:0000000100006bf0 stp x29, x30, [sp, #0xfffffff0]! ; XREF=_main+280000000100006bf4 mov x29, sp0000000100006bf8 sub sp, sp, #0x100000000100006bfc adrp x8, #0x100008000 ; imp___got_dyld_stub_binder0000000100006c00 add x8, x8, #0xc30 ; @selector(alloc)0000000100006c04 adrp x9, #0x100008000 ; imp___got_dyld_stub_binder0000000100006c08 add x9, x9, #0xc40 ; objc_cls_ref_NSObject0000000100006c0c ldr x9, [x9] ; objc_cls_ref_NSObject0000000100006c10 ldr x1, [x8] ; @selector(alloc)0000000100006c14 mov x0, x90000000100006c18 bl imp___stubs__objc_msgSend0000000100006c1c adrp x8, #0x100008000 ; imp___got_dyld_stub_binder0000000100006c20 add x8, x8, #0xc38 ; @selector(init)0000000100006c24 ldr x1, [x8] ; @selector(init)0000000100006c28 bl imp___stubs__objc_msgSend0000000100006c2c movz x8, #0x00000000100006c30 add x9, sp, #0x80000000100006c34 str x0, [sp, #0x8]0000000100006c38 mov x0, x90000000100006c3c mov x1, x80000000100006c40 bl imp___stubs__objc_storeStrong0000000100006c44 mov sp, x290000000100006c48 ldp x29, x30, [sp], #0x100000000100006c4c ret ; endp 两者的区别是 autorelease 版本多了如下内容 12345670000000100006b8c bl imp___stubs__objc_autoreleasePoolPush ; 调用 objc_autoreleasePoolPush方法0000000100006ba8 str x0, [sp] ; 把objc_autoreleasePoolPush的返回值入栈......0000000100006bdc ldr x0, [sp] ; 把之前入栈的返回值出栈0000000100006be0 bl imp___stubs__objc_autoreleasePoolPop ; 调用objc_autoreleasePoolPop方法 发现了和预想不一样的地方，按照常理，在 autoreleasepool 里面的对象初始化的时候，似乎要调用-[NSObject autorelease] 来让他自动释放，然而，并没有。 看看 objc 的源码 objc_autoreleasePoolPush 和 objc_autoreleasePoolPop 的实现。 objc_autoreleasePoolPush 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162void *objc_autoreleasePoolPush(void){ if (UseGC) return nil; return AutoreleasePoolPage::push();}static inline void *push() { id *dest; if (DebugPoolAllocation) { // Each autorelease pool starts on a new pool page. dest = autoreleaseNewPage(POOL_SENTINEL); } else { dest = autoreleaseFast(POOL_SENTINEL); } assert(*dest == POOL_SENTINEL); return dest;}static inline id *autoreleaseFast(id obj){ AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) { return page-&gt;add(obj); } else if (page) { return autoreleaseFullPage(obj, page); } else { return autoreleaseNoPage(obj); }}static __attribute__((noinline))id *autoreleaseNoPage(id obj){ // No pool in place. assert(!hotPage()); if (obj != POOL_SENTINEL &amp;&amp; DebugMissingPools) { // We are pushing an object with no pool in place, // and no-pool debugging was requested by environment. _objc_inform(&quot;MISSING POOLS: Object %p of class %s &quot; &quot;autoreleased with no pool in place - &quot; &quot;just leaking - break on &quot; &quot;objc_autoreleaseNoPool() to debug&quot;, (void*)obj, object_getClassName(obj)); objc_autoreleaseNoPool(obj); return nil; } // Install the first page. AutoreleasePoolPage *page = new AutoreleasePoolPage(nil); setHotPage(page); // Push an autorelease pool boundary if it wasn't already requested. if (obj != POOL_SENTINEL) { page-&gt;add(POOL_SENTINEL); } // Push the requested object. return page-&gt;add(obj);} push 的主要作用是选一个/建一个autoreleasePoolPage ，设定为hotpage备用，流程图如下 objc_autoreleasePoolPop 1","link":"/back/%E7%90%86%E8%A7%A3autorelease.html"},{"title":"分类","text":"","link":"/categories/index.html"},{"title":"404 Not Found","text":"对不起，您所访问的页面不存在或者已删除。 您可以点击此处返回首页。 ACE_xW","link":"/source/404.html"},{"title":"标签","text":"","link":"/tags/index.html"},{"title":"关于我们","text":"ACE_xW 简介 联系方式 Blog: http://bapuqln.github.io GitHub: https://github.com/bapuqln","link":"/source/about/index.html"},{"title":"分类","text":"","link":"/source/categories/index.html"},{"title":"ARM 汇编","text":"ARM 汇编 Layout label: instruction ;comment &gt;label 字母、下划线和 $ 组成. &gt;comment 所有在;后面的都认为是注释 &gt;instruction 指令 1234567 .textstart: MOV r1, #20 ;puts the value 20 into register r1 MOV r2, #22 ;puts the value 22 into register r2 ADD r0, r1, r2 ;adds r1 and r2, r0 contains 42end: b end ;infinite loop, always jump back to end Instruction Format &lt;op&gt;{cond}{flags} Rd, Rn, Operand2 例如: ADD r0, r1, r2 三个字母的指令 {cond} 可选，两个字母的状态码(condition code) {flags} 可选，附加标志位 Rd 目标寄存器 Rn 第一个寄存器 Operand2 第二个寄存器或者操作数 Condition Code 在指令后面添加，允许指令在特定条件下执行。 AL - always 无条件执行，因此可以不用写 ADDAL 和 ADD 是等价的 NV - never。 AL 的反义词，带有该标记的指令不会执行。已经废弃。 EQ - equal 当 Z 标志为被设置过后，才会执行，如果 Z 标志位被清除，该行指令被忽略. MOV r0, #42 ;Write the value 42 into the register r0MOV r1, #41 ;Write the value 41 into the register r1CMP r0, r1 ;Compare the registers r0 and r1, update CPSR register BEQ label ;This command will not be run, since Z = 0MOV r1, #42 ;Write the value 42 into the register r1CMP r0, r1 ;Compare r0 and r1, update the CPSRBEQ label ;This command will be run, since Z = 1 1234* NE - not equal &gt; EQ 的反义词，如果 Z 标志位被清除，则执行。如果 Z 标志位被设置过，该行指令被忽略 MOV r0, #42 ;Write the value 42 into the register r0MOV r1, #42 ;Write the value 42 into the register r1CMP r0, r1 ;Compare the registers r0 and r1, update CPSR register BNE label ;This command will not be run, since Z = 1MOV r1, #41 ;Write the value 42 into the register r1CMP r0, r1 ;Compare r0 and r1, update the CPSRBNE label ;This command will be run, since Z = 0 12345678910111213* VS - overflow set &gt; 如果 overflow(v) 位被设置，该条件为 true。两个32位有符号数相加，可能会出一个33位的有符号数* VC - overflow clear &gt; 如果 overflow(v) 位被清除，该条件为 true。 * MI - minus &gt; 如果 negative(N) 为被设置，该条件为 true MOV r0, #40MOV r1, #42SUBS r2, r0, r1 ; 40 – 42, the result is negative BMI destination ; this portion of code is never executed PL - plus 如果 negative(N) 位被清除，该条件为 true。(&lt;= 0) CS - Carry Set 当一个在32位无符号数上的操作超出了32位的范围的时候，carry set 标志位设为 true CC - Carry Clear 如果 Carry Flag(C) 被清除了，该条语句执行 HI - Higher 如果 Carry Flag(C) 被设置，并且结果非0(Z)，该语句执行 LS - Lower or Same 如果 Carry Flag(C) 被清除，并且结果为0(Z)，该语句执行 GE - Greater than or Equal 当有符号数，并且当 Negative(N) 和 Overflow(V) 相等的时候，该语句才有效 LT - Less Than 有符号数，并且当 Negative(V) 和 Overflow(V) 不相等的时候，该语句才有效。 LE - Less Than or Equal 像 LT， 如果 Negative(V) 和 Overflow(V) 不相等，或者 Zero(Z)标志位被设置了的时候，该语句才执行。 CODE MEANING FLAGS EQ Equal equals Zero Z NE Not Equal !Z VS Overflow V VC No overflow !V MI Minus/negative N PL Plus/positive or zero !N CS Carryset/unsigned higher or same C CC Carry clear/unsigned lower !C HI Unsigned higher C and !Z LS Unsigned lower or same !C or Z GE Signed greater than or equal N == V LT Signed less than N != V GT Signed greater than !Z and (N == V) LE Signed less than or equal Z or (N != V) AL Always(default) Any Updating Condition Flags 默认情况下，指令不更新条件标志。 &gt; 当 S (ADDS, SBCS...) 标志位被设置后，指令才能更新标志位。 &gt; 例外：比较指令会自动更新 Objective-C MOV r0, # 80 00 00 0F ; r0 I 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 I I I IMOV r1, r0, LSL #1 ; r1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 I I I I 0","link":"/source/back/ARM%E6%B1%87%E7%BC%96.html"},{"title":"Clang学习笔记","text":"Clang 学习笔记 什么是 Clang Clang 是 LLVM 的前端，可以分析 C 语言家族的所有源代码。 Clang 是如何工作的 预处理：展开所有的宏，将代码解析成抽象语法树 Clang AST 几乎所有的编译器 &amp; 静态分析工具 都是用 AST 来表示原本的代码。 一般来说， Clang AST 由两个类组成：Decl &amp; bStmt。 &gt; FunctionDecl：函数原型或者函数定义 &gt; BinaryOperator：二元表达式，（a+b） &gt; CallExpr：函数调用，foo（x） 怎么使用 Clang Clang Plugin 使用 Clang Plugin，写出的代码本身就是插件。在使用 Clang Plugin 的时候，我们不可以保留不同文件之间的全局信息和其他横跨多个文件的上下文信息。插件的运行是通过传递命令行参数给 build system（Clang/Make），在源文件分析前后，我们不能进行任何的 custom task。插件的存在形式是一个动态链接库。 LibTooling(Clang Tool) 使用 LibTooling，代码本身就是一个正常的 C++ 程序，已正常的 main() 函数作为入口。LibTooling 一般用来把程序构建的过程和程序的分析过程分开。针对每个源程序都会生成分析代码以及对应的 AST，但同时还可以维护不同源代码文件的全局信息。由于程序有 main()函数，我们还可以在分析源代码前后运行其他的任务。 LibClang 当我们想要一个稳定的 API 的时候，LibClang 是一个很好的选择，Clang 变化很块，如果使用 Plugin 或者 LibTooling，我们可能需要更新代码以应对 Clang 的变化。但如果需要在 C++ 以外的地方调用 Clang 的 API 的时候，必须要使用 LibClang。 LibClang 不可以使用完整的 AST（只能使用高层次的 AST），而另外两个选择（Plugin 与 LibTooling）则可以。如果还是无法选择，推荐使用 LibTooling interface，简单好用。LibTooling能够像 Plugin 一样完整的使用 AST，同时还不会丢掉源代码的全局信息。另外设置 LibTooling 比 Plugin 更容易。 开始使用 Clang 编译安装 LLVM 12cd where-you-want-llvm-to-livesvn co http://llvm.org/svn/llvm-project/llvm/trunk llvm Clang 123cd where-you-want-llvm-to-livecd llvm/toolssvn co http://llvm.org/svn/llvm-project/cfe/trunk clang Compile-RT 123cd where-you-want-llvm-to-livecd llvm/projectssvn co http://llvm.org/svn/llvm-project/compiler-rt/trunk compiler-rt 构建 1234cd where you want to build llvmmkdir buildcd buildcmake -G &lt;generator&gt; [options] &lt;path to llvm sources&gt; LibTooling 假如我们要分析一个 C 语言文件如下： 12345678910#No header, because it needs additional effortsvoid do_math(int *x) { *x += 5;}int main(void) { int result = -1, val = 4; do_math(&amp;val); return result;} 我们想要对上述函数进行重构。 * 把函数名do_math 改为 addFive * 把所有的对 do_math 的调用都改为 addFive * 把返回值改为 val 从 main 函数开始 1234567891011121314int main(int argc, const char **argv) { // parse the command-line args passed to your code CommonOptionsParser op(argc, argv, StatSampleCategory); // create a new Clang Tool instance (a LibTooling environment) ClangTool Tool(op.getCompilations(), op.getSourcePathList()); // run the Clang Tool, creating a new FrontendAction (explained below) int result = Tool.run(newFrontendActionFactory&lt;ExampleFrontendAction&gt;().get()); errs() &lt;&lt; &quot;\\nFound &quot; &lt;&lt; numFunctions &lt;&lt; &quot; functions.\\n\\n&quot;; // print out the rewritten source code (&quot;rewriter&quot; is a global var.) rewriter.getEditBuffer(rewriter.getSourceMgr().getMainFileID()).write(errs()); return result;} 首先设置一个 ClangTool，将命令行参数：op.getCompilations() 以及源文件列表 op.getSourcePathList() 传给它，然后就运行这个工具就好了。 LibTooling 的优点在于，可以再工具运行前后做其他的事情，比如说打印出修改前后的代码以及统计函数的个数。 创建 FrontendAction 现在创建自己的 FrontendAction，创建的原因：想要分析 test.c 的 AST 表示。 123456789class ExampleFrontendAction : public ASTFrontendAction {public: ExampleFrontendAction() {} //Note that unique pointer is used. virtual std::unique_ptr&lt;ASTConsumer&gt; CreateASTConsumer(CompilerInstance &amp;CI, StringRef file) { return llvm::make_unique&lt;ExampleASTConsumer&gt;(&amp;CI); // pass CI pointer to ASTConsumer }}; 这里不是很复杂，我们创建了一个ASTFrontendAction的子类，改写了CreateASTConsumer函数以返回我们自己的ASTConsumer。我们还将指向CompileInstance的指针传入，因为这里面包含很多我们需要分析的上下文信息。 构建 ASTConsumer ASTConsumer 由Clang parser产生的AST。我们可以任意地重载ASTConsumer的成员函数，这样解析AST后我们的代码就可以被调用。首先，我们重载函数HandleTopLevelDecl，这在Clang解析完顶级的声明（像全局变量，函数定义等）后就可以被调用了。 1234567891011121314151617181920class ExampleASTConsumer : public ASTConsumer {private: ExampleVisitor *visitor; // doesn't have to be privatepublic: // override the constructor in order to pass CI explicit ExampleASTConsumer(CompilerInstance *CI) : visitor(new ExampleVisitor(CI)) // initialize the visitor { } // override this to call our ExampleVisitor on each top-level Decl virtual bool HandleTopLevelDecl(DeclGroupRef DG) { // a DeclGroupRef may have multiple Decls, so we iterate through each one for (DeclGroupRef::iterator i = DG.begin(), e = DG.end(); i != e; i++) { Decl *D = *i; visitor-&gt;TraverseDecl(D); // recursively visit each AST node in Decl &quot;D&quot; } return true; }}; 以上代码使用了ExampleVisitor（见下文），来访问整个源文件顶级声明（top-level declaration）的AST节点。对于test.c而言，两个FunctionDecl将会被访问，do_math()以及main()。 更好的 ASTConsumer 实现 重载HandleTopLevelDecl()意味着每当一个新的Decl出现的时候，函数中的代码就会被调用，而不是等到整个源文件被解析完成后。从parser的角度看，当访问do_math()的时候，它将完全不知道main()的存在，也就是说我们不能access到当前分析的函数之后的函数。 但是，这个功能很重要！ 不过，ASTConsumer还有一个更好的函数用来重载，HandelTranslationUnit()，该函数只有在整个文件都解析完才被调用。这样的话，一个translation单元就是一整个源文件。ASTContext类用来表示那个源文件的AST，并且包含许多很有用的成员（去读文档吧！）。 所以，下面的代码重载了HandelTranslationUnit(): 123456// override this to call our ExampleVisitor on the entire source file virtual void HandleTranslationUnit(ASTContext &amp;Context) { /* we can use ASTContext to get the TranslationUnitDecl, which is a single Decl that collectively represents the entire source file */ visitor-&gt;TraverseDecl(Context.getTranslationUnitDecl()); } 大多数情况下，我们都应该使用HandelTranslationUnit(), 尤其在使用RecursiveASTVisitor的时候。 创建一个 RecursiveASTVisitor 前面两部分只不过在设置架构，现在到了正文部分了。RecursiveASTVisitor是一个特别有用的类，使用它可以访问任意类型的AST节点，比如FunctionDecl以及Stmt, 只要重载那个函数（比如VisitFunctionDecl以及VisitStmt）就可以了。当然，其它AST类也同样适用这样的规则。Clang提供了一个官方的文档，虽然很短，但是很全面。 像Visit..(表示Visit任意节点的函数，如VisitStmt）这样的函数，我们必须返回true以继续遍历AST或者返回false以终止遍历，退出Clang。我们不可以直接调用Visit..，而是应该调用TraverseDecl（正如我们前面的那个例子一样），调用Visit..函数则是在背后调用的。 由于我们只需要改写函数定义和一些statement，我们只需要重载VisitFunctionDecl和VisitStmt。下面是部分代码： 12345678910111213141516171819202122232425262728293031class ExampleVisitor : public RecursiveASTVisitor&lt;ExampleVisitor&gt; {private: ASTContext *astContext; // used for getting additional AST infopublic: explicit ExampleVisitor(CompilerInstance *CI): astContext(&amp;(CI-&gt;getASTContext())) { // initialize private members rewriter.setSourceMgr(astContext-&gt;getSourceManager(), astContext-&gt;getLangOpts()); } virtual bool VisitFunctionDecl(FunctionDecl *func) { numFunctions++; string funcName = func-&gt;getNameInfo().getName().getAsString(); if (funcName == &quot;do_math&quot;) { rewriter.ReplaceText(func-&gt;getLocation(), funcName.length(), &quot;add5&quot;); errs() &lt;&lt; &quot;** Rewrote function def: &quot; &lt;&lt; funcName &lt;&lt; &quot;\\n&quot;; } return true; } virtual bool VisitStmt(Stmt *st) { if (ReturnStmt *ret = dyn_cast&lt;ReturnStmt&gt;(st)) { rewriter.ReplaceText(ret-&gt;getRetValue()-&gt;getLocStart(), 6, &quot;val&quot;); errs() &lt;&lt; &quot;** Rewrote ReturnStmt\\n&quot;; } if (CallExpr *call = dyn_cast&lt;CallExpr&gt;(st)) { rewriter.ReplaceText(call-&gt;getLocStart(), 7, &quot;add5&quot;); errs() &lt;&lt; &quot;** Rewrote function call\\n&quot;; } return true; }}; 以上的代码引入了Rewriter类，可以让我们对源代码进行修改，这在代码重构或者小规模的代码修改里面很常见。我们还在main()函数的末尾用它打印出了修改后的代码。 使用Rewriter意味着我们需要找到正确SourceLocation来插入或者替换相关的代码。同时，我们还使用了dyn_cast，来检查Stmt st是一个ReturnStmt还是CallExpr。而errs()是一个stderr流，在LLVM/Clang里面打印debug信息 写一个更具体的Visit..函数 除了更一般化地重载VisitStmt，我们可以更具体化地重载VisitReturnStme以及VisitCallExpr。VisitReturnStme和VisitCallExpr都是Stmt的子类。这就是Clang AST和RecursiveASTVisitor的美妙之处：我们可以选择一般化或者是具体化，下面就是代码 1234567891011// this replaces the VisitStmt function abovevirtual bool VisitReturnStmt(ReturnStmt *ret) { rewriter.ReplaceText(ret-&gt;getLocStart(), 6, &quot;val&quot;); errs() &lt;&lt; &quot;** Rewrote ReturnStmt\\n&quot;; return true;}virtual bool VisitCallExpr(CallExpr *call) { rewriter.ReplaceText(call-&gt;getLocStart(), 7, &quot;add5&quot;); errs() &lt;&lt; &quot;** Rewrote function call\\n&quot;; return true;}","link":"/source/back/Clang%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"},{"title":"Clang plugin with Xcode","text":"Creating and using Clang plugin with Xcode 环境设置 plugin 设置 Xcode 工程设置 warnning error Xcode 集成 与 error/warning 的交互 环境设置 需要 llvm/clang，源码 12345678910111213141516171819cd /optsudo mkdir llvmsudo chown `whoami` llvmcd llvmexport LLVM_HOME=`pwd```` 2. 根据本机的 clang 版本来编译,本机3.3.1 为例```C++git clone -b release_33 https://github.com/llvm-mirror/llvm.git llvmgit clone -b release_33 https://github.com/llvm-mirror/clang.git llvm/tools/clanggit clone -b release_33 https://github.com/llvm-mirror/clang-tools-extra.git llvm/tools/clang/tools/extragit clone -b release_33 https://github.com/llvm-mirror/compiler-rt.git llvm/projects/compiler-rt mkdir llvm_buildcd llvm_buildcmake ../llvm -DCMAKE_BUILD_TYPE:STRING=Releasemake -j`sysctl -n hw.logicalcpu` plugin 设置 创建 plugin 的文件夹 12cd $LLVM_HOMEmkdir toy_clang_plugin; cd toy_clang_plugin 基于 plugin 的例子结构如下 ToyClangPlugin.exports CMakeLists.txt ToyClangPlugin.cpp 文件内容 ToyClangPlugin.cpp 12345678910111213141516171819202122232425262728293031#include &quot;clang/Frontend/FrontendPluginRegistry.h&quot;#include &quot;clang/AST/AST.h&quot;#include &quot;clang/AST/ASTConsumer.h&quot;#include &quot;clang/Frontend/CompilerInstance.h&quot; using namespace clang; namespace{ class ToyConsumer : public ASTConsumer { }; class ToyASTAction : public PluginASTAction { public: virtual clang::ASTConsumer *CreateASTConsumer(CompilerInstance &amp;Compiler, llvm::StringRef InFile) { return new ToyConsumer; } bool ParseArgs(const CompilerInstance &amp;CI, const std::vector&lt;std::string&gt;&amp; args) { return true; } };} static clang::FrontendPluginRegistry::Add&lt;ToyASTAction&gt;X(&quot;ToyClangPlugin&quot;, &quot;Toy Clang Plugin&quot;); CMakeLists.txt 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124cmake_minimum_required (VERSION 2.6)project (ToyClangPlugin) set( CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin )set( CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib )set( CMAKE_ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/lib ) set( LLVM_HOME /opt/llvm )set( LLVM_SRC_DIR ${LLVM_HOME}/llvm )set( CLANG_SRC_DIR ${LLVM_HOME}/llvm/tools/clang )set( LLVM_BUILD_DIR ${LLVM_HOME}/llvm_build )set( CLANG_BUILD_DIR ${LLVM_HOME}/llvm_build/tools/clang) add_definitions (-D__STDC_LIMIT_MACROS -D__STDC_CONSTANT_MACROS)add_definitions (-D_GNU_SOURCE -DHAVE_CLANG_CONFIG_H) set (CMAKE_CXX_COMPILER &quot;${LLVM_BUILD_DIR}/bin/clang++&quot;)set (CMAKE_CC_COMPILER &quot;${LLVM_BUILD_DIR}/bin/clang&quot;) set (CMAKE_CXX_FLAGS &quot;${CMAKE_CXX_FLAGS} -fPIC -fno-common -Woverloaded-virtual -Wcast-qual -fno-strict-aliasing -pedantic -Wno-long-long -Wall -Wno-unused-parameter -Wwrite-strings -fno-exceptions -fno-rtti&quot;) set (CMAKE_MODULE_LINKER_FLAGS &quot;-Wl,-flat_namespace -Wl,-undefined -Wl,suppress&quot;) set (LLVM_LIBS LLVMJIT LLVMX86CodeGen LLVMX86AsmParser LLVMX86Disassembler LLVMExecutionEngine LLVMAsmPrinter LLVMSelectionDAG LLVMX86AsmPrinter LLVMX86Info LLVMMCParser LLVMCodeGen LLVMX86Utils LLVMScalarOpts LLVMInstCombine LLVMTransformUtils LLVMipa LLVMAnalysis LLVMTarget LLVMCore LLVMMC LLVMSupport LLVMBitReader LLVMOption) macro(add_clang_plugin name) set (srcs ${ARGN}) include_directories( &quot;${LLVM_SRC_DIR}/include&quot; &quot;${CLANG_SRC_DIR}/include&quot; &quot;${LLVM_BUILD_DIR}/include&quot; &quot;${CLANG_BUILD_DIR}/include&quot; ) link_directories( &quot;${LLVM_BUILD_DIR}/lib&quot; ) add_library( ${name} SHARED ${srcs} ) if (SYMBOL_FILE) set_target_properties( ${name} PROPERTIES LINK_FlAGS &quot;-exported_symbols_list ${SYMBOL_FILE}&quot;) endif() foreach (clang_lib ${CLANG_LIBS}) target_link_libraries( ${name} ${clang_lib} ) endforeach() foreach (llvm_lib ${LLVM_LIBS}) target_link_libraries( ${name} ${llvm_lib} ) endforeach() foreach (user_lib ${USER_LIBS}) target_link_libraries( ${name} ${user_lib} ) endforeach() endmacro(add_clang_plugin) set(SYMBOL_FILE ToyClangPlugin.exports) set (CLANG_LIBS clang clangFrontend clangAST clangAnalysis clangBasic clangCodeGen clangDriver clangFrontendTool clangLex clangParse clangSema clangEdit clangSerialization clangStaticAnalyzerCheckers clangStaticAnalyzerCore clangStaticAnalyzerFrontend) set (USER_LIBS pthread curses) add_clang_plugin(ToyClangPlugin ToyClangPlugin.cpp) set_target_properties(ToyClangPlugin PROPERTIES LINKER_LANGUAGE CXX PREFIX &quot;&quot;) ToyClangPlugin.exports 1__ZN4llvm8Registry* 现在我们能够基于 CMakeLists.txt 生成 Xcode-project， 123mkdir build; cd buildcmake -G Xcode ..open ToyClangPlugin.xcodeproj 运行 ALL_BUILD target ，然后就能看到动态库：lib/Debug/ToyClangPlugin.dylib RecuresiveASTVisitor Clang 的 AST 模块提供了RecuresiveASTVisitor，他能够让你编译整个 AST，我们只需要创建一个子类并且实现我们感兴趣的方法就行。为了测试一下，现在只是打印所有发现的类名。 12345678910111213141516171819class ToyClassVisitor : public RecursiveASTVisitor&lt;ToyClassVisitor&gt;{public: bool VisitObjCInterfaceDecl(ObjCInterfaceDecl *declaration) { printf(&quot;ObjClass: %s\\n&quot;, declaration-&gt;getNameAsString().c_str()); return true; }}; class ToyConsumer : public ASTConsumer{public: void HandleTranslationUnit(ASTContext &amp;context) { visitor.TraverseDecl(context.getTranslationUnitDecl()); }private: ToyClassVisitor visitor;}; 下面我们就来创建测试的文件并且看看 plugin 是如何工作的。 123456789#import &lt;Foundation/Foundation.h&gt; @interface ToyObject : NSObject @end @implementation ToyObject @end rebuild &amp; 运行 插件 12345/opt/llvm/toy_clang_plugin/build $ $LLVM_HOME/llvm_build/bin/clang ../test.m \\ -Xclang -load \\ -Xclang lib/Debug/ToyClangPlugin.dylib \\ -Xclang -plugin \\ -Xclang ToyClangPlugin 报警告 下面我们试试这个情况：类名是以小写字母开始。 在 ToyClassVisitor 中增加 ASTContext 123456789101112131415161718class ToyClassVisitor : public RecursiveASTVisitor&lt;ToyClassVisitor&gt;{private: ASTContext *context;public: void setContext(ASTContext &amp;context) { this-&gt;context = &amp;context; }// ...}; // ...void HandleTranslationUnit(ASTContext &amp;context) { visitor.setContext(context); visitor.TraverseDecl(context.getTranslationUnitDecl());} // ... 增加检测 1234567891011121314151617bool VisitObjCInterfaceDecl(ObjCInterfaceDecl *declaration){ checkForLowercasedName(declaration); return true;}// ...void checkForLowercasedName(ObjCInterfaceDecl *declaration){ StringRef name = declaration-&gt;getName(); char c = name[0]; if (isLowercase(c)) { DiagnosticsEngine &amp;diagEngine = context-&gt;getDiagnostics(); unsigned diagID = diagEngine.getCustomDiagID(DiagnosticsEngine::Warning, &quot;Class name should not start with lowercase letter&quot;); SourceLocation location = declaration-&gt;getLocation(); diagEngine.Report(location, diagID); }} 测一下 1234567@interface bad_ToyObject : NSObject @end @implementation bad_ToyObject @end rebuild &amp; run 12345678910/opt/llvm/toy_clang_plugin/build $ $LLVM_HOME/llvm_build/bin/clang ../test.m \\ -Xclang -load \\ -Xclang lib/Debug/ToyClangPlugin.dylib \\ -Xclang -plugin \\ -Xclang ToyClangPlugin ../test.m:11:12: warning: Class name should not start with lowercase letter@interface bad_ToyObject : NSObject ^1 warning generated. 报错误 试一下如果类名里面包含下划线 123456789101112131415161718void checkForUnderscoreInName(ObjCInterfaceDecl *declaration){ size_t underscorePos = declaration-&gt;getName().find('_'); if (underscorePos != StringRef::npos) { DiagnosticsEngine &amp;diagEngine = context-&gt;getDiagnostics(); unsigned diagID = diagEngine.getCustomDiagID(DiagnosticsEngine::Error, &quot;Class name with `_` forbidden&quot;); SourceLocation location = declaration-&gt;getLocation().getLocWithOffset(underscorePos); diagEngine.Report(location, diagID); }} bool VisitObjCInterfaceDecl(ObjCInterfaceDecl *declaration){ // disable this check temporary // checkForLowercasedName(declaration); checkForUnderscoreInName(declaration); return true;} 看看运行后的输出 12345678910/opt/llvm/toy_clang_plugin/build $ $LLVM_HOME/llvm_build/bin/clang ../test.m \\ -Xclang -load \\ -Xclang lib/Debug/ToyClangPlugin.dylib \\ -Xclang -plugin \\ -Xclang ToyClangPlugin ../test.m:11:15: error: Class name with `_` forbidden@interface bad_ToyObject : NSObject ^1 error generated. 我们试试两个监测都打开的时候的样子 12345678910111213/opt/llvm/toy_clang_plugin/build $ $LLVM_HOME/llvm_build/bin/clang ../test.m \\ -Xclang -load \\ -Xclang lib/Debug/ToyClangPlugin.dylib \\ -Xclang -plugin \\ -Xclang ToyClangPlugin ../test.m:11:12: warning: Class name should not start with lowercase letter@interface bad_ToyObject : NSObject ^../test.m:11:15: error: Class name with `_` forbidden@interface bad_ToyObject : NSObject ^1 warning and 1 error generated. Xcode 集成 很遗憾，Xcode 的 clang 并不支持插件，所以我们要这么做。 在 Xcode 中启用自定义编译工具 12sudo mv HackedClang.xcplugin `xcode-select -print-path`/../PlugIns/Xcode3Core.ideplugin/Contents/SharedSupport/Developer/Library/Xcode/Plug-inssudo mv HackedBuildSystem.xcspec `xcode-select -print-path`/Platforms/iPhoneSimulator.platform/Developer/Library/Xcode/Specifications 这样就能在 build option 里面找到编译器了 在 OTHER_CFLAGS 中增加 1-Xclang -load -Xclang /opt/llvm/toy_clang_plugin/build/lib/Debug/ToyClangPlugin.dylib -Xclang -add-plugin -Xclang ToyClangPlugin 注意：这个地方使用 -add-plugin，因为我们想用自己的 ASTAction，而不是替换掉现存的 在 Module - CLANG_ENABLE_MODULES 设置为 NO 把之前新建的 test.m 增加到工程中。即可见到 增加交互 针对 warning &amp; error 增加 FixItHints 123456789101112131415161718192021222324252627282930313233343536373839404142void checkForLowercasedName(ObjCInterfaceDecl *declaration){ StringRef name = declaration-&gt;getName(); char c = name[0]; if (isLowercase(c)) { std::string tempName = name; tempName[0] = toUppercase(c); StringRef replacement(tempName); SourceLocation nameStart = declaration-&gt;getLocation(); SourceLocation nameEnd = nameStart.getLocWithOffset(name.size()); FixItHint fixItHint = FixItHint::CreateReplacement(SourceRange(nameStart, nameEnd), replacement); DiagnosticsEngine &amp;diagEngine = context-&gt;getDiagnostics(); unsigned diagID = diagEngine.getCustomDiagID(DiagnosticsEngine::Warning, &quot;Class name should not start with lowercase letter&quot;); SourceLocation location = declaration-&gt;getLocation(); diagEngine.Report(location, diagID).AddFixItHint(fixItHint); }} void checkForUnderscoreInName(ObjCInterfaceDecl *declaration){ StringRef name = declaration-&gt;getName(); size_t underscorePos = name.find('_'); if (underscorePos != StringRef::npos) { std::string tempName = name; std::string::iterator end_pos = std::remove(tempName.begin(), tempName.end(), '_'); tempName.erase(end_pos, tempName.end()); StringRef replacement(tempName); SourceLocation nameStart = declaration-&gt;getLocation(); SourceLocation nameEnd = nameStart.getLocWithOffset(name.size()); FixItHint fixItHint = FixItHint::CreateReplacement(SourceRange(nameStart, nameEnd), replacement); DiagnosticsEngine &amp;diagEngine = context-&gt;getDiagnostics(); unsigned diagID = diagEngine.getCustomDiagID(DiagnosticsEngine::Error, &quot;Class name with `_` forbidden&quot;); SourceLocation location = declaration-&gt;getLocation().getLocWithOffset(underscorePos); diagEngine.Report(location, diagID).AddFixItHint(fixItHint); }}","link":"/source/back/Creating_and_using_Clang_plugin_with_Xcode.html"},{"title":"LLVM &amp; Clang","text":"LLVM &amp; Clang LLVM DragonMediu LLVM（Low Level Virtual Machine） 是一个底层虚拟机，但是现在是一系列编译器和工具链的合集，而且是模块化和可重用的。 #### LLVM 的结构 传统的编译器分为三个阶段：前端，优化，后端 Untitled LLVM 也是三段式结构。 如果要支持一个新的硬件设备，只需要实现一个新的后端。要支持一个新的语言，只需要实现一个新的前端。 优化阶段 针对了统一的 LLVM IR，LLVM IR 主要有三种格式（完全等价） * 在内存中的编译中间语言 * 硬盘上存储的二进制中间语言（.bc） * 可读的中间格式（.ll） Demo - hello.c 1 生成一个二进制的 .bc 文件 生成一个 .ll 文件","link":"/source/back/LLVM_Clang.html"},{"title":"Mesh Transforms","text":"Mesh Transforms 先上源代码 本文很简单粗暴，在 layer 中引入了一些点，然后通过移动点来改变整体的形状。 CAMeshVertex CAMeshVertex 是相当简单的一个结构体 1234typedef struct CAMeshVertex { CGPoint from; CAPoint3D to;} CAMeshVertex; CAPoint3D 看上去和 CGPoint 很类似，只不过拓展了 z 轴 12345typedef struct CAPoint3D { CGFloat x; CGFloat y; CGFloat z;} CAPoint3D; CAMeshVertex 的想法是相当简单：他描述了平面点和3D 空间的映射， CAMeshFace 1234typedef struct CAMeshFace { unsigned int indices[4]; float w[4];} CAMeshFace;","link":"/source/back/Mesh_Transform.html"},{"title":"MVC、MVP、MVVM","text":"MVC. MVP. MVVM 架构模式 MVX 中的 Model 在大多数的iOS项目中，Model 层只是一个单纯的数据结构，大部分的模型都是这样的 12345678910struct User { enum Gender: String { case male = &quot;male&quot; case female = &quot;female&quot; } let name: String let email: String let age: Int let gender: Gender} 模型起到了定义一堆坑的作用，只是一个简单的模板，并没有参与到实际的业务逻辑，只是在模型层进行了一些抽象，将服务器端发回的JSON或者说NSDictionary 对象中的字段一一取出并填装到预先定义好的模型中。 可以将这种模型层中提供的对象理解为即开即用的NSDictionary实例，在使用时，可以直接从模型中取出属性，省去了从NSDictionary中抽出属性以及验证是否合法的过程. JSON -&gt; Model 使用 Swift 将 Dictionary 转换成模型，在笔者看来其实是一件比较麻烦的事情，主要原因是 Swift 作为一个号称类型安全的语言，有着使用体验非常差的 Optional 特性，从 Dictionary 中取出的值都是不一定存在的，所以如果需要纯手写这个过程其实还是比较麻烦的. 123456789extension User { init(json: [String: Any]) { let name = json[&quot;name&quot;] as! String let email = json[&quot;email&quot;] as! String let age = json[&quot;age&quot;] as! Int let gender = Gender(rawValue: json[&quot;gender&quot;] as! String)! self.init(name: name, email: email, age: age, gender: gender) }} 这里为 User 模型创建了一个 extension 并写了一个简单的模型转换的初始化方法，当我们从 JSON 对象中取值时，得到的都是 Optional 对象；而在大多数情况下，我们都没有办法直接对 Optional 对象进行操作，这就非常麻烦了。 麻烦的 Optional 在 Swift 中遇到无法立即使用的 Optional 对象时，我们可以会使用 ! 默认将字典中取出的值当作非 Optional 处理，但是如果服务端发回的数据为空，这里就会直接崩溃；当然，也可使用更加安全的 if let 对 Optional 对象进行解包（unwrap）。 123456789101112extension User { init?(json: [String: Any]) { if let name = json[&quot;name&quot;] as? String, let email = json[&quot;email&quot;] as? String, let age = json[&quot;age&quot;] as? Int, let genderString = json[&quot;gender&quot;] as? String, let gender = Gender(rawValue: genderString) { self.init(name: name, email: email, age: age, gender: gender) } return nil }} 上面的代码看起来非常的丑陋，而正是因为上面的情况在 Swift 中非常常见，所以社区在 Swift 2.0 中引入了 guard 关键字来优化代码的结构。 123456789101112extension User { init?(json: [String: Any]) { guard let name = json[&quot;name&quot;] as? String, let email = json[&quot;email&quot;] as? String, let age = json[&quot;age&quot;] as? Int, let genderString = json[&quot;gender&quot;] as? String, let gender = Gender(rawValue: genderString) else { return nil } self.init(name: name, email: email, age: age, gender: gender) }} 不过，上面的代码在笔者看来，并没有什么本质的区别，不过使用 guard 对错误的情况进行提前返回确实是一个非常好的编程习惯。 不关心空值的 Objective-C 为什么 Objective-C 中没有这种问题呢？主要原因是在 OC 中所有的对象其实都是 Optional 的，我们也并不在乎对象是否为空，因为在 OC 中向 nil 对象发送消息并不会造成崩溃，Objective-C 运行时仍然会返回 nil 对象。 OC 作为动态语言，这种设计思路其实还是非常优秀的，它避免了大量由于对象不存在导致无法完成方法调用造成的崩溃；同时，作为开发者，我们往往都不需要考虑 nil 的存在，所以使用 OC 时写出的模型转换的代码都相对好看很多。 1234567891011121314151617181920212223242526272829// User.htypedef NS_ENUM(NSUInteger, Gender) { Male = 0, Female = 1,};@interface User: NSObject@property (nonatomic, strong) NSString *email;@property (nonatomic, strong) NSString *name;@property (nonatomic, assign) NSUInteger age;@property (nonatomic, assign) Gender gender;@end// User.m@implementation User- (instancetype)initWithJSON:(NSDictionary *)json { if (self = [super init]) { self.email = json[@&quot;email&quot;]; self.name = json[@&quot;name&quot;]; self.age = [json[@&quot;age&quot;] integerValue]; self.gender = [json[@&quot;gender&quot;] integerValue]; } return self;}@end 元编程能力 从上面的代码，我们可以看出：Objective-C 和 Swift 对于相同功能的处理，却有较大差别的实现。这种情况的出现主要原因是语言的设计思路导致的；Swift 一直鼓吹自己有着较强的安全性，能够写出更加稳定可靠的应用程序，而安全性来自于 Swift 语言的设计哲学；由此看来静态类型、安全和动态类型、元编程能力（？）看起来是比较难以共存的。 OC 中对于 nil 的处理能够减少我们在编码时的工作量，不过也对工程师的代码质量提出了考验。我们需要思考 nil 的出现会不会带来崩溃，是否会导致行为的异常、增加应用崩溃的风险以及不确定性，而这也是 Swift 引入 Optional 这一概念来避免上述问题的初衷。 相比而言，笔者还是更喜欢强大的元编程能力，这样可以减少大量的重复工作并且提供更多的可能性，与提升工作效率相比，牺牲一些安全性还是可以接受的。 网络服务Service 层 现有的大多数应用都会将网路服务组织成单独的一层，所以有时候你会看到所谓的 MVCS 架构模式，它其实只是在 MVC 的基础上加上了一个服务层（Service），而在 iOS 中常见的 MVC 架构模式也都可以理解为 MVCS 的形式，当引入了 Service 层之后，整个数据的获取以及处理的流程是这样的： 大多数情况下服务的发起都是在 Controller 中进行的； 然后会在 HTTP 请求的回调中交给模型层处理 JSON 数据； 返回开箱即用的对象交还给 Controller 控制器； 最后由 View 层展示服务端返回的数据； 不过按理来说服务层并不属于模型层，为什么要在这里进行介绍呢？这是因为 Service 层其实与 Model 层之间的联系非常紧密；网络请求返回的结果决定了 Model 层该如何设计以及该有哪些功能模块，而 Service 层的设计是与后端的 API 接口的设计强关联的，这也是我们谈模型层的设计无法绕过的坑。 iOS 中的 Service 层大体上有两种常见的组织方式，其中一种是命令式的，另一种是声明式的。 命令式 命令式的 Service 层一般都会为每一个或者一组 API 写一个专门用于 HTTP 请求的 Manager 类，在这个类中，我们会在每一个静态方法中使用 AFNetworking 或者 Alamofire 等网络框架发出 HTTP 请求。 123456789101112131415161718192021222324252627import Foundationimport Alamofirefinal class UserManager { static let baseURL = &quot;http://localhost:3000&quot; static let usersBaseURL = &quot;\\(baseURL)/users&quot; static func allUsers(completion: @escaping ([User]) -&gt; ()) { let url = &quot;\\(usersBaseURL)&quot; Alamofire.request(url).responseJSON { response in if let jsons = response.result.value as? [[String: Any]] { let users = User.users(jsons: jsons) completion(users) } } } static func user(id: Int, completion: @escaping (User) -&gt; ()) { let url = &quot;\\(usersBaseURL)/\\(id)&quot; Alamofire.request(url).responseJSON { response in if let json = response.result.value as? [String: Any], let user = User(json: json) { completion(user) } } }} 在这个方法中，我们完成了网络请求、数据转换 JSON、JSON 转换到模型以及最终使用 completion 回调的过程，调用 Service 服务的 Controller 可以直接从回调中使用构建好的 Model 对象。 123456UserManager.user(id: 1) { user in self.nameLabel.text = user.name self.emailLabel.text = user.email self.ageLabel.text = &quot;\\(user.age)&quot; self.genderLabel.text = user.gender.rawValue} 声明式 使用声明式的网络服务层与命令式的方法并没有本质的不同，它们最终都调用了底层的一些网络库的 API，这种网络服务层中的请求都是以配置的形式实现的，需要对原有的命令式的请求进行一层封装，也就是说所有的参数 requestURL、method 和 parameters 都应该以配置的形式声明在每一个 Request 类中。 如果是在 Objective-C 中，一般会定义一个抽象的基类，并让所有的 Request 都继承它；但是在 Swift 中，我们可以使用协议以及协议扩展的方式实现这一功能。 123456789101112131415protocol AbstractRequest { var requestURL: String { get } var method: HTTPMethod { get } var parameters: Parameters? { get }}extension AbstractRequest { func start(completion: @escaping (Any) -&gt; Void) { Alamofire.request(requestURL, method: self.method).responseJSON { response in if let json = response.result.value { completion(json) } } }} 在 AbstractRequest 协议中，我们定义了发出一个请求所需要的全部参数，并在协议扩展中实现了 start(completion:) 方法，这样实现该协议的类都可以直接调用 start(completion:) 发出网络请求。 12345678910111213141516final class AllUsersRequest: AbstractRequest { let requestURL = &quot;http://localhost:3000/users&quot; let method = HTTPMethod.get let parameters: Parameters? = nil}final class FindUserRequest: AbstractRequest { let requestURL: String let method = HTTPMethod.get let parameters: Parameters? = nil init(id: Int) { self.requestURL = &quot;http://localhost:3000/users/\\(id)&quot; }} 我们在这里写了两个简单的 Request 类 AllUsersRequest 和 FindUserRequest，它们两个一个负责获取所有的 User 对象，一个负责从服务端获取指定的 User；在使用上面的声明式 Service 层时也与命令式有一些不同： 123456FindUserRequest(id: 1).start { json in if let json = json as? [String: Any], let user = User(json: json) { print(user) }} 因为在 Swift 中，我们没法将 JSON 在 Service 层转换成模型对象，所以我们不得不在 FindUserRequest 的回调中进行类型以及 JSON 转模型等过程；又因为 HTTP 请求可能依赖其他的参数，所以在使用这种形式请求资源时，我们需要在初始化方法传入参数。 命令式 vs 声明式 现有的 iOS 开发中的网络服务层一般都是使用这两种组织方式，我们一般会按照资源或者功能来划分命令式中的 Manager 类，而声明式的 Request 类与实际请求是一对一的关系。 这两种网络层的组织方法在笔者看来没有高下之分，无论是 Manager 还是 Request 的方式，尤其是后者由于一个类只对应一个 API 请求，在整个 iOS 项目变得异常复杂时，就会导致网络层类的数量剧增。 这个问题并不是不可以接受的，在大多数项目中的网络请求就是这么做的，虽然在查找实际的请求类时有一些麻烦，不过只要遵循一定的命名规范还是可以解决的。 小结 现有的 MVC 下的 Model 层，其实只起到了对数据结构定义的作用，它将服务端返回的 JSON 数据，以更方便使用的方式包装了一下，这样呈现给上层的就是一些即拆即用的『字典』。 单独的 Model 层并不能返回什么关键的作用，它只有与网络服务层 Service 结合在一起的时候才能发挥更重要的能力。 而网络服务 Service 层是对 HTTP 请求的封装，其实现形式有两种，一种是命令式的，另一种是声明式的，这两种实现的方法并没有绝对的优劣，遵循合适的形式设计或者重构现有的架构，随着应用的开发与迭代，为上层提供相同的接口，保持一致性才是设计 Service 层最重要的事情。 服务端的 Model 层 虽然文章是对客户端中 Model 层进行分析和介绍，但是在客户端大规模使用 MVC 架构模式之前，服务端对于 MVC 的使用早已有多年的历史，而移动端以及 Web 前端对于架构的设计是近年来才逐渐被重视。 因为客户端的应用变得越来越复杂，动辄上百万行代码的巨型应用不断出现，以前流水线式的开发已经没有办法解决现在的开发、维护工作，所以合理的架构设计成为客户端应用必须要重视的事情。 这一节会以 Ruby on Rails 中 Model 层的设计为例，分析在经典的 MVC 框架中的 Model 层是如何与其他模块进行交互的，同时它又担任了什么样的职责。 Model 层的职责 Rails 中的 Model 层主要承担着以下两大职责： 使用数据库存储并管理 Web 应用的数据； 包含 Web 应用所有的业务逻辑； 除了上述两大职责之外，Model 层还会存储应用的状态，同时，由于它对用户界面一无所知，所以它不依赖于任何视图的状态，这也使得 Model 层的代码可以复用。 Model 层的两大职责决定了它在整个 MVC 框架的位置： 因为 Model 是对数据库中表的映射，所以当 Controller 向 Model 层请求数据时，它会从数据库中获取相应的数据，然后对数据进行加工最后返回给 Controller 层。","link":"/source/back/MCV_MVVM_MVP.html"},{"title":"Metal 编程指南","text":"Metal Programming Guide Command organization and execution model (指令组织和执行模型) 在 Metal 框架中, MTLDevice 协议定义的接口描述了一个 GPU, 该协议提供了一系列方法可以查询设备属性, 创建设备相关对象(缓存和纹理) command queue 包含了一系列的 command buffers, command queue 用于管理其中的 command buffers 的执行顺序. command buffer 包含了多个被编码的指令, 这些指令在一个特定设备上运行. command encoder 可以将绘制, 计算, 位图传输指令放到一个 command buffer 中 command buffers 最终被提交到设备中去执行. MTLCommandQueue 协议为 command queue 定义了接口, 主要是创建 command buffer 对象的方法. MTLCommandBuffer 协议 为 command queue 定义了接口, 提供了创建 command encoder, 入队列执行, 检测状态以及其他操作. 该协议定义了几种 command encoder 的类型, 他们可以被用于将不同的 GPU 任务编码到 command buffer 中执行. MTLRenderCommandEncoder 协议 - 将图形渲染指令编码为一次渲染过程. MTLComputeCommandEncoder 协议 - 编码并行计算任务 MTLBlitCommandEncoder 协议 - 在缓存和纹理之间的拷贝以及 mipmap 的生成. 任一时刻, 只有一个 Encoder 是处于激活状态的, 他可以向一个 command buffer 提交 command. 对于同一个 command buffer 来说,必须是前一个 encoder 结束后, 新的 encoder 才可以被创建并且用于此 command buffer(MTLParallelRenderCommandEncoder 例外). 一点所有的指令编码结束, MTLCommandBuffer 对象自己就会提交,并且会被标记为准备执行状态. MTLCommandQueue 协议可以用来控制这些要被执行的 MTLCommandBuffer 对象. 一个 MTLDevice 对象代表了一个可以执行 command 的 GPU. MTLDevice 协议有创建新的 command queue , 从内存创建缓存, 创建纹理, 查询设备能力的方法. 使用 MTLCreateSystemDefaultDevice 来创建首选设备. 创建: command buffers 和 command encoder 基本不耗费什么系统资源. Command queue &amp; buffer &amp; texture &amp; sample state libraries &amp; compute state &amp; render pipeline state &amp; depth/stencil state, 这些对象系统鼓励重用. Command Queue command queue 接受的是: 有序的 command buffer(将要在 GPU 中执行) 列表. 在 command queue 中的 command buffers 会被确保按顺序执行. command queue 是线程安全的. MTLDevice 中有两个方法可以创建 command queue newCommandQueue newCommandQueueWithMaxCommandBufferCount 不要没事销毁和创建 commandQueue, 记得复用. Command buffer command buffer 在被 GPU 执行之前会包含多个被编码的 command, 不支持重用, 能做的就是提交执行后, 检查状态 他还是 app 中独立可以被追踪的任务单元. 创建 command buffer MTLCommandQueue 中定义了创建 commandBuffer 的方法. 一个 MTLCommandQueue 对象只能提交给创建他的 MTLCommandQueue. commandBuffers创建的 command buffer 对象持有他执行时需要的数据. 在特定场景下, 你需要的资源已经被持有了, 可以使用commandBufferWithUnretainedReferences方法.(该方法只有在极端需要性能 app 中, 并且能够保证在 command 执行完之前资源都保持存活的情况下才使用) Executing Command MTLCommandBuffer 协议中有下列的方法可以设定在 command queue 中的执行顺序. 一个 command buffer 一定要先提交然后在执行. enqueue 方法可以为一个 command buffer 在 command queue 中预定一个位置.但是并没有把 command buffer 提交执行.当这个 command buffer 最终提交的时候, 他会在之前做 enqueue 操作的 command buffer 之后执行. commit 方法会使 command buffer 尽快的被执行.但必须是等到之前 enqueue 的 command buffer 执行后. commit 会隐式的调用 enqueue. Registering Handler Blocks for Command Buffer Execution addScheduledHandler, 当 command buffer 被 schedule 的时候调用. waitUntilScheduled, 该方法同步的等待, 当 command buffer 被完全执行完或者其所有注册 addScheduledhandler 都结束的时候返回. addCompleteHandler, 当设备执行完 command buffer 的时候调用. waitUntilCompleted, 该方法同步的等待, 当设备执行完 command buffer并且所有注册 addCompleteHandler 都返回的时候. presentDrawable:, 便捷函数:在command buffer 被 schedule 的时候, 能够将可显示的资源(CAMetalDrawable 对象)展示出来 status, read-only 属性. command buffer 是在生命周期的哪个阶段. error, 如果没有异常,为 nil. 如果有错误, 可以看看 command buffer error codes. Command Encoder 1.Encoder 是一个一次性的 transient 的对象, 在激活状态的时候可以他就可以把一个 command 追加到 command buffer 中. 使用 endEncoding 来结束编码 command. 还想要编码 command, 只能在新建一个 encoder. Creating a Command Encoding Object renderCommandEncoderWithDescriptor, 创建一个 MTLRenderCommandEncoder 类型的 encoder 用来在TMLRenderPassDescriptor中做图形渲染. computeCommandEncoder, 创建一个 MTLComputeCommandEncoder 类型的 encoder 用来做并行计算. blitCommandEncoder, 创建了一个 MTLBlitCommandEncoder 类型的 encoder 用来做内存操作. parallelRenderCommandEncoderWithDescriptor, 创建了一个MTLParallelRenderCommandEncoder 类型的 encoder, 用来让多个 MTLRenderCommandEncoder 对象在不同的线程工作,并且保证渲染到同一个 attachment(共享的MTLRenderPassDescriptor) 中. Render Command Encoder 该 encoder 需要关联一个MTLRenderPassDescriptor对象，在这个descriptor对象中包含了颜色 、景深、模板attachment，这些attachment将被当做绘制命令的目标， 该 Encoder 有如下能力: 指定图形资源, 如缓存和纹理对象。 指定 MTLRenderPipelineState对象(包含 compiled rendering state 以及顶点和片段着色器) 指定 fixed-function 状态, 包括 viewport, 更多可以看 MTLRenderCommandEncoder 协议 Compute Command Encoder 参见 MTLComputeCommandEncoder 协议 Blit Command Encoder MTLBlitCommandEncoder 协议可以追加一个 command 用来做 MTLBuffer 和 MTLTexture 之前的内存拷贝操作. 还可以用固定颜色填充纹理生成一个 mipmaps Multiple Thread, Command Buffers, Command Encoder 大多数程序使用单一的线程来encoder 绘制指令到一个 command buffer 来绘制一帧画面.在每一帧结束的时候, 提交 command buffer, 这样就可以 shcedule 并且 开始 command 的执行. 如果需要并行的为 command buffer 编码, 这样就需要在同时创建多个command buffer, 在不同的线程 encoder 每一个 command buffer. 如果提前知道 command buffer 的执行顺序, 就可以按顺序 enqueue 每个 command buffer, 就不用等待执行编码和提交. Resource Objects: Buffers and Textures MTLBuffer 表示一块非格式化的内存可以存放任何类型的数据.通常用来存放顶点, 着色器, 计算状态数据. MTLTexture 表示一块有格式的图像数据, 有特定的纹理类型 &amp; 像素格式 MTLSampleState 用于纹理对象的查找计算. Buffers are Typeless Allocations of Memory 一个 MTLBuffer 表示了一段内存区域,他可以存放任何数据类型. Creating a Buffer Object 下面的 MTLDevice 方法创建并返回一个 MTLBuffer 对象 newBufferWithLenth:Options: 分配内存创建一个 MTLBuffer 对象 newBufferWithBytes:length:options: 通过从已有的存储器中拷贝到新分配的内存中 newBufferWithBytesNoCopy:length:options:deallocator: 该方法创建一个 MTLBuffer 对象，但不会为这个对象新分配内存，而是使用已经存在的内存。","link":"/source/back/Metal%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97.html"},{"title":"Selector 是什么","text":"selector 到底是什么 1234567891011static SEL sel_alloc(const char *name, bool copy){ selLock.assertWriting(); return (SEL)(copy ? strdup(name) : name); }const char *sel_getName(SEL sel) { if (!sel) return &quot;&lt;null selector&gt;&quot;; return (const char *)(const void*)sel;} 从 sel_alloc 可以看出来，SEL 就是直接使用当前的字符串，或者把当前的字符串拷贝一份，然后char * 强转为 SEL. 从 sel_getName 可以看出，SEL 类型可以强转为 char * 也就是说 SEL 就是字符串，那么@selector(XXX)\u0010就是字符串 XXX。然后从 class 里面取方法就是拿这个字符串跟 class 里面的 methodList 里面取 method 的 name（也就是 SEL）作对比，如果相等，就取到了。","link":"/source/back/Selector%E6%98%AF%E4%BB%80%E4%B9%88.html"},{"title":"Block学习","text":"#iOS Block 概要 ##1.Block 的种类 block 常见的类型有三种: __NSGlobalBlock__（全局）, __NSStackBlock__（栈）, __NSMallocBlock（堆）。 1234567891011121314int main(int argc, const char *argv[]){ @autorelease{ int i = 10; //ARC 情况下 ^{i;}; //创建 block 的时候都是在 `栈` 中 --&gt; StackBlock void (^block) = ^{i;}; //block为 strong 类型，并且捕获了外部变量，所以赋值的时候，自动进行了 copy -&gt; MallocBlock __weak void (^weakBlock) = ^{i;};\u0010 //如果是 weak 类型的 block，不会自动进行 copy -&gt; StackBlock void (^stackBlock) = ^{}; //如果 block 是 strong 类型，并且没有捕获外部变量、或者用到全局变量，静态变量，那么就会被转换成 GlobalStack. } } 综上所述：我们可以得到如下的结论：ARC 下 1.block 没有捕获外部变量，或者用到全局变量、静态变量，则为 __NSGlobalBlock__ 2.block 用到自动变量且用正常变量来接受这个 block，则是 MallocBlock 3.block 用到自动变量或者用 weak 变量来接受 block，则是 StackBlock 备注： 1.block 用到自动变量初创之时都是 StackBlock 类型，在 ARC 环境下赋值给正常变量时，系统会将 block 拷贝到堆上，StackBlock 变成了 MallocBlock 2.在 MRC 下，赋值给正常变量时，系统不会自动的将 block 拷贝到堆上。 ###2.Block 内外关系 123456static int a;//全局或者局部变量都一样- (void)test{ ^{ a; }} //不向 block 内传递任何东西，（\u0010全局或者局部变量作用域广，任何时候用到变量 a 都是同一个变量，block 用到的变量 a 也是同一个） 123456- (void)test{ static int a; ^{ a = 10; }} //向 block 内传递地址（局部静态变量作用域有限，block 记录了局部静态变量的地址，确保了 block 内外用到的变量 a 是同一个） 123456- (void)test{ int a; ^{ a; }} // 向 block 内传递 123456- (void)test{ __block int a; ^{ a = 10; }} //向 block 内传递构造的结构体 __Block_byref 综上所述：__block 修饰的基础类型和对象类型都会构造__Block_byref结构体再传递。 构造__Block_byref结构体在传递的方式会很复杂。 ###3.梳理 在 ARC 环境下， __NSGlobalBlock__ 几乎不出现，使用起来没什么需要注意。 __NSStackBlock__ 几乎不出现， 但他是 __NSMallocBlock__ 的前身。 __NSMallocBlock__ 比较重要 看得懂编译是一切的前提 ##1.看懂编译 编译选项：clang --rewrite-objc ### A.不带参数 123456int main(int argc, const char *argv[]){ @autorelease{ ^{} } return 0;} 编译结果： 12345678910111213141516171819202122232425262728293031323334353637struct __block_impl{ void *isa; int Flags; int Reverse; void *FuncPtr;};struct __main_block_impl_0{ struct __block_impl impl; struct __main_block_desc_0 *Desc; __main_block_desc_0(void *fp, struct __main_block_desc_0 *desc, int flags = 0){ impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct _main_block_impl_0 *__cself){}static struct _main_block_func_0{ size_t reserved; size_t Block_size;}__main_block_desc_0_DATA = {0, sizeof(struct __main_block_impl_0);}int main(int argc, const char* argv[]){ void(*test)()=( (void (*))&amp;__main_block_impl_0( (void *)__main_block_func_9, &amp;__main_block_desc_0_DATA) ); ); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr((__block_impl *)test); return 0;} __main_block_impl_0 就是 block 的一个 C++的实现，0 表示第几个block，其实就是一个结构体。 __block_impl 结构体中 1. isa指向所属类，就是 block 的类型。 2. flags，标志变量，在 block 内部操作中会用到。 3. Reserved，是保留变量。 4. FuncPtr，block 执行时调用的函数指针，它包含了 isa 指针，其实 block 也是一个对象。 __main_block_desc_0 结构体中 1. Reserved，为保留字段 2. Block_size 为 block 的大小，也就是sizeof(struct __main_block_impl_0) 在上面的代码中，定义__main_block_desc_0结构体时，同时创建了__main_block_desc_0_DATA，并给它赋值，以供main函数中对__main_block_0进行初始化。 __main_block_impl_0 的isa指向了__NSConcreteStackBlock 从main函数中看，__main_block_impl_0的FuncPtr指向了函数__main_block_func_0 __main_block_impl_0的Desc也指向了定义的__main_block_desc_0时就创建的__main_block_desc_0_DATA，其中记录了 block 结构体大小等信息。 ##2.Block 实际结构 在Block_private.h 中定义了对 block 的相关结构体的真实定义 1234567891011121314struct Block_descriptor{ unsigned long int reserved; unsigned long int size; void (*copy)(void *dst, void *src); void (*dispose)(void *)}struct Block_layout{ void *isa; int flags; int reserved; void (* invoke)(void *,...); struct Block_descriptor *descriptor;} invoke ,相当于上文中的 FuncPtr, block 执行时调用的函数指针，block 定义时内部的执行代码都在这个函数中。 Block_descriptor，block 的详细描述 copy/dispose,辅助拷贝/销毁函数，处理 block 范围外的变量时使用。 结论： block 就是一个里面存储了指向函数体中包含定义 block 时代码块的函数指针，以及block 外部上下文等信息的结构体。 B. 基础类型 12345678int main(int argc, const char *argv[]){ int any = 1; void (^test)() = ^{ NSLog(@&quot;%d&quot;, any); }; test(); return 0;} 编译结果： 1234567891011121314151617181920212223242526272829303132333435struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;};struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; int any; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, int _any, int flags=0) : any(_any) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; } }; static void __main_block_func_0(struct __main_block_impl_0 *__cself){ int any = __cself-&gt;any; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_a_f8f541_mi_0, any); }static struct __main_block_desc_0 { size_t reserved; size_t Block_size;} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0)};int main (int argc, const char *argv[]){ int any = 1; void (*test)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, any)); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test); return 0;} ###C. 对象类型 12345678int main(int argc, const char *argv[]){ NSString *any = [NSString stringWithFormat:@&quot;1&quot;]\u0010; void (^test)() = ^{ NSLog(@&quot;%@&quot;, any); }; test(); return 0;} 编译结果： 123456789101112131415161718192021222324252627282930313233343536373839404142struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;};struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; NSString *any; __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, NSString *_any, int flags=0) : any(_any) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct __main_block_impl_0 *__cself) { NSString *any = __cself-&gt;any; // bound by copy NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_b_ca6e15_mi_2, any);}static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;any, (void*)src-&gt;any, 3/*BLOCK_FIELD_IS_OBJECT*/);}static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;any, 3/*BLOCK_FIELD_IS_OBJECT*/);}static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};int main (int argc, const char *argv[]){ NSString *any = ((NSString *(*)(id, SEL, NSString *, ...))(void *)objc_msgSend)((id)objc_getClass(&quot;NSString&quot;), sel_registerName(&quot;stringWithFormat:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_b_ca6e15_mi_0, (NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_b_ca6e15_mi_1); void (*test)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, any, 570425344)); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test); return 0;} ###D.__block 修饰基础类型 12345678int main(int argc, const char * argv[]) { __block int any = 1; void (^test)() = ^ { NSLog(@&quot;%d&quot;,any); }; test(); return 0;} 编译结果： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;};struct __Block_byref_any_0 { void *__isa;__Block_byref_any_0 *__forwarding; int __flags; int __size; int any;};struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_any_0 *any; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_any_0 *_any, int flags=0) : any(_any-&gt;__forwarding) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct __main_block_impl_0 *__cself) { __Block_byref_any_0 *any = __cself-&gt;any; // bound by ref NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_c_88a22a_mi_0, (any-&gt;__forwarding-&gt;any)); }static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;any, (void*)src-&gt;any, 8/*BLOCK_FIELD_IS_BYREF*/);}static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;any, 8/*BLOCK_FIELD_IS_BYREF*/);}static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};int main(int argc, const char *argv[]){ __attribute__((__blocks__(byref))) __Block_byref_any_0 any = {(void*)0,(__Block_byref_any_0 *)&amp;any, 0, sizeof(__Block_byref_any_0), 1}; void(*test)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_any_0 *)&amp;any, 570425344)); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test); return 0;} ###E. __block修饰对象类型 12345678int main(int argc, const char * argv[]) { __block NSString * any = [NSString stringWithFormat:@&quot;1&quot;]; void (^test)() = ^ { NSLog(@&quot;%@&quot;,any); }; test(); return 0;} 编译结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657struct __block_impl { void *isa; int Flags; int Reserved; void *FuncPtr;};static void __Block_byref_id_object_copy_131(void *dst, void *src) { _Block_object_assign((char*)dst + 40, *(void * *) ((char*)src + 40), 131);}static void __Block_byref_id_object_dispose_131(void *src) { _Block_object_dispose(*(void * *) ((char*)src + 40), 131);}struct __Block_byref_any_0 { void *__isa;__Block_byref_any_0 *__forwarding; int __flags; int __size; void (*__Block_byref_id_object_copy)(void*, void*); void (*__Block_byref_id_object_dispose)(void*); NSString *any;};struct __main_block_impl_0 { struct __block_impl impl; struct __main_block_desc_0* Desc; __Block_byref_any_0 *any; // by ref __main_block_impl_0(void *fp, struct __main_block_desc_0 *desc, __Block_byref_any_0 *_any, int flags=0) : any(_any-&gt;__forwarding) { impl.isa = &amp;_NSConcreteStackBlock; impl.Flags = flags; impl.FuncPtr = fp; Desc = desc; }};static void __main_block_func_0(struct __main_block_impl_0 *__cself) { __Block_byref_any_0 *any = __cself-&gt;any; // bound by ref NSLog((NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_d_a788e6_mi_1, (any-&gt;__forwarding-&gt;any)); }static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) {_Block_object_assign((void*)&amp;dst-&gt;any, (void*)src-&gt;any, 8/*BLOCK_FIELD_IS_BYREF*/);}static void __main_block_dispose_0(struct __main_block_impl_0*src) {_Block_object_dispose((void*)src-&gt;any, 8/*BLOCK_FIELD_IS_BYREF*/);}static struct __main_block_desc_0 { size_t reserved; size_t Block_size; void (*copy)(struct __main_block_impl_0*, struct __main_block_impl_0*); void (*dispose)(struct __main_block_impl_0*);} __main_block_desc_0_DATA = { 0, sizeof(struct __main_block_impl_0), __main_block_copy_0, __main_block_dispose_0};int main(int argc, const char *argv[]){ __attribute__((__blocks__(byref))) __Block_byref_any_0 any = {(void*)0,(__Block_byref_any_0 *)&amp;any, 33554432, sizeof(__Block_byref_any_0), __Block_byref_id_object_copy_131, __Block_byref_id_object_dispose_131, ((NSString *(*)(id, SEL, NSString *, ...))(void *)objc_msgSend)((id)objc_getClass(&quot;NSString&quot;), sel_registerName(&quot;stringWithFormat:&quot;), (NSString *)&amp;__NSConstantStringImpl__var_folders_n6__72n032j2fn1zsdjjvn88vrc0000gn_T_d_a788e6_mi_0)}; void (*test)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0, &amp;__main_block_desc_0_DATA, (__Block_byref_any_0 *)&amp;any, 570425344)); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test); return 0;} ##3. 结果分析 ###3.1 1. __main_block_func_0 为 block 具体实现函数 2. __main_block_desc_0 为 block 大小描述 + 拷贝函数 + 销毁函数 3. __main_block_impl_0 block 的一切都封装在内，包括前两个函数 + 捕获的参数。该结构体就是 block 在内存里的真实存在。 4. block 的调用((void (*)(__block_impl *)) ((__block_impl *)test) -&gt; FuncPtr)((__block_impl *)test); ###3.2 以 A 为例 block 的调用 12void (*test)() = ((void (*)())&amp;__main_block_impl_0((void *)__main_block_func_0,&amp;__main_block_desc_0_DATA)); ((void (*)(__block_impl *))((__block_impl *)test)-&gt;FuncPtr)((__block_impl *)test); 调用__main_block_impl_0结构体的构造函数，生成__main_block_impl_0结构体的实例，获取实例地址，将这个地址转成函数地址。 (void (*)(__block_impl *))读取地址，强转成函数 ((__block_impl *)test)之类对象转换成父类，这个地方 test 指针真正的指向对象__main_block_impl_0,是一个子类对象，但是__main_block_impl_0包含了__block_impl结构体，所以读取子类对象的父类对象大小，就能取到了父类对象 ###3.3 对象类型编译结果 1. 拷贝__main_block_impl_0 -&gt; __Block_byref_any 123static void __main_block_copy_0(struct __main_block_impl_0*dst, struct __main_block_impl_0*src) { _Block_object_assign((void*)&amp;dst-&gt;any, (void*)src-&gt;any, 3/*BLOCK_FIELD_IS_OBJECT*/);} 销毁 __main_block_impl_0 -&gt; __Block_byref_any 123static void __main_block_dispose_0(struct __main_block_impl_0*src) { _Block_object_dispose((void*)src-&gt;any, 3/*BLOCK_FIELD_IS_OBJECT*/);} ###3.4 __block修饰编译结果有的","link":"/source/back/block%E5%AD%A6%E4%B9%A0.html"},{"title":"iOS 内存管理","text":"iOS 内存管理和 malloc 源代码解读 iOS 内存基本管理 在接触 iOS 开发的时候，我们知道引用计数器的概念，也知道 ARC 和 MRC，但其实这仅仅是对堆内存上对象的内存管理。 在内存管理方面，其实 iOS 和其他操作系统总体上来说是大同小异的，大的框架原理基本相似，小的细节有所创新和不同。 和其他操作系统上运行的进程类似，iOS App 进程的地址空间也分为代码区、数据区、栈区和堆区。进程开始时，会把 mach-o 文件中的各部分，按需加载到内存中。 对于一般的 iPhone 来说，实际物理内存都在1GB 左右，对于超大的内存需求，也和一般的操作系统一样，都由系统内核维护一套虚拟内存系统。但这里需要注意的是 iOS 的虚拟系统原则略有不同，最截然不同的地方就是当物理内存内存紧张情况时得处理。 当物理内存紧张时，iOS 会把可以通过重新映射来加载的内存直接清理出内存，对于不可再生的数据，iOS 需要 App 进程配合处理，由各进程发送内存警告要求配合释放内存。对于不能及时释放足够内存的，直接 kill 掉进程，必要时甚至是前台运行的 app。。 所以，iOS 在外存没有交换区，没有内存页换出的过程。 malloc 基本原理 在 iOS APP 进程地址空间各个区域中，最灵活的就要属堆区，它为进程动态分配内存，也是我们经常和内存打交道的地方。 通常，我们会在需要新对象的时候，进行[NSObject alloc]调用，而释放对象时需要 release（ARC 会自动帮你做到这些）。 而这些 alloc、release 方法的调用，最终会走到 libsystem_malloc.dylib 的 malloc() 和 free() 函数这里。libsystem_malloc.dylib 是 iOS 内核之外的一个内存库，我们 app 进程需要的内存，先会请求到这里，但最终libsystem_malloc.dylib也都会向 iOS 的系统内核发起申请，映射实际内存到 app 进程的地址空间。 从苹果公开的 malloc 的源代码上看，原理大概如此： malloc 内存分配基于 malloc zone，并将内存分配按大小分为 nano、tiny、small、large 几种类型。申请时按需进行最适分配。 malloc 在首次调用时，初始化 default zone，在 64 位情况下，会初始化 default zone 为 nano zone。同事初始化一个 scalable zone 作为 helper zone，nano zone 负责 nano 大小的分配，scalable zone 负责 tiny、small 和 large 内存的分配。每次 malloc 时，根据传入的 size 参数，优先交个 nano zone 做分配处理，如果大小不在 nano 范围，则转交给 helper zone 处理。 nano malloc 在支持64位的条件下，malloc 优先考虑 nano malloc，负责对 256B 以下小内存分配，单位是16B。 nano zone 分配内存的地址空间范围是 0x00006nnnnnnnnnnn （OSX 64位情况），将地址空间从大到小一次分为 magazine、band、slot 几个级别 magazine 范围对应于 CPU，CPU0 对应 Mag0、CPU1 对应 Mag1，以此类推； Band 范围为 2M，连续分配内存当内存不够时以 Band 为单位向内核请求。 Slot 则对应每个 Band 中 128K 大小的范围，每个 Band 都分为 16个 Slot，分别对应于 16B、32B、.... 256B大小，支持他们的内存分配。 分配过程 确定当前 CPU 对应的 mag 和通过 size 参数计算出来的 slot，去对应的 metadata 的链表中取已经被释放过得内存区块缓存。判断渠道检查指针地址是否有问题，没有问题就直接返回。 初次进行 nano malloc 时，nano zone 并没有缓存，会直接在 nano zone 范围的地址空间上直接分配连续地址内存。 如当前 band 中当前 slot 耗尽，则向系统申请新的 band （每个 band 固定大小2M，容纳了16个128K 的槽），连续地址分配内存的基地址、limit 地址以及当前分配到的地址由 meta data 结构维护起来，而这些 meta data 则以 mag、slot 为维度（mag 个数是处理器个数，slot 是16个）的二维数组形式，放在 nanozone_t 的 meta_data字段中。 当 app 通过 free() 释放内存时：malloc 库会检查指针地址，如果没有问题，则以链表形式将这些区块按大小存储起来。这些链表的头部放在 meta_data 数组中对应的 [mag][slot] 元素中。 其实从缓存获取空余内存和释放内存时都会对指向这片内存区域的指针进行检查，如果有类似地址不对齐、未释放、多次释放、所属地址与预期的 mag、slot 不匹配等情况都会以报错结束。 除了分配和释放、系统内存吃紧时，nano zone 需将 cache 的内存区块还给系统，这主要是通过对各个 slot 对应的 meta data 上挂着空闲的链表上内存区块回收来完成。 scalable zone 上内存分配简要分析 对于超出 nano 大小范围或者不支持 nano 分配的，直接会在 scalable zone 上分配。由于 scalable zone 上的内存分配比 nano 分配要复杂。下面只做简单介绍。 scalable zone 上分配的内存包括 tiny、small、large 三大类。其中 tiny 和 small 的分配、释放过程大致相同，large 类型有自己的方式管理。 而 tiny、small 的方式也遵循着 nano 分配中的原则，新内存从系统申请并分配，free 后按照大小以特定的形式缓存起来，供后续分配使用。这里的分配在 region 上进行，region 和 nano malloc 里的 band 概念即为相似，但不同的是地址空间未必连续，而且每个 region 都有自己的位图等描述信息。和 nano 一样每个 CPU 都有一个 magazine，除此之外还分配了一个 index 为 -1 的 magazine 作为后备之用。 以 tiny 的情况为例， 分配时： 确定当前线程所在处理器的 magazine index，找到对应的 magazine 结构。 优先查看上次最后释放的区块是否和此次请求的大小刚好相等（都是对齐后的 slot 大小），如果是则直接返回。 如果不是，则查找 free list 中当前请求大小区块的空闲缓存列表，如果有返回，并整理列表。 如果没有，则在 free list 找比当前申请区块大的，而且最接近的缓存，如果有返回，并把剩余大小放到 free list 中另外的链表上。（这里需要注意的是，在一般情况下，free list 分为64个槽，0-62 上挂载区块的大小都是按 16B 为单位递增，63为所有更大的内存区块挂载的地方） 上面几项都不行，就在最后一个 region 的尾部或者首部（如果支持 ALSR）找空闲区域分配。 如果还是不行，说明所有现有 region 都没有可用空间了，那么从一个后备 magazine 中取出一个可用 region，完整地拿过来放到当前 magazine，再走一遍上面的步骤。 如果这都不行，那只能向内核申请一块新的 region 区域，挂载到当前的 magazine 下并分配内存。 如果还是不行，那就没招了，系统也给不到内存，就返回报错。 free 时 检查指针指向的地址是否有问题。 如果 last free 指针上没有挂载内存区块，则当道 last free 上就 OK 了。 如果有 last free，置换内存，并把 last free 原有内存区块挂载到 free list 上。（在挂载的 free list 前，会根据 region 位图检查前后区块是否能合并成为更大的区块，如果能会合并成一个） 合并后所在的 region 如果空闲字节超过一定条件，则把 region 放到后备的 magazine 中（-1）。 如果整个 region 都是空的，则直接还给系统内核，一了百了。 而 large 的情况，malloc 以页为单位申请和分配内存，不区分 magazine，scalable zone 同意维护一个 hash table 管理已申请的内存。而且由于内存区域都比较庞大，置换村总量2G 的区块，氛围16个元素，每个最大为128M。large 相关的结构相对简单。 苹果 malloc 代码：","link":"/source/back/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86.html"},{"title":"iOS 静态库转动态库","text":"iOS 静态库转动态库的方法 问题 由于二级制 __TEXT 段 60M 的上限问题，支付宝钱包也将个别的 SDK 转换成动态库。 在实际抓换的过程中，由于源代码保密的问题，第三方只能提供二级制的静态库，不能提供源代码。因为我们只能把静态库直接转成动态库 抓换方法 转换方法是基于动态库本身编译和链接的特点：在链接时会把依赖的静态库 symbol 复制到本库 步骤示意图：（S1 表示静态库，D1 表示动态库） 举例说明：将不依赖其他的静态库的静态库 AMapFoundationKit.framework 转换成动态库 AMapFoundationKit.framework 步骤一 可以从Xcode原生的动态库模版一个空的动态库，与静态库名称相同，即AMapFoundationKit。 步骤二 ####2.1 设置Framework搜索路径，在AMapFoundationKit -&gt; Build Settings -&gt; FRAMEWORK_SEARCH_PATHS设置成静态库的路径 2.2 将静态库拖到AMapFoundationKit -&gt; Build Phases -&gt; Link Binary With Libraries 2.3 2.3 将静态库Headers中的所有头文件拖到AMapFoundationKit -&gt; Build Phases -&gt; Headers -&gt; Public，不用Copy文件。同时删除模版生成的AMapFoundationKit.h。 2.4 将静态库中的所有资源拖到AMapFoundationKit -&gt; Build Phases -&gt; Copy Bundle Resources 2.5 定义Link时load all symbols，将AMapFoundationKit -&gt; Build Settings -&gt; OTHER_LDFLAGS中添加-all_load 2.6 关闭Version System，AMapFoundationKit -&gt; Build Settings -&gt; VERSIONING_SYSTEM设置为None 2.7 创建触发编译的空文件（不用写任何函数），因为无编译文件将不会生成macho文件。 2.8 将静态库framework的所有系统库的依赖添加进来，可根据编译时symbol未找到symbol报错，依次添加到AMapFoundationKit -&gt; Build Phases -&gt; Link Binary With Libraries 步骤三 执行编译 步骤四 获取编译后的产物，即动态库AMapFoundationKit.framework","link":"/source/back/iOS%E9%9D%99%E6%80%81%E5%BA%93%E8%BD%AC%E5%8A%A8%E6%80%81%E5%BA%93.html"},{"title":"IMP是什么","text":"IMP 到底是什么 IMP 的定义可以再 objc.h 中找到 12typedef void (*IMP)(void /* id, SEL, ... */ ); typedef void (*IMP)(void); 其实就是参数为空，返回值为空的函数指针。 #1 IMP 能直接调用么 定义一个类： 1234567891011@interface TestClass : NSObject@end@implementation TestClass- (id)test:(NSInteger)arg { return nil;}@end 获取 IMP 并调用： 123456int main(int argc, char * argv[]) { IMP testIMP = class_getMethodImplementation([TestClass class], @selector(test:)); testIMP(); return 1;} #2 IMP 的返回值和参数怎么定？ 不对劲吧，参数没有传。怎么判断一个方法的具体参数呢： 1Method testMethod = class_getInstanceMethod([TestClass class], @selector(test:)); 而 Method 是： 12345struct objc_method { SEL method_name OBJC2_UNAVAILABLE; char *method_types OBJC2_UNAVAILABLE; IMP method_imp OBJC2_UNAVAILABLE;} 从调试窗口看到的： method_types是@24@0:8q16 [4], 内容都是一个字符跟一个数字成对出现, 第一对表示返回值和参数长度(其中@表示返回值为id, 24表示参数长度为24字节),后面三对代表三个参数(@0表示参数是id而参数的偏移为0, :8表示参数是selector偏移为8,q16表示参数为long long偏移为16), 完整的type encoding参见参考. 也就意味着test:方法的IMP的类型应该是id (*IMP)(id, SEL, long long), 其中参数的第一个id是self, 第二个SEL是当前IMP对应的selector, 第三个long long就是test:的arg参数. 更详细的介绍见参考.","link":"/source/back/imp%E6%98%AF%E4%BB%80%E4%B9%88.html"},{"title":"依赖注入","text":"iOS 依赖注入（DI） 依赖注入DI: Dependency Injection是控制反转IoC: Inversion of Control的实现方式之一，另外一种是依赖查找DL: Dependency Lookup 什么是依赖注入(Dependency injection) 在StackOverflow上有个问题：如何向一个5岁的小孩解释依赖注入 “When you go and get things out of the refrigerator for yourself, you can cause problems. You might leave the door open, you might get something Mommy or Daddy doesn’t want you to have. You might even be looking for something we don’t even have or which has expired. What you should be doing is stating a need, “I need something to drink with lunch,” and then we will make sure you have something when you sit down to eat.” 映射到面向对象开发中的就是：高层类（5岁小孩）应该依赖底层基础设施（家长）来提供必要的服务。 依赖倒置解决了高层次模块依赖于低层次模块和细节的问题 Dependency Injection是一个将行为从依赖中分离的技术。允许开发者定义一个方法函数依赖于外部其他各种交互，而不需要编码如何获得这些外部交互的实例。这样就在各种组件之间解耦，从而获得干净的代码，相比依赖的硬编码，一个组建只有在运行时才调用其所需要的其他组件，因此在代码运行时，通过特定的框架和容器，将其所需要的其他依赖组件进行注入，主动推入。 依赖注入可以看成是控制反转（inversion of control）的一个特例。反转的是依赖，而不是其他。“Inversion of Control Containers and the Dependency Injection pattern” 依赖注入与IOC模式类似于工厂模式，是一种解决调用者和被调用者依赖耦合关系的模式。他解决了对象之间的依赖关系，使得对象只依赖于IOC/DI 容器，实现松散耦合，然后在对象创建时，由IOC/DI容器将其依赖的对象注入其内部。 DI 解决的问题 所有的对象都必须创建；或者说：使用对象之前必须创建，但是现在我们可以不必一定遵循这个定律了，我们可以从DI容器中直接获得一个对象然后直接使用，无需事先创建它们。 依赖注入 参考文章：依赖注入 1234567891011121314- (NSNumber *)nextReminderId{ NSNumber *currentReminderId = [[NSUserDefaults standardUserDefaults] objectForKey:@&quot;currentReminderId&quot;]; if (currentReminderId) { // 增加前一个 reminderId currentReminderId = @([currentReminderId intValue] + 1); } else { // 如果还没有，设为 0 currentReminderId = @0; } // 将 currentReminderId 更新到 model 中 [[NSUserDefaults standardUserDefaults] setObject:currentReminderId forKey:@&quot;currentReminderId&quot;]; return currentReminderId;} 构造器注入 构造器注入，即将某个依赖对象传入到构造器中 (在 Objective- C中指 designated 初始化方法) 并存储起来，以便在后续过程中使用： 1234567891011121314@interface Example ()@property (nonatomic, strong, readonly) NSUserDefaults *userDefaults;@end@implementation Example- (instancetype)initWithUserDefaults:(NSUserDefaults *userDefaults){ self = [super init]; if (self) { _userDefaults = userDefaults; } return self;}@end 1234567891011- (NSNumber *)nextReminderId{ NSNumber *currentReminderId = [self.userDefaults objectForKey:@&quot;currentReminderId&quot;]; if (currentReminderId) { currentReminderId = @([currentReminderId intValue] + 1); } else { currentReminderId = @0; } [self.userDefaults setObject:currentReminderId forKey:@&quot;currentReminderId&quot;]; return currentReminderId;} 属性注入 对于属性注入，nextReminderId 的代码看起来和 self.userDefaults 的做法是一致的。只是这次不是将依赖对象传递给初始化方法，而是采用属性赋值方式 1234@interface Example@property (nonatomic, strong) NSUserDefaults *userDefaults;- (NSNumber *)nextReminderId;@end 方法注入 如果依赖对象只在某一个方法中被使用，则可以利用方法参数做注入： 1234567891011- (NSNumber *)nextReminderIdWithUserDefaults:(NSUserDefaults *)userDefaults{ NSNumber *currentReminderId = [userDefaults objectForKey:@&quot;currentReminderId&quot;]; if (currentReminderId) { currentReminderId = @([currentReminderId intValue] + 1); } else { currentReminderId = @0; } [userDefaults setObject:currentReminderId forKey:@&quot;currentReminderId&quot;]; return currentReminderId;} Demo Demo场景 Demo 中使用依赖注入的方式来为不同的 BioAuthDemoObject 提供不同的对象属性。 Demo结构 基类有相同的方法，只有在运行的时候，才会调用传入的实现 #参考 Dependency Injection, iOS and You 关于IOS依赖注入(DI)那些事 依赖注入 iOS控制反转(IoC)与依赖注入(DI)的实现 objection typhoon Objection 与 Typhoon 的协议绑定对比","link":"/source/back/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5.html"},{"title":"如何分析Crash日志","text":"iOS Crash Log 解析 #1 简介 Crash Log 是用来分析 Crash 问题的主要手段。 #2 示例 下面的 Crash Log 取自于天猫客户端，Log 中不重要的部分已经被略去： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354Incident Identifier: C7F427F7-FDF8-41C3-9659-3C54756B1547CrashReporter Key: TODOHardware Model: iPhone8,2Process: Tmall4iPhone [1313]Path: /var/containers/Bundle/Application/5F09E0C7-C766-42D8-B2C7-31E335F73349/Tmall4iPhone.app/Tmall4iPhoneIdentifier: Unknown|com.taobao.tmallVersion: 5.24.1 (5.24.1)Code Type: ARM-64Parent Process: ??? [1]Date/Time: 2016-10-07 03:16:35 +0000OS Version: iPhone OS 10.0.1 (14A403)Report Version: 104Exception Type: SIGSEGVException Codes: SEGV_ACCERR at 0x110Triggered by Thread: 42Thread 0:0 libsystem_kernel.dylib 0x0000000186bf016c _mach_msg_trap :8 (in libsystem_kernel.dylib)1 CoreFoundation 0x0000000187bedcec ___CFRunLoopServiceMachPort :192 (in CoreFoundation)2 CoreFoundation 0x0000000187beb908 ___CFRunLoopRun :1132 (in CoreFoundation)3 CoreFoundation 0x0000000187b1a048 _CFRunLoopRunSpecific :444 (in CoreFoundation)4 GraphicsServices 0x000000018959d198 _GSEventRunModal :180 (in GraphicsServices)5 UIKit 0x000000018daf3818 -[UIApplication _run] :684 (in UIKit)6 UIKit 0x000000018daee550 _UIApplicationMain :208 (in UIKit)7 Tmall4iPhone 0x000000010006bf7c main main.m:27 (in Tmall4iPhone)8 libdyld.dylib 0x0000000186afc5b8 _start :4 (in libdyld.dylib)Thread 42 Crashed:0 CFNetwork 0x00000001883cd970 __ZN15TCPIOConnection12copyPropertyEPK10__CFString :44 (in CFNetwork)1 CFNetwork 0x00000001882a49c4 __ZN14SPDYConnection20_onqueue_closeStreamEP10SPDYStream :236 (in CFNetwork)2 CFNetwork 0x00000001882a48b4 ____ZN14SPDYConnection19startEnqueuedStreamEP10SPDYStream_block_invoke_2 :28 (in CFNetwork)3 libdispatch.dylib 0x0000000186ac9200 __dispatch_call_block_and_release :24 (in libdispatch.dylib)4 libdispatch.dylib 0x0000000186ac91c0 __dispatch_client_callout :16 (in libdispatch.dylib)5 libdispatch.dylib 0x0000000186ad7444 __dispatch_queue_serial_drain :928 (in libdispatch.dylib)6 libdispatch.dylib 0x0000000186acc9a8 __dispatch_queue_invoke :652 (in libdispatch.dylib)7 libdispatch.dylib 0x0000000186ad938c __dispatch_root_queue_drain :572 (in libdispatch.dylib)8 libdispatch.dylib 0x0000000186ad90ec __dispatch_worker_thread3 :124 (in libdispatch.dylib)9 libsystem_pthread.dylib 0x0000000186cd12c8 __pthread_wqthread :1288 (in libsystem_pthread.dylib)10 libsystem_pthread.dylib 0x0000000186cd0db4 _start_wqthread :4 (in libsystem_pthread.dylib)Thread State: lr:0x00000001882a49c4 x6:0x0000000170ade8b0 x7:0x0000000000000450 x4:0x0000000000000001 x5:0x0000000000000010 x2:0x0000021aaf85c0e0 x3:0xfffffff0001fc088 x0:0x0000000000000000 x1:0x00000001ab457998 cpsr:0x0000000080000000 x10:0x0000000000077234 x16:0xfffffff100000000 x15:0xfffffff500000000 x18:0x0000000000000000 x17:0x003000000000f49f x12:0xffc0000800000000 x11:0x0000000000049198 x14:0xfffffffd00000001 fp:0x000000016e5b2c50 x13:0x0000000800000000 sp:0x000000016e5b2b70 x19:0x00000001701574a0 x21:0x00000001ab457998 x9:0x0000000000000000 x8:0x00000001a6bcc000 x20:0x0000000000000000 pc:0x00000001883cd970 x28:0xffffffffffffffff x27:0x000000016e5b30e0 x26:0x0000000000000014 x25:0x0000000000000000 x24:0x0000000000000000 x23:0x00000001746f2580 x22:0xdc990b23045700adBinary Images:0x0000000100064000 - 0x0000000103517fff Tmall4iPhone arm64 &lt;d21caba7463b3a38a7ee3ae16448f4b6&gt; /var/containers/Bundle/Application/5F09E0C7-C766-42D8-B2C7-31E335F73349/Tmall4iPhone.app/Tmall4iPhone0x000000018823b000 - 0x00000001885aafff CFNetwork arm64 &lt;ca09941bfd353bb8b6b679a0f14cad1e&gt; /System/Library/Frameworks/CFNetwork.framework/CFNetwork #3 关注点 Identifier: Unknown|com.taobao.tmall, 在这里区分是线上版本还是线下开发版本. Version: 5.24.1 (5.24.1), 应用版本号. Code Type: ARM-64, 代码架构, 目前有ARM/ARM-64两种. OS Version: iPhone OS 10.0.1 (14A403), 系统版本及build号, 用来查找系统库文件, 用于疑难问题的排查. Exception Type: SIGSEGV, 异常类型常见的有SIGSEGV/SIGABRT/SIGTRAP/SIGBUS/SIGILL等. Exception Codes: SEGV_ACCERR at 0x110, 非法访问0x110这个没有访问权限的地址. Triggered by Thread: 42, 挂的线程是Thread 42, 待会看调用栈的时候, 看Thread 42的调用栈就好. 12345SIGSEGV 访问了非法的地址(地址还没有从系统映射到当前进程的内存空间), 一般是野指针导致, 而野指针一般由于多线程操作对象导致.SIGABRT 一般是Exception或者其他的代码主动退出的问题.SIGTRAP 代码里面触发了调试指令, 该指令可能由编译器提供的trap方法触发, 如'__builtin_trap()'SIGBUS 一般由于地址对齐问题导致, 单纯的OC代码挺难触发的, 主要是系统库方法或者其他c实现的方法导致SIGILL 表示执行了非法的cpu指令, 但是一般是由于死循环导致 那么我们来看 Thread 42 123Thread 42 Crashed:0 CFNetwork 0x00000001883cd970 __ZN15TCPIOConnection12copyPropertyEPK10__CFString :44 (in CFNetwork)1 CoreFoundation 0x0000000187bedcec ___CFRunLoopServiceMachPort :192 (in CoreFoundation) 这里我们取了两条调用栈记录, 这里的每条调用记录都叫做frame, 每条有一个编号0和1, 这个编号代表的是frame number, 它是当前frame在整个调用栈中的索引. 先看frame #0, frame #0是当前调用的方法的信息, 0 CFNetwork 0x00000001883cd970 __ZN15TCPIOConnection12copyPropertyEPK10__CFString :44 (in CFNetwork), CFNetwork代表当前frame调用的方法所在的镜像(可执行文件或动态库)的名称, 0x00000001883cd970代表当前执行的指令在内存中的地址(也就是crash的指令的地址), __ZN15TCPIOConnection12copyPropertyEPK10__CFString :44 是前面那个地址符号化后的方法名称, :44表示挂的指令相对于符号化出来的方法的首地址的偏移量. 再看frame #1, frame #1是调用frame #0方法的地方, 1 CoreFoundation 0x0000000187bedcec ___CFRunLoopServiceMachPort :192 (in CoreFoundation), 镜像名和地址不多说, 这里要说说偏移量:192, 除了frame #0的方法地址是取的pc寄存器的内容(存放的当前指令的地址), 而其他frame实际上存的都是历史记录, 而为了省内存和cpu, frame中并不会保存所有的寄存器的值, 只存了lr寄存器的内容(存放的是方法调用完后要返回的地址), 而返回地址是调用方法的地址的下一个指令地址. 因此偏移量192(lr), 对应的调用处的地址是188(pc). 其他frame的看法参见frame #1. Thread State:, 后面跟的内容是在frame #0挂的时候的所有寄存器的值, 寄存器中可能存放的是一个指令的地址/一个指向对象的指针/一个数值. 寄存器的值结合汇编代码, 可以推断具体是对某个方法调用的参数或者类的成员变量导致的野指针. 后续会有详细的问题分析实战文章做介绍. Binary Images: 表示当前运行时所加载的所有的镜像的名称/uuid/加载地址等信息. 看一条示例: 10x0000000100064000 - 0x0000000103517fff Tmall4iPhone arm64 &lt;d21caba7463b3a38a7ee3ae16448f4b6&gt; /var/containers/Bundle/Application/5F09E0C7-C766-42D8-B2C7-31E335F73349/Tmall4iPhone.app/Tmall4iPhone 000000100064000 - 0x0000000103517fff表示镜像Tmall4iPhone在内存中的加载地址的起始范围, 这个在符号化和调试疑难问题时是一个很重要的参考. Tmall4iPhone是镜像名称, arm64是架构, d21caba7463b3a38a7ee3ae16448f4b6是镜像的uuid, /var/containers/Bundle/Application/5F09E0C7-C766-42D8-B2C7-31E335F73349/Tmall4iPhone.app/Tmall4iPhone是镜像在用户手机上地址. 注1: uuid可以通过dwarfdump --uuid Tmall4iPhone 查看, 确定镜像是否相同.","link":"/source/back/%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90Crash%E6%97%A5%E5%BF%97.html"},{"title":"深入理解 autorelease","text":"深入理解 autorelease 先上一段代码，分别实现了包含 autorelease pool 不包含 autorelease pool 的函数 123456789void autoreleasepool() { @autoreleasepool { NSObject *a = [[NSObject alloc] init]; }}void noautoreleasepool() { NSObject *a = [[NSObject alloc] init];} 编译后再用hopper disassembler 反编译，然后看 autorelasepool函数的汇编代码。 123456789101112131415161718192021222324252627282930 _autoreleasepool:0000000100006b80 stp x29, x30, [sp, #0xfffffff0]! ; XREF=_main+240000000100006b84 mov x29, sp0000000100006b88 sub sp, sp, #0x100000000100006b8c bl imp___stubs__objc_autoreleasePoolPush0000000100006b90 adrp x8, #0x100008000 ; imp___got_dyld_stub_binder0000000100006b94 add x8, x8, #0xc30 ; @selector(alloc)0000000100006b98 adrp x9, #0x100008000 ; imp___got_dyld_stub_binder0000000100006b9c add x9, x9, #0xc40 ; objc_cls_ref_NSObject0000000100006ba0 ldr x9, [x9] ; objc_cls_ref_NSObject0000000100006ba4 ldr x1, [x8] ; @selector(alloc)0000000100006ba8 str x0, [sp]0000000100006bac mov x0, x90000000100006bb0 bl imp___stubs__objc_msgSend0000000100006bb4 adrp x8, #0x100008000 ; imp___got_dyld_stub_binder0000000100006bb8 add x8, x8, #0xc38 ; @selector(init)0000000100006bbc ldr x1, [x8] ; @selector(init)0000000100006bc0 bl imp___stubs__objc_msgSend0000000100006bc4 movz x8, #0x00000000100006bc8 add x9, sp, #0x80000000100006bcc str x0, [sp, #0x8]0000000100006bd0 mov x0, x90000000100006bd4 mov x1, x80000000100006bd8 bl imp___stubs__objc_storeStrong0000000100006bdc ldr x0, [sp]0000000100006be0 bl imp___stubs__objc_autoreleasePoolPop0000000100006be4 mov sp, x290000000100006be8 ldp x29, x30, [sp], #0x100000000100006bec ret ; endp 再看 noautoreleasepool 函数的反汇编代码： 1234567891011121314151617181920212223242526 _noautoreleasepool:0000000100006bf0 stp x29, x30, [sp, #0xfffffff0]! ; XREF=_main+280000000100006bf4 mov x29, sp0000000100006bf8 sub sp, sp, #0x100000000100006bfc adrp x8, #0x100008000 ; imp___got_dyld_stub_binder0000000100006c00 add x8, x8, #0xc30 ; @selector(alloc)0000000100006c04 adrp x9, #0x100008000 ; imp___got_dyld_stub_binder0000000100006c08 add x9, x9, #0xc40 ; objc_cls_ref_NSObject0000000100006c0c ldr x9, [x9] ; objc_cls_ref_NSObject0000000100006c10 ldr x1, [x8] ; @selector(alloc)0000000100006c14 mov x0, x90000000100006c18 bl imp___stubs__objc_msgSend0000000100006c1c adrp x8, #0x100008000 ; imp___got_dyld_stub_binder0000000100006c20 add x8, x8, #0xc38 ; @selector(init)0000000100006c24 ldr x1, [x8] ; @selector(init)0000000100006c28 bl imp___stubs__objc_msgSend0000000100006c2c movz x8, #0x00000000100006c30 add x9, sp, #0x80000000100006c34 str x0, [sp, #0x8]0000000100006c38 mov x0, x90000000100006c3c mov x1, x80000000100006c40 bl imp___stubs__objc_storeStrong0000000100006c44 mov sp, x290000000100006c48 ldp x29, x30, [sp], #0x100000000100006c4c ret ; endp 两者的区别是 autorelease 版本多了如下内容 12345670000000100006b8c bl imp___stubs__objc_autoreleasePoolPush ; 调用 objc_autoreleasePoolPush方法0000000100006ba8 str x0, [sp] ; 把objc_autoreleasePoolPush的返回值入栈......0000000100006bdc ldr x0, [sp] ; 把之前入栈的返回值出栈0000000100006be0 bl imp___stubs__objc_autoreleasePoolPop ; 调用objc_autoreleasePoolPop方法 发现了和预想不一样的地方，按照常理，在 autoreleasepool 里面的对象初始化的时候，似乎要调用-[NSObject autorelease] 来让他自动释放，然而，并没有。 看看 objc 的源码 objc_autoreleasePoolPush 和 objc_autoreleasePoolPop 的实现。 objc_autoreleasePoolPush 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162void *objc_autoreleasePoolPush(void){ if (UseGC) return nil; return AutoreleasePoolPage::push();}static inline void *push() { id *dest; if (DebugPoolAllocation) { // Each autorelease pool starts on a new pool page. dest = autoreleaseNewPage(POOL_SENTINEL); } else { dest = autoreleaseFast(POOL_SENTINEL); } assert(*dest == POOL_SENTINEL); return dest;}static inline id *autoreleaseFast(id obj){ AutoreleasePoolPage *page = hotPage(); if (page &amp;&amp; !page-&gt;full()) { return page-&gt;add(obj); } else if (page) { return autoreleaseFullPage(obj, page); } else { return autoreleaseNoPage(obj); }}static __attribute__((noinline))id *autoreleaseNoPage(id obj){ // No pool in place. assert(!hotPage()); if (obj != POOL_SENTINEL &amp;&amp; DebugMissingPools) { // We are pushing an object with no pool in place, // and no-pool debugging was requested by environment. _objc_inform(&quot;MISSING POOLS: Object %p of class %s &quot; &quot;autoreleased with no pool in place - &quot; &quot;just leaking - break on &quot; &quot;objc_autoreleaseNoPool() to debug&quot;, (void*)obj, object_getClassName(obj)); objc_autoreleaseNoPool(obj); return nil; } // Install the first page. AutoreleasePoolPage *page = new AutoreleasePoolPage(nil); setHotPage(page); // Push an autorelease pool boundary if it wasn't already requested. if (obj != POOL_SENTINEL) { page-&gt;add(POOL_SENTINEL); } // Push the requested object. return page-&gt;add(obj);} push 的主要作用是选一个/建一个autoreleasePoolPage ，设定为hotpage备用，流程图如下 objc_autoreleasePoolPop 1","link":"/source/back/%E7%90%86%E8%A7%A3autorelease.html"},{"title":"标签","text":"","link":"/source/tags/index.html"},{"title":"路由","text":"APP 内组件路由设计 APP内部主要为了解决两个问题 1. 各个页面和组件之间的跳转问题 2. 各个组件之间的相互调用. 各个页面和组件之间的跳转问题 屏幕快照 2018-02-27 下午4.11.24 在iOS开发的过程中，经常会遇到以下的场景，点击按钮跳转Push到另外一个界面，或者点击一个cell Present一个新的ViewController。在MVC模式中，一般都是新建一个VC，然后Push / Present到下一个VC。但是在MVVM中，会有一些不合适的情况。 40_17 众所周知，MVVM把MVC拆成了上图演示的样子，原来View对应的与数据相关的代码都移到ViewModel中，相应的C也变瘦了，演变成了M-VM-C-V的结构。这里的C里面的代码可以只剩下页面跳转相关的逻辑。如果用代码表示就是下面这样子： 假设一个按钮的执行逻辑都封装成了command。 123456 @weakify(self); [[[_viewModel.someCommand executionSignals] flatten] subscribeNext:^(id x) { @strongify(self); // 跳转逻辑 [self.navigationController pushViewController:targetViewController animated:YES];}]; MVVM框架的目的除去解耦以外，还有2个很重要的目的： 代码复用率高 方便进行单元测试 如果需要测试一个业务是否正确，我们只要对ViewModel进行单元测试即可。前提是假定我们使用ReactiveCocoa进行UI绑定的过程是准确无误的。目前绑定是正确的。所以我们只需要单元测试到ViewModel即可完成业务逻辑的测试。 页面跳转也属于业务逻辑，所以应该放在ViewModel中一起单元测试，保证业务逻辑测试的覆盖率。 把页面跳转放到ViewModel中，有2种做法，第一种就是用路由来实现，第二种由于和路由没有关系，所以这里就不多阐述，有兴趣的可以看lpd-mvvm-kit这个库关于页面跳转的具体实现。 页面跳转相互的耦合性也就体现出来了： 由于pushViewController或者presentViewController，后面都需要带一个待操作的ViewController，那么就必须要引入该类，import头文件也就引入了耦合性。 由于跳转这里写死了跳转操作，如果线上一旦出现了bug，这里是不受我们控制的。 推送消息或者是3D-Touch需求，要求直接跳转到内部第10级界面，那么就需要写一个入口跳转到指定界面。 各个组件之间的相互调用 屏幕快照 2018-02-27 下午4.24.18 关于组件间的调用，也需要解耦。随着业务越来越复杂，我们封装的组件越来越多，要是封装的粒度拿捏不准，就会出现大量组件之间耦合度高的问题。组件的粒度可以随着业务的调整，不断的调整组件职责的划分。但是组件之间的调用依旧不可避免，相互调用对方组件暴露的接口。如何减少各个组件之间的耦合度，是一个设计优秀的路由的职责所在。 如何设计一个路由 方案调研 JLRoutes JLRoutes 使用 URL Scheme 的方式，将所有的资源看成是一个URL。 JLRoutes 将传入的 URL Scheme 按照上面的样子进行分割，并获取NSURLComponent JLRoutes全局会保存一个Map，这个Map会以scheme为Key，JLRoutes为Value。所以在routeControllerMap里面每个scheme都是唯一的。 在每个JLRoutes里面都保存了一个数组，这个数组里面保存了每个路由规则JLRRouteDefinition里面会保存外部传进来的block闭包，pattern，和拆分之后的pattern。 在每个JLRoutes的数组里面，会按照路由的优先级进行排列，优先级高的排列在前面。 123456789101112131415161718192021222324252627- (void)_registerRoute:(NSString *)routePattern priority:(NSUInteger)priority handler:(BOOL (^)(NSDictionary *parameters))handlerBlock{ JLRRouteDefinition *route = [[JLRRouteDefinition alloc] initWithScheme:self.scheme pattern:routePattern priority:priority handlerBlock:handlerBlock]; if (priority == 0 || self.routes.count == 0) { [self.routes addObject:route]; } else { NSUInteger index = 0; BOOL addedRoute = NO; // 找到当前已经存在的一条优先级比当前待插入的路由低的路由 for (JLRRouteDefinition *existingRoute in [self.routes copy]) { if (existingRoute.priority &lt; priority) { // 如果找到，就插入数组 [self.routes insertObject:route atIndex:index]; addedRoute = YES; break; } index++; } // 如果没有找到任何一条路由比当前待插入的路由低的路由，或者最后一条路由优先级和当前路由一样，那么就只能插入到最后。 if (!addedRoute) { [self.routes addObject:route]; } }} 由于这个数组里面的路由是一个单调队列，所以查找优先级的时候只用从高往低遍历即可。 具体查找路由的过程如下 首先根据外部传进来的URL初始化一个JLRRouteRequest，然后用这个JLRRouteRequest在当前的路由数组里面依次request，每个规则都会生成一个response，但是只有符合条件的response才会match，最后取出匹配的JLRRouteResponse拿出其字典parameters里面对应的参数就可以了。查找和匹配过程中重要的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859- (BOOL)_routeURL:(NSURL *)URL withParameters:(NSDictionary *)parameters executeRouteBlock:(BOOL)executeRouteBlock{ if (!URL) { return NO; } [self _verboseLog:@&quot;Trying to route URL %@&quot;, URL]; BOOL didRoute = NO; JLRRouteRequest *request = [[JLRRouteRequest alloc] initWithURL:URL]; for (JLRRouteDefinition *route in [self.routes copy]) { // 检查每一个route，生成对应的response JLRRouteResponse *response = [route routeResponseForRequest:request decodePlusSymbols:shouldDecodePlusSymbols]; if (!response.isMatch) { continue; } [self _verboseLog:@&quot;Successfully matched %@&quot;, route]; if (!executeRouteBlock) { // 如果我们被要求不允许执行，但是又找了匹配的路由response。 return YES; } // 装配最后的参数 NSMutableDictionary *finalParameters = [NSMutableDictionary dictionary]; [finalParameters addEntriesFromDictionary:response.parameters]; [finalParameters addEntriesFromDictionary:parameters]; [self _verboseLog:@&quot;Final parameters are %@&quot;, finalParameters]; didRoute = [route callHandlerBlockWithParameters:finalParameters]; if (didRoute) { // 调用Handler成功 break; } } if (!didRoute) { [self _verboseLog:@&quot;Could not find a matching route&quot;]; } // 如果在当前路由规则里面没有找到匹配的路由，当前路由不是global 的，并且允许降级到global里面去查找，那么我们继续在global的路由规则里面去查找。 if (!didRoute &amp;&amp; self.shouldFallbackToGlobalRoutes &amp;&amp; ![self _isGlobalRoutesController]) { [self _verboseLog:@&quot;Falling back to global routes...&quot;]; didRoute = [[JLRoutes globalRoutes] _routeURL:URL withParameters:parameters executeRouteBlock:executeRouteBlock]; } // 最后，依旧没有找到任何能匹配的，如果有unmatched URL handler，调用这个闭包进行最后的处理。if, after everything, we did not route anything and we have an unmatched URL handler, then call it if (!didRoute &amp;&amp; executeRouteBlock &amp;&amp; self.unmatchedURLHandler) { [self _verboseLog:@&quot;Falling back to the unmatched URL handler&quot;]; self.unmatchedURLHandler(self, URL, parameters); } return didRoute;} 举个例子 先注册一个Router，规则如下: 123456[[JLRoutes globalRoutes] addRoute:@&quot;/:object/:action&quot; handler:^BOOL(NSDictionary *parameters) { NSString *object = parameters[@&quot;object&quot;]; NSString *action = parameters[@&quot;action&quot;]; // stuff return YES;}]; 传入一个URL， 让 Route 处理 12NSURL *editPost = [NSURL URLWithString:@&quot;ele://post/halfrost?debug=true&amp;foo=bar&quot;]; [[UIApplication sharedApplication] openURL:editPost]; 匹配之后，得到如下的字典 123456789{ &quot;object&quot;: &quot;post&quot;, &quot;action&quot;: &quot;halfrost&quot;, &quot;debug&quot;: &quot;true&quot;, &quot;foo&quot;: &quot;bar&quot;, &quot;JLRouteURL&quot;: &quot;ele://post/halfrost?debug=true&amp;foo=bar&quot;, &quot;JLRoutePattern&quot;: &quot;/:object/:action&quot;, &quot;JLRouteScheme&quot;: &quot;JLRoutesGlobalRoutesScheme&quot;} 详细过程 JLRoutes还可以支持Optional的路由规则，假如定义一条路由规则： Swift/the(/foo/:a)(/bar/:b) JLRoutes 会帮我们默认注册如下4条路由规则： 1234/the/foo/:a/bar/:b/the/foo/:a/the/bar/:b/the routable-ios Routable路由是用在in-app native端的 URL router, 它可以用在iOS上也可以用在 Android UPRouter里面保存了2个字典。 routes字典里面存储的Key是路由规则，Value存储的是UPRouterOptions。 cachedRoutes里面存储的Key是最终的URL，带传参的，Value存储的是RouterParams。RouterParams里面会包含在routes匹配的到的UPRouterOptions，还有额外的打开参数openParams和一些额外参数extraParams。 这一段代码里面重点在干一件事情，遍历routes字典，然后找到参数匹配的字符串，封装成RouterParams返回。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (RouterParams *)routerParamsForUrl:(NSString *)url extraParams: (NSDictionary *)extraParams { if (!url) { //if we wait, caching this as key would throw an exception if (_ignoresExceptions) { return nil; } @throw [NSException exceptionWithName:@&quot;RouteNotFoundException&quot; reason:[NSString stringWithFormat:ROUTE_NOT_FOUND_FORMAT, url] userInfo:nil]; } if ([self.cachedRoutes objectForKey:url] &amp;&amp; !extraParams) { return [self.cachedRoutes objectForKey:url]; } // 比对url通过/分割之后的参数个数和pathComponents的个数是否一样 NSArray *givenParts = url.pathComponents; NSArray *legacyParts = [url componentsSeparatedByString:@&quot;/&quot;]; if ([legacyParts count] != [givenParts count]) { NSLog(@&quot;Routable Warning - your URL %@ has empty path components - this will throw an error in an upcoming release&quot;, url); givenParts = legacyParts; } __block RouterParams *openParams = nil; [self.routes enumerateKeysAndObjectsUsingBlock: ^(NSString *routerUrl, UPRouterOptions *routerOptions, BOOL *stop) { NSArray *routerParts = [routerUrl pathComponents]; if ([routerParts count] == [givenParts count]) { NSDictionary *givenParams = [self paramsForUrlComponents:givenParts routerUrlComponents:routerParts]; if (givenParams) { openParams = [[RouterParams alloc] initWithRouterOptions:routerOptions openParams:givenParams extraParams: extraParams]; *stop = YES; } } }]; if (!openParams) { if (_ignoresExceptions) { return nil; } @throw [NSException exceptionWithName:@&quot;RouteNotFoundException&quot; reason:[NSString stringWithFormat:ROUTE_NOT_FOUND_FORMAT, url] userInfo:nil]; } [self.cachedRoutes setObject:openParams forKey:url]; return openParams;} 下面这段函数，第一个参数是外部传进来URL带有各个入参的分割数组。第二个参数是路由规则分割开的数组。routerComponent由于规定：号后面才是参数，所以routerComponent的第1个位置就是对应的参数名。params字典里面以参数名为Key，参数为Value。 123456789101112131415161718- (NSDictionary *)paramsForUrlComponents:(NSArray *)givenUrlComponents routerUrlComponents:(NSArray *)routerUrlComponents { __block NSMutableDictionary *params = [NSMutableDictionary dictionary]; [routerUrlComponents enumerateObjectsUsingBlock: ^(NSString *routerComponent, NSUInteger idx, BOOL *stop) { NSString *givenComponent = givenUrlComponents[idx]; if ([routerComponent hasPrefix:@&quot;:&quot;]) { NSString *key = [routerComponent substringFromIndex:1]; [params setObject:givenComponent forKey:key]; } else if (![routerComponent isEqualToString:givenComponent]) { params = nil; *stop = YES; } }]; return params;} 通过RouterParams的初始化方法，把路由规则对应的UPRouterOptions，上一步封装好的参数字典givenParams，还有 routerParamsForUrl: extraParams: 方法的第二个入参，这3个参数作为初始化参数，生成了一个RouterParams 12345 NSDictionary *givenParams = [self paramsForUrlComponents:givenParts routerUrlComponents:routerParts];if (givenParams) { openParams = [[RouterParams alloc] initWithRouterOptions:routerOptions openParams:givenParams extraParams: extraParams]; *stop = YES;} 最后一步self.cachedRoutes的字典里面Key为带参数的URL，Value是RouterParams。 1[self.cachedRoutes setObject:openParams forKey:url]; 最后将匹配封装出来的RouterParams转换成对应的Controller。 123456789101112131415161718192021222324252627- (UIViewController *)controllerForRouterParams:(RouterParams *)params { SEL CONTROLLER_CLASS_SELECTOR = sel_registerName(&quot;allocWithRouterParams:&quot;); SEL CONTROLLER_SELECTOR = sel_registerName(&quot;initWithRouterParams:&quot;); UIViewController *controller = nil; Class controllerClass = params.routerOptions.openClass;#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; if ([controllerClass respondsToSelector:CONTROLLER_CLASS_SELECTOR]) { controller = [controllerClass performSelector:CONTROLLER_CLASS_SELECTOR withObject:[params controllerParams]]; } else if ([params.routerOptions.openClass instancesRespondToSelector:CONTROLLER_SELECTOR]) { controller = [[params.routerOptions.openClass alloc] performSelector:CONTROLLER_SELECTOR withObject:[params controllerParams]]; }#pragma clang diagnostic pop if (!controller) { if (_ignoresExceptions) { return controller; } @throw [NSException exceptionWithName:@&quot;RoutableInitializerNotFound&quot; reason:[NSString stringWithFormat:INVALID_CONTROLLER_FORMAT, NSStringFromClass(controllerClass), NSStringFromSelector(CONTROLLER_CLASS_SELECTOR), NSStringFromSelector(CONTROLLER_SELECTOR)] userInfo:nil]; } controller.modalTransitionStyle = params.routerOptions.transitionStyle; controller.modalPresentationStyle = params.routerOptions.presentationStyle; return controller;} 如果Controller是一个类，那么就调用allocWithRouterParams:方法去初始化。如果Controller已经是一个实例了，那么就调用initWithRouterParams:方法去初始化。 将Routable的大致流程图解如下： HHRouter ViewController提供了2个方法。map是用来设置路由规则，matchController是用来匹配路由规则的，匹配争取之后返回对应的UIViewController。 12- (void)map:(NSString *)route toControllerClass:(Class)controllerClass;- (UIViewController *)matchController:(NSString *)route; block闭包提供了三个方法，map也是设置路由规则，matchBlock：是用来匹配路由，找到指定的block，但是不会调用该block。callBlock:是找到指定的block，找到以后就立即调用。 1234- (void)map:(NSString *)route toBlock:(HHRouterBlock)block;- (HHRouterBlock)matchBlock:(NSString *)route;- (id)callBlock:(NSString *)route; matchBlock:和callBlock:的区别就在于前者不会自动调用闭包。所以matchBlock:方法找到对应的block之后，如果想调用，需要手动调用一次。 除去上面这些方法，HHRouter还为我们提供了一个特殊的方法。 1- (HHRouteType)canRoute:(NSString *)route; 这个方法就是用来找到执行路由规则对应的RouteType，RouteType总共就3种: 12345typedef NS_ENUM (NSInteger, HHRouteType) { HHRouteTypeNone = 0, HHRouteTypeViewController = 1, HHRouteTypeBlock = 2}; 再来看看HHRouter是如何管理路由规则的。整个HHRouter就是由一个NSMutableDictionary *routes控制的。 123@interface HHRouter ()@property (strong, nonatomic) NSMutableDictionary *routes;@end 别看只有这一个看似“简单”的字典数据结构，但是HHRouter路由设计的还是很精妙的。 1234567891011- (void)map:(NSString *)route toBlock:(HHRouterBlock)block{ NSMutableDictionary *subRoutes = [self subRoutesToRoute:route]; subRoutes[@&quot;_&quot;] = [block copy];}- (void)map:(NSString *)route toControllerClass:(Class)controllerClass{ NSMutableDictionary *subRoutes = [self subRoutesToRoute:route]; subRoutes[@&quot;_&quot;] = controllerClass;} 上面两个方法分别是block闭包和ViewController设置路由规则调用的方法实体。不管是ViewController还是block闭包，设置规则的时候都会调用subRoutesToRoute:方法。 123456789101112131415161718- (NSMutableDictionary *)subRoutesToRoute:(NSString *)route{ NSArray *pathComponents = [self pathComponentsFromRoute:route]; NSInteger index = 0; NSMutableDictionary *subRoutes = self.routes; while (index &lt; pathComponents.count) { NSString *pathComponent = pathComponents[index]; if (![subRoutes objectForKey:pathComponent]) { subRoutes[pathComponent] = [[NSMutableDictionary alloc] init]; } subRoutes = subRoutes[pathComponent]; index++; } return subRoutes;} 上面这段函数就是来构造路由匹配规则的字典。 举个例子： 123456[[HHRouter shared] map:@&quot;/user/:userId/&quot; toControllerClass:[UserViewController class]];[[HHRouter shared] map:@&quot;/story/:storyId/&quot; toControllerClass:[StoryViewController class]];[[HHRouter shared] map:@&quot;/user/:userId/story/?a=0&quot; toControllerClass:[StoryListViewController class]]; 设置3条规则以后，按照上面构造路由匹配规则的字典的方法，该路由规则字典就会变成这个样子： 123456789101112131415{ story = { &quot;:storyId&quot; = { &quot;_&quot; = StoryViewController; }; }; user = { &quot;:userId&quot; = { &quot;_&quot; = UserViewController; story = { &quot;_&quot; = StoryListViewController; }; }; };} 路由规则字典生成之后，等到匹配的时候就会遍历这个字典。 假设这时候有一条路由过来： 1[[[HHRouter shared] matchController:@&quot;hhrouter20://user/1/&quot;] class], HHRouter对这条路由的处理方式是先匹配前面的scheme，如果连scheme都不正确的话，会直接导致后面匹配失败。 然后再进行路由匹配，最后生成的参数字典如下： 12345{ &quot;controller_class&quot; = UserViewController; route = &quot;/user/1/&quot;; userId = 1;} 具体的路由参数匹配的函数在 1- (NSDictionary *)paramsInRoute:(NSString *)route 个方法里面实现的。这个方法就是按照路由匹配规则，把传进来的URL的参数都一一解析出来，带？号的也都会解析成字典。这个方法没什么难度，就不在赘述了。 ViewController 的字典里面默认还会加上2项： 12&quot;controller_class&quot; = route = route里面都会保存传过来的完整的URL。 如果传进来的路由后面带访问字符串呢？那我们再来看看： 1[[HHRouter shared] matchController:@&quot;/user/1/?a=b&amp;c=d&quot;] 那么解析出所有的参数字典会是下面的样子： 1234567{ a = b; c = d; &quot;controller_class&quot; = UserViewController; route = &quot;/user/1/?a=b&amp;c=d&quot;; userId = 1;} 同理，如果是一个block闭包的情况呢？ 还是先添加一条block闭包的路由规则： 12[[HHRouter shared] map:@&quot;/user/add/&quot; toBlock:^id(NSDictionary* params) {}]; 这条规则对应的会生成一个路由规则的字典。 123456789101112131415161718{ story = { &quot;:storyId&quot; = { &quot;_&quot; = StoryViewController; }; }; user = { &quot;:userId&quot; = { &quot;_&quot; = UserViewController; story = { &quot;_&quot; = StoryListViewController; }; }; add = { &quot;_&quot; = &quot;&lt;__NSMallocBlock__: 0x600000240480&gt;&quot;; }; };} 注意”_”后面跟着是一个block。 匹配block闭包的方式有两种。 1234567// 1.第一种方式匹配到对应的block之后，还需要手动调用一次闭包。 HHRouterBlock block = [[HHRouter shared] matchBlock:@&quot;/user/add/?a=1&amp;b=2&quot;]; block(nil);// 2.第二种方式匹配block之后自动会调用改闭包。 [[HHRouter shared] callBlock:@&quot;/user/add/?a=1&amp;b=2&quot;]; 匹配出来的参数字典是如下： 123456{ a = 1; b = 2; block = &quot;&lt;__NSMallocBlock__: 0x600000056b90&gt;&quot;; route = &quot;/user/add/?a=1&amp;b=2&quot;;} block的字典里面会默认加上下面这2项： 12block = route = route里面都会保存传过来的完整的URL。 生成的参数字典最终会被绑定到ViewController的Associated Object关联对象上。 123456789- (void)setParams:(NSDictionary *)paramsDictionary{ objc_setAssociatedObject(self, &amp;kAssociatedParamsObjectKey, paramsDictionary, OBJC_ASSOCIATION_RETAIN_NONATOMIC);}- (NSDictionary *)params{ return objc_getAssociatedObject(self, &amp;kAssociatedParamsObjectKey);} 这个绑定的过程是在match匹配完成的时候进行的。 12345678910111213- (UIViewController *)matchController:(NSString *)route{ NSDictionary *params = [self paramsInRoute:route]; Class controllerClass = params[@&quot;controller_class&quot;]; UIViewController *viewController = [[controllerClass alloc] init]; if ([viewController respondsToSelector:@selector(setParams:)]) { [viewController performSelector:@selector(setParams:) withObject:[params copy]]; } return viewController;} 最终得到的ViewController也是我们想要的。相应的参数都在它绑定的params属性的字典里面。 将上述过程图解出来，如下： MGJRouter JLRoutes 的问题主要在于查找 URL 的实现不够高效，通过遍历而不是匹配。还有就是功能偏多。 HHRouter 的 URL 查找是基于匹配，所以会更高效，MGJRouter 也是采用的这种方法，但它跟 ViewController 绑定地过于紧密，一定程度上降低了灵活性。 于是就有了 MGJRouter。 从数据结构来看，MGJRouter还是和HHRouter一模一样的 123@interface MGJRouter ()@property (nonatomic) NSMutableDictionary *routes;@end 那么我们就来看看它对HHRouter做了哪些优化改进。 1.MGJRouter支持openURL时，可以传一些 userinfo 过去 1[MGJRouter openURL:@&quot;mgj://category/travel&quot; withUserInfo:@{@&quot;user_id&quot;: @1900} completion:nil]; 这个对比HHRouter，仅仅只是写法上的一个语法糖，在HHRouter中虽然不支持带字典的参数，但是在URL后面可以用URL Query Parameter来弥补。 12345678910111213if (parameters) { MGJRouterHandler handler = parameters[@&quot;block&quot;]; if (completion) { parameters[MGJRouterParameterCompletion] = completion; } if (userInfo) { parameters[MGJRouterParameterUserInfo] = userInfo; } if (handler) { [parameters removeObjectForKey:@&quot;block&quot;]; handler(parameters); } } MGJRouter对userInfo的处理是直接把它封装到Key = MGJRouterParameterUserInfo对应的Value里面。 2.支持中文的URL。 12345[parameters enumerateKeysAndObjectsUsingBlock:^(id key, NSString *obj, BOOL *stop) { if ([obj isKindOfClass:[NSString class]]) { parameters[key] = [obj stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; } }]; 这里就是需要注意一下编码。 3.定义一个全局的 URL Pattern 作为 Fallback。 这一点是模仿的JLRoutes的匹配不到会自动降级到global的思想。 1234567if (parameters) { MGJRouterHandler handler = parameters[@&quot;block&quot;]; if (handler) { [parameters removeObjectForKey:@&quot;block&quot;]; handler(parameters); } } parameters字典里面会先存储下一个路由规则，存在block闭包中，在匹配的时候会取出这个handler，降级匹配到这个闭包中，进行最终的处理。 4.当 OpenURL 结束时，可以执行 Completion Block。 在MGJRouter里面，作者对原来的HHRouter字典里面存储的路由规则的结构进行了改造。 123NSString *const MGJRouterParameterURL = @&quot;MGJRouterParameterURL&quot;; NSString *const MGJRouterParameterCompletion = @&quot;MGJRouterParameterCompletion&quot;; NSString *const MGJRouterParameterUserInfo = @&quot;MGJRouterParameterUserInfo&quot;; 这3个key会分别保存一些信息： MGJRouterParameterURL保存的传进来的完整的URL信息。 MGJRouterParameterCompletion保存的是completion闭包。 MGJRouterParameterUserInfo保存的是UserInfo字典。 举个例子： 12345678910[MGJRouter registerURLPattern:@&quot;ele://name/:name&quot; toHandler:^(NSDictionary *routerParameters) { void (^completion)(NSString *) = routerParameters[MGJRouterParameterCompletion]; if (completion) { completion(@&quot;完成了&quot;); } }]; [MGJRouter openURL:@&quot;ele://name/halfrost/?age=20&quot; withUserInfo:@{@&quot;user_id&quot;: @1900} completion:^(id result) { NSLog(@&quot;result = %@&quot;,result); }]; 上面的URL会匹配成功，那么生成的参数字典结构如下： 12345678910{ MGJRouterParameterCompletion = &quot;&lt;__NSGlobalBlock__: 0x107ffe680&gt;&quot;; MGJRouterParameterURL = &quot;ele://name/halfrost/?age=20&quot;; MGJRouterParameterUserInfo = { &quot;user_id&quot; = 1900; }; age = 20; block = &quot;&lt;__NSMallocBlock__: 0x608000252120&gt;&quot;; name = halfrost;} 5.可以统一管理URL 这个功能非常有用。 URL 的处理一不小心，就容易散落在项目的各个角落，不容易管理。比如注册时的 pattern 是 mgj://beauty/:id，然后 open 时就是 mgj://beauty/123，这样到时候 url 有改动，处理起来就会很麻烦，不好统一管理。 所以 MGJRouter 提供了一个类方法来处理这个问题。 12345678#define TEMPLATE_URL @&quot;qq://name/:name&quot;[MGJRouter registerURLPattern:TEMPLATE_URL toHandler:^(NSDictionary *routerParameters) { NSLog(@&quot;routerParameters[name]:%@&quot;, routerParameters[@&quot;name&quot;]); // halfrost}];[MGJRouter openURL:[MGJRouter generateURLWithPattern:TEMPLATE_URL parameters:@[@&quot;halfrost&quot;]]];} generateURLWithPattern:函数会对我们定义的宏里面的所有的:进行替换，替换成后面的字符串数组，依次赋值。 将上述过程图解出来，如下： 蘑菇街为了区分开页面间调用和组件间调用，于是想出了一种新的方法。用Protocol的方法来进行组件间的调用。 每个组件之间都有一个 Entry，这个 Entry，主要做了三件事： 注册这个组件关心的 URL 注册这个组件能够被调用的方法/属性 在 App 生命周期的不同阶段做不同的响应 页面间的openURL调用就是如下的样子： 每个组件间都会向MGJRouter注册，组件间相互调用或者是其他的App都可以通过openURL:方法打开一个界面或者调用一个组件。 在组件间的调用，蘑菇街采用了Protocol的方式。 [ModuleManager registerClass:ClassA forProtocol:ProtocolA] 的结果就是在 MM 内部维护的 dict 里新加了一个映射关系。 [ModuleManager classForProtocol:ProtocolA] 的返回结果就是之前在 MM 内部 dict 里 protocol 对应的 class，使用方不需要关心这个 class 是个什么东东，反正实现了 ProtocolA 协议，拿来用就行。 这里需要有一个公共的地方来容纳这些 public protocl，也就是图中的 PublicProtocl.h。 我猜测，大概实现可能是下面的样子： 123456@interface ModuleProtocolManager : NSObject+ (void)registServiceProvide:(id)provide forProtocol:(Protocol*)protocol;+ (id)serviceProvideForProtocol:(Protocol *)protocol;@end 然后这是一个单例，在这里注册各个协议 12345678910111213141516171819202122232425262728293031323334353637@interface ModuleProtocolManager ()@property (nonatomic, strong) NSMutableDictionary *serviceProvideSource;@end@implementation ModuleProtocolManager+ (ModuleProtocolManager *)sharedInstance{ static ModuleProtocolManager * instance; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ instance = [[self alloc] init]; }); return instance;}- (instancetype)init{ self = [super init]; if (self) { _serviceProvideSource = [[NSMutableDictionary alloc] init]; } return self;}+ (void)registServiceProvide:(id)provide forProtocol:(Protocol*)protocol{ if (provide == nil || protocol == nil) return; [[self sharedInstance].serviceProvideSource setObject:provide forKey:NSStringFromProtocol(protocol)];}+ (id)serviceProvideForProtocol:(Protocol *)protocol{ return [[self sharedInstance].serviceProvideSource objectForKey:NSStringFromProtocol(protocol)];} 在ModuleProtocolManager中用一个字典保存每个注册的protocol。现在再来猜猜ModuleEntry的实现。 12345678#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;@protocol DetailModuleEntryProtocol &lt;NSObject&gt;@required;- (UIViewController *)detailViewControllerWithId:(NSString*)Id Name:(NSString *)name;@end 然后每个模块内都有一个和暴露到外面的协议相连接的“接头”。 1234#import &lt;Foundation/Foundation.h&gt;@interface DetailModuleEntry : NSObject@end 在它的实现中，需要引入3个外部文件，一个是ModuleProtocolManager，一个是DetailModuleEntryProtocol，最后一个是所在模块需要跳转或者调用的组件或者页面。 123456789101112131415161718192021222324#import &quot;DetailModuleEntry.h&quot;#import &lt;DetailModuleEntryProtocol/DetailModuleEntryProtocol.h&gt;#import &lt;ModuleProtocolManager/ModuleProtocolManager.h&gt;#import &quot;DetailViewController.h&quot;@interface DetailModuleEntry()&lt;DetailModuleEntryProtocol&gt;@end@implementation DetailModuleEntry+ (void)load{ [ModuleProtocolManager registServiceProvide:[[self alloc] init] forProtocol:@protocol(DetailModuleEntryProtocol)];}- (UIViewController *)detailViewControllerWithId:(NSString*)Id Name:(NSString *)name{ DetailViewController *detailVC = [[DetailViewController alloc] initWithId:id Name:name]; return detailVC;}@end 至此基于Protocol的方案就完成了。如果需要调用某个组件或者跳转某个页面，只要先从ModuleProtocolManager的字典里面根据对应的ModuleEntryProtocol找到对应的DetailModuleEntry，找到了DetailModuleEntry就是找到了组件或者页面的“入口”了。再把参数传进去即可。 1234567- (void)didClickDetailButton:(UIButton *)button{ id&lt; DetailModuleEntryProtocol &gt; DetailModuleEntry = [ModuleProtocolManager serviceProvideForProtocol:@protocol(DetailModuleEntryProtocol)]; UIViewController *detailVC = [DetailModuleEntry detailViewControllerWithId:@“详情界面” Name:@“我的购物车”]; [self.navigationController pushViewController:detailVC animated:YES];} 这样就可以调用到组件或者界面了。 如果组件之间有相同的接口，那么还可以进一步的把这些接口都抽离出来。这些抽离出来的接口变成“元接口”，它们是可以足够支撑起整个组件一层的。 CTMediator 这方案是基于Mediator的。 传统的中间人Mediator的模式是这样的 这种模式每个页面或者组件都会依赖中间者，各个组件之间互相不再依赖，组件间调用只依赖中间者Mediator，Mediator还是会依赖其他组件。那么这是最终方案了么？ 主要思想是利用了Target-Action简单粗暴的思想，利用Runtime解决解耦的问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget{ NSString *targetClassString = [NSString stringWithFormat:@&quot;Target_%@&quot;, targetName]; NSString *actionString = [NSString stringWithFormat:@&quot;Action_%@:&quot;, actionName]; Class targetClass; NSObject *target = self.cachedTarget[targetClassString]; if (target == nil) { targetClass = NSClassFromString(targetClassString); target = [[targetClass alloc] init]; } SEL action = NSSelectorFromString(actionString); if (target == nil) { // 这里是处理无响应请求的地方之一，这个demo做得比较简单，如果没有可以响应的target，就直接return了。实际开发过程中是可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求的 return nil; } if (shouldCacheTarget) { self.cachedTarget[targetClassString] = target; } if ([target respondsToSelector:action]) {#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; return [target performSelector:action withObject:params];#pragma clang diagnostic pop } else { // 有可能target是Swift对象 actionString = [NSString stringWithFormat:@&quot;Action_%@WithParams:&quot;, actionName]; action = NSSelectorFromString(actionString); if ([target respondsToSelector:action]) {#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; return [target performSelector:action withObject:params];#pragma clang diagnostic pop } else { // 这里是处理无响应请求的地方，如果无响应，则尝试调用对应target的notFound方法统一处理 SEL action = NSSelectorFromString(@&quot;notFound:&quot;); if ([target respondsToSelector:action]) {#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; return [target performSelector:action withObject:params];#pragma clang diagnostic pop } else { // 这里也是处理无响应请求的地方，在notFound都没有的时候，这个demo是直接return了。实际开发过程中，可以用前面提到的固定的target顶上的。 [self.cachedTarget removeObjectForKey:targetClassString]; return nil; } } }} targetName就是调用接口的Object，actionName就是调用方法的SEL，params是参数，shouldCacheTarget代表是否需要缓存，如果需要缓存就把target存起来，Key是targetClassString，Value是target。 通过这种方式进行改造的，外面调用的方法都很统一，都是调用performTarget: action: params: shouldCacheTarget:。第三个参数是一个字典，这个字典里面可以传很多参数，只要Key-Value写好就可以了。处理错误的方式也统一在一个地方了，target没有，或者是target无法响应相应的方法，都可以在Mediator这里进行统一出错处理。 但是在实际开发过程中，不管是界面调用，组件间调用，在Mediator中需要定义很多方法。于是作者又想出了建议我们用Category的方法，对Mediator的所有方法进行拆分，这样就就可以不会导致Mediator这个类过于庞大了。 123456789101112131415161718192021222324252627282930313233- (UIViewController *)CTMediator_viewControllerForDetail{ UIViewController *viewController = [self performTarget:kCTMediatorTargetA action:kCTMediatorActionNativFetchDetailViewController params:@{@&quot;key&quot;:@&quot;value&quot;} shouldCacheTarget:NO ]; if ([viewController isKindOfClass:[UIViewController class]]) { // view controller 交付出去之后，可以由外界选择是push还是present return viewController; } else { // 这里处理异常场景，具体如何处理取决于产品 return [[UIViewController alloc] init]; }}- (void)CTMediator_presentImage:(UIImage *)image{ if (image) { [self performTarget:kCTMediatorTargetA action:kCTMediatorActionNativePresentImage params:@{@&quot;image&quot;:image} shouldCacheTarget:NO]; } else { // 这里处理image为nil的场景，如何处理取决于产品 [self performTarget:kCTMediatorTargetA action:kCTMediatorActionNativeNoImage params:@{@&quot;image&quot;:[UIImage imageNamed:@&quot;noImage&quot;]} shouldCacheTarget:NO]; }} 把这些具体的方法一个个的都写在Category里面就好了，调用的方式都非常的一致，都是调用performTarget: action: params: shouldCacheTarget:方法。 最终去掉了中间者Mediator对组件的依赖，各个组件之间互相不再依赖，组件间调用只依赖中间者Mediator，Mediator不依赖其他任何组件。 没有开源的解决方案 Uber在发现MVC的一些弊端之后：比如动辄上万行巨胖无比的VC，无法进行单元测试等缺点后，于是考虑把架构换成VIPER。但是VIPER也有一定的弊端。因为它的iOS特定的结构，意味着iOS必须为Android做出一些妥协的权衡。以视图为驱动的应用程序逻辑，代表应用程序状态由视图驱动，整个应用程序都锁定在视图树上。由操作应用程序状态所关联的业务逻辑的改变，就必须经过Presenter。因此会暴露业务逻辑。最终导致了视图树和业务树进行了紧紧的耦合。这样想实现一个紧紧只有业务逻辑的Node节点或者紧紧只有视图逻辑的Node节点就非常的困难了。 通过改进VIPER架构，吸收其优秀的特点，改进其缺点，就形成了Uber 骑手App的全新架构——Riblets(肋骨)。 在这个新的架构中，即使是相似的逻辑也会被区分成很小很小，相互独立，可以单独进行测试的组件。每个组件都有非常明确的用途。使用这些一小块一小块的Riblets(肋骨)，最终把整个App拼接成一颗Riblets(肋骨)树。 通过抽象，一个Riblets(肋骨)被定义成一下6个更小的组件，这些组件各自有各自的职责。通过一个Riblets(肋骨)进一步的抽象业务逻辑和视图逻辑 一个Riblets(肋骨)被设计成这样，那和之前的VIPER和MVC有什么区别呢？最大的区别在路由上面。 Riblets(肋骨)内的Router不再是视图逻辑驱动的，现在变成了业务逻辑驱动。这一重大改变就导致了整个App不再是由表现形式驱动，现在变成了由数据流驱动。 每一个Riblet都是由一个路由Router，一个关联器Interactor，一个构造器Builder和它们相关的组件构成的。所以它的命名（Router - Interactor - Builder，Rib）也由此得来。当然还可以有可选的展示器Presenter和视图View。路由Router和关联器Interactor处理业务逻辑，展示器Presenter和视图View处理视图逻辑。 重点分析一下Riblet里面路由的职责。 路由职责 在整个App的结构树中，路由的职责是用来关联和取消关联其他子Riblet的。至于决定是由关联器Interactor传递过来的。在状态转换过程中，关联和取消关联子Riblet的时候，路由也会影响到关联器Interactor的生命周期。路由只包含2个业务逻辑： 1.提供关联和取消关联其他路由的方法。 2.在多个孩子之间决定最终状态的状态转换逻辑 拼装 每一个Riblets只有一对Router路由和Interactor关联器。但是它们可以有多对视图。Riblets只处理业务逻辑，不处理视图相关的部分。Riblets可以拥有单一的视图（一个Presenter展示器和一个View视图），也可以拥有多个视图（一个Presenter展示器和多个View视图，或者多个Presenter展示器和多个View视图），甚至也可以能没有视图（没有Presenter展示器也没有View视图）。这种设计可以有助于业务逻辑树的构建，也可以和视图树做到很好的分离。 举个例子，骑手的Riblet是一个没有视图的Riblet，它用来检查当前用户是否有一个激活的路线。如果骑手确定了路线，那么这个Riblet就会关联到路线的Riblet上面。路线的Riblet会在地图上显示出路线图。如果没有确定路线，骑手的Riblet就会被关联到请求的Riblet上。请求的Riblet会在屏幕上显示等待被呼叫。像骑手的Riblet这样没有任何视图逻辑的Riblet，它分开了业务逻辑，在驱动App和支撑模块化架构起了重大作用。 在这个新的架构中，数据流动是单向的。Data数据流从service服务流到Model Stream生成Model流。Model流再从Model Stream流动到Interactor关联器。Interactor关联器，scheduler调度器，远程推送都可以想Service触发变化来引起Model Stream的改动。Model Stream生成不可改动的models。这个强制的要求就导致关联器只能通过Service层改变App的状态。 举两个例子： 数据从后台到视图View上 一个状态的改变，引起服务器后台触发推送到App。数据就被Push到App，然后生成不可变的数据流。关联器收到model之后，把它传递给展示器Presenter。展示器Presenter把model转换成view model传递给视图View。 数据从视图到服务器后台 当用户点击了一个按钮，比如登录按钮。视图View就会触发UI事件传递给展示器Presenter。展示器Presenter调用关联器Interactor登录方法。关联器Interactor又会调用Service call的实际登录方法。请求网络之后会把数据pull到后台服务器。 Riblet间的数据流 当一个关联器Interactor在处理业务逻辑的工程中，需要调用其他Riblet的事件的时候，关联器Interactor需要和子关联器Interactor进行关联。见上图5个步骤。 如果调用方法是从子调用父类，父类的Interactor的接口通常被定义成监听者listener。如果调用方法是从父类调用到子类，那么子类的接口通常是一个delegate，实现父类的一些Protocol。 在Riblet的方案中，路由Router仅仅只是用来维护一个树型关系，而关联器Interactor才担当的是用来决定触发组件间的逻辑跳转的角色。 各个方案对比 APP间跳转 URL Scheme方式 Universal Link方式 APP内路由跳转 URLRoute注册 Protocol-Class 注册 Target-Action 经过上面的分析，可以发现，路由的设计思路是从URLRoute -&gt;Protocol-class -&gt;Target-Action一步步的深入的过程。这也是逐渐深入本质的过程。 1. URLRoute注册方案的优缺点 首先URLRoute也许是借鉴前端Router和系统App内跳转的方式想出来的方法。它通过URL来请求资源。不管是H5，RN，Weex，iOS界面或者组件请求资源的方式就都统一了。URL里面也会带上参数，这样调用什么界面或者组件都可以。所以这种方式是最容易，也是最先可以想到的。 URLRoute的优点很多，最大的优点就是服务器可以动态的控制页面跳转，可以统一处理页面出问题之后的错误处理，可以统一三端，iOS，Android，H5 / RN / Weex 的请求方式。 但是这种方式也需要看不同公司的需求。如果公司里面已经完成了服务器端动态下发的脚手架工具，前端也完成了Native端如果出现错误了，可以随时替换相同业务界面的需求，那么这个时候可能选择URLRoute的几率会更大。 但是如果公司里面H5没有做相关出现问题后能替换的界面，H5开发人员觉得这是给他们增添负担。如果公司也没有完成服务器动态下发路由规则的那套系统，那么公司可能就不会采用URLRoute的方式。因为URLRoute带来的少量动态性，公司是可以用JSPatch来做到。线上出现bug了，可以立即用JSPatch修掉，而不采用URLRoute去做。 所以选择URLRoute这种方案，也要看公司的发展情况和人员分配，技术选型方面。 URLRoute方案也是存在一些缺点的，首先URL的map规则是需要注册的，它们会在load方法里面写。写在load方法里面是会影响App启动速度的。 其次是大量的硬编码。URL链接里面关于组件和页面的名字都是硬编码，参数也都是硬编码。而且每个URL参数字段都必须要一个文档进行维护，这个对于业务开发人员也是一个负担。而且URL短连接散落在整个App四处，维护起来实在有点麻烦，虽然蘑菇街想到了用宏统一管理这些链接，但是还是解决不了硬编码的问题。 真正一个好的路由是在无形当中服务整个App的，是一个无感知的过程，从这一点来说，略有点缺失。 最后一个缺点是，对于传递NSObject的参数，URL是不够友好的，它最多是传递一个字典。 2. Protocol-Class注册方案的优缺点 Protocol-Class方案的优点，这个方案没有硬编码。 Protocol-Class方案也是存在一些缺点的，每个Protocol都要向ModuleManager进行注册。 这种方案ModuleEntry是同时需要依赖ModuleManager和组件里面的页面或者组件两者的。当然ModuleEntry也是会依赖ModuleEntryProtocol的，但是这个依赖是可以去掉的，比如用Runtime的方法NSProtocolFromString，加上硬编码是可以去掉对Protocol的依赖的。但是考虑到硬编码的方式对出现bug，后期维护都是不友好的，所以对Protocol的依赖还是不要去除。 最后一个缺点是组件方法的调用是分散在各处的，没有统一的入口，也就没法做组件不存在时或者出现错误时的统一处理。 3. Target-Action方案的优缺点 Target-Action方案的优点，充分的利用Runtime的特性，无需注册这一步。Target-Action方案只有存在组件依赖Mediator这一层依赖关系。在Mediator中维护针对Mediator的Category，每个category对应一个Target，Categroy中的方法对应Action场景。Target-Action方案也统一了所有组件间调用入口。 Target-Action方案也能有一定的安全保证，它对url中进行Native前缀进行验证。 Target-Action方案的缺点，Target_Action在Category中将常规参数打包成字典，在Target处再把字典拆包成常规参数，这就造成了一部分的硬编码。","link":"/back/%E8%B7%AF%E7%94%B1.html"},{"title":"路由","text":"APP 内组件路由设计 APP内部主要为了解决两个问题 1. 各个页面和组件之间的跳转问题 2. 各个组件之间的相互调用. 各个页面和组件之间的跳转问题 屏幕快照 2018-02-27 下午4.11.24 在iOS开发的过程中，经常会遇到以下的场景，点击按钮跳转Push到另外一个界面，或者点击一个cell Present一个新的ViewController。在MVC模式中，一般都是新建一个VC，然后Push / Present到下一个VC。但是在MVVM中，会有一些不合适的情况。 40_17 众所周知，MVVM把MVC拆成了上图演示的样子，原来View对应的与数据相关的代码都移到ViewModel中，相应的C也变瘦了，演变成了M-VM-C-V的结构。这里的C里面的代码可以只剩下页面跳转相关的逻辑。如果用代码表示就是下面这样子： 假设一个按钮的执行逻辑都封装成了command。 123456 @weakify(self); [[[_viewModel.someCommand executionSignals] flatten] subscribeNext:^(id x) { @strongify(self); // 跳转逻辑 [self.navigationController pushViewController:targetViewController animated:YES];}]; MVVM框架的目的除去解耦以外，还有2个很重要的目的： 代码复用率高 方便进行单元测试 如果需要测试一个业务是否正确，我们只要对ViewModel进行单元测试即可。前提是假定我们使用ReactiveCocoa进行UI绑定的过程是准确无误的。目前绑定是正确的。所以我们只需要单元测试到ViewModel即可完成业务逻辑的测试。 页面跳转也属于业务逻辑，所以应该放在ViewModel中一起单元测试，保证业务逻辑测试的覆盖率。 把页面跳转放到ViewModel中，有2种做法，第一种就是用路由来实现，第二种由于和路由没有关系，所以这里就不多阐述，有兴趣的可以看lpd-mvvm-kit这个库关于页面跳转的具体实现。 页面跳转相互的耦合性也就体现出来了： 由于pushViewController或者presentViewController，后面都需要带一个待操作的ViewController，那么就必须要引入该类，import头文件也就引入了耦合性。 由于跳转这里写死了跳转操作，如果线上一旦出现了bug，这里是不受我们控制的。 推送消息或者是3D-Touch需求，要求直接跳转到内部第10级界面，那么就需要写一个入口跳转到指定界面。 各个组件之间的相互调用 屏幕快照 2018-02-27 下午4.24.18 关于组件间的调用，也需要解耦。随着业务越来越复杂，我们封装的组件越来越多，要是封装的粒度拿捏不准，就会出现大量组件之间耦合度高的问题。组件的粒度可以随着业务的调整，不断的调整组件职责的划分。但是组件之间的调用依旧不可避免，相互调用对方组件暴露的接口。如何减少各个组件之间的耦合度，是一个设计优秀的路由的职责所在。 如何设计一个路由 方案调研 JLRoutes JLRoutes 使用 URL Scheme 的方式，将所有的资源看成是一个URL。 JLRoutes 将传入的 URL Scheme 按照上面的样子进行分割，并获取NSURLComponent JLRoutes全局会保存一个Map，这个Map会以scheme为Key，JLRoutes为Value。所以在routeControllerMap里面每个scheme都是唯一的。 在每个JLRoutes里面都保存了一个数组，这个数组里面保存了每个路由规则JLRRouteDefinition里面会保存外部传进来的block闭包，pattern，和拆分之后的pattern。 在每个JLRoutes的数组里面，会按照路由的优先级进行排列，优先级高的排列在前面。 123456789101112131415161718192021222324252627- (void)_registerRoute:(NSString *)routePattern priority:(NSUInteger)priority handler:(BOOL (^)(NSDictionary *parameters))handlerBlock{ JLRRouteDefinition *route = [[JLRRouteDefinition alloc] initWithScheme:self.scheme pattern:routePattern priority:priority handlerBlock:handlerBlock]; if (priority == 0 || self.routes.count == 0) { [self.routes addObject:route]; } else { NSUInteger index = 0; BOOL addedRoute = NO; // 找到当前已经存在的一条优先级比当前待插入的路由低的路由 for (JLRRouteDefinition *existingRoute in [self.routes copy]) { if (existingRoute.priority &lt; priority) { // 如果找到，就插入数组 [self.routes insertObject:route atIndex:index]; addedRoute = YES; break; } index++; } // 如果没有找到任何一条路由比当前待插入的路由低的路由，或者最后一条路由优先级和当前路由一样，那么就只能插入到最后。 if (!addedRoute) { [self.routes addObject:route]; } }} 由于这个数组里面的路由是一个单调队列，所以查找优先级的时候只用从高往低遍历即可。 具体查找路由的过程如下 首先根据外部传进来的URL初始化一个JLRRouteRequest，然后用这个JLRRouteRequest在当前的路由数组里面依次request，每个规则都会生成一个response，但是只有符合条件的response才会match，最后取出匹配的JLRRouteResponse拿出其字典parameters里面对应的参数就可以了。查找和匹配过程中重要的代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859- (BOOL)_routeURL:(NSURL *)URL withParameters:(NSDictionary *)parameters executeRouteBlock:(BOOL)executeRouteBlock{ if (!URL) { return NO; } [self _verboseLog:@&quot;Trying to route URL %@&quot;, URL]; BOOL didRoute = NO; JLRRouteRequest *request = [[JLRRouteRequest alloc] initWithURL:URL]; for (JLRRouteDefinition *route in [self.routes copy]) { // 检查每一个route，生成对应的response JLRRouteResponse *response = [route routeResponseForRequest:request decodePlusSymbols:shouldDecodePlusSymbols]; if (!response.isMatch) { continue; } [self _verboseLog:@&quot;Successfully matched %@&quot;, route]; if (!executeRouteBlock) { // 如果我们被要求不允许执行，但是又找了匹配的路由response。 return YES; } // 装配最后的参数 NSMutableDictionary *finalParameters = [NSMutableDictionary dictionary]; [finalParameters addEntriesFromDictionary:response.parameters]; [finalParameters addEntriesFromDictionary:parameters]; [self _verboseLog:@&quot;Final parameters are %@&quot;, finalParameters]; didRoute = [route callHandlerBlockWithParameters:finalParameters]; if (didRoute) { // 调用Handler成功 break; } } if (!didRoute) { [self _verboseLog:@&quot;Could not find a matching route&quot;]; } // 如果在当前路由规则里面没有找到匹配的路由，当前路由不是global 的，并且允许降级到global里面去查找，那么我们继续在global的路由规则里面去查找。 if (!didRoute &amp;&amp; self.shouldFallbackToGlobalRoutes &amp;&amp; ![self _isGlobalRoutesController]) { [self _verboseLog:@&quot;Falling back to global routes...&quot;]; didRoute = [[JLRoutes globalRoutes] _routeURL:URL withParameters:parameters executeRouteBlock:executeRouteBlock]; } // 最后，依旧没有找到任何能匹配的，如果有unmatched URL handler，调用这个闭包进行最后的处理。if, after everything, we did not route anything and we have an unmatched URL handler, then call it if (!didRoute &amp;&amp; executeRouteBlock &amp;&amp; self.unmatchedURLHandler) { [self _verboseLog:@&quot;Falling back to the unmatched URL handler&quot;]; self.unmatchedURLHandler(self, URL, parameters); } return didRoute;} 举个例子 先注册一个Router，规则如下: 123456[[JLRoutes globalRoutes] addRoute:@&quot;/:object/:action&quot; handler:^BOOL(NSDictionary *parameters) { NSString *object = parameters[@&quot;object&quot;]; NSString *action = parameters[@&quot;action&quot;]; // stuff return YES;}]; 传入一个URL， 让 Route 处理 12NSURL *editPost = [NSURL URLWithString:@&quot;ele://post/halfrost?debug=true&amp;foo=bar&quot;]; [[UIApplication sharedApplication] openURL:editPost]; 匹配之后，得到如下的字典 123456789{ &quot;object&quot;: &quot;post&quot;, &quot;action&quot;: &quot;halfrost&quot;, &quot;debug&quot;: &quot;true&quot;, &quot;foo&quot;: &quot;bar&quot;, &quot;JLRouteURL&quot;: &quot;ele://post/halfrost?debug=true&amp;foo=bar&quot;, &quot;JLRoutePattern&quot;: &quot;/:object/:action&quot;, &quot;JLRouteScheme&quot;: &quot;JLRoutesGlobalRoutesScheme&quot;} 详细过程 JLRoutes还可以支持Optional的路由规则，假如定义一条路由规则： Swift/the(/foo/:a)(/bar/:b) JLRoutes 会帮我们默认注册如下4条路由规则： 1234/the/foo/:a/bar/:b/the/foo/:a/the/bar/:b/the routable-ios Routable路由是用在in-app native端的 URL router, 它可以用在iOS上也可以用在 Android UPRouter里面保存了2个字典。 routes字典里面存储的Key是路由规则，Value存储的是UPRouterOptions。 cachedRoutes里面存储的Key是最终的URL，带传参的，Value存储的是RouterParams。RouterParams里面会包含在routes匹配的到的UPRouterOptions，还有额外的打开参数openParams和一些额外参数extraParams。 这一段代码里面重点在干一件事情，遍历routes字典，然后找到参数匹配的字符串，封装成RouterParams返回。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849- (RouterParams *)routerParamsForUrl:(NSString *)url extraParams: (NSDictionary *)extraParams { if (!url) { //if we wait, caching this as key would throw an exception if (_ignoresExceptions) { return nil; } @throw [NSException exceptionWithName:@&quot;RouteNotFoundException&quot; reason:[NSString stringWithFormat:ROUTE_NOT_FOUND_FORMAT, url] userInfo:nil]; } if ([self.cachedRoutes objectForKey:url] &amp;&amp; !extraParams) { return [self.cachedRoutes objectForKey:url]; } // 比对url通过/分割之后的参数个数和pathComponents的个数是否一样 NSArray *givenParts = url.pathComponents; NSArray *legacyParts = [url componentsSeparatedByString:@&quot;/&quot;]; if ([legacyParts count] != [givenParts count]) { NSLog(@&quot;Routable Warning - your URL %@ has empty path components - this will throw an error in an upcoming release&quot;, url); givenParts = legacyParts; } __block RouterParams *openParams = nil; [self.routes enumerateKeysAndObjectsUsingBlock: ^(NSString *routerUrl, UPRouterOptions *routerOptions, BOOL *stop) { NSArray *routerParts = [routerUrl pathComponents]; if ([routerParts count] == [givenParts count]) { NSDictionary *givenParams = [self paramsForUrlComponents:givenParts routerUrlComponents:routerParts]; if (givenParams) { openParams = [[RouterParams alloc] initWithRouterOptions:routerOptions openParams:givenParams extraParams: extraParams]; *stop = YES; } } }]; if (!openParams) { if (_ignoresExceptions) { return nil; } @throw [NSException exceptionWithName:@&quot;RouteNotFoundException&quot; reason:[NSString stringWithFormat:ROUTE_NOT_FOUND_FORMAT, url] userInfo:nil]; } [self.cachedRoutes setObject:openParams forKey:url]; return openParams;} 下面这段函数，第一个参数是外部传进来URL带有各个入参的分割数组。第二个参数是路由规则分割开的数组。routerComponent由于规定：号后面才是参数，所以routerComponent的第1个位置就是对应的参数名。params字典里面以参数名为Key，参数为Value。 123456789101112131415161718- (NSDictionary *)paramsForUrlComponents:(NSArray *)givenUrlComponents routerUrlComponents:(NSArray *)routerUrlComponents { __block NSMutableDictionary *params = [NSMutableDictionary dictionary]; [routerUrlComponents enumerateObjectsUsingBlock: ^(NSString *routerComponent, NSUInteger idx, BOOL *stop) { NSString *givenComponent = givenUrlComponents[idx]; if ([routerComponent hasPrefix:@&quot;:&quot;]) { NSString *key = [routerComponent substringFromIndex:1]; [params setObject:givenComponent forKey:key]; } else if (![routerComponent isEqualToString:givenComponent]) { params = nil; *stop = YES; } }]; return params;} 通过RouterParams的初始化方法，把路由规则对应的UPRouterOptions，上一步封装好的参数字典givenParams，还有 routerParamsForUrl: extraParams: 方法的第二个入参，这3个参数作为初始化参数，生成了一个RouterParams 12345 NSDictionary *givenParams = [self paramsForUrlComponents:givenParts routerUrlComponents:routerParts];if (givenParams) { openParams = [[RouterParams alloc] initWithRouterOptions:routerOptions openParams:givenParams extraParams: extraParams]; *stop = YES;} 最后一步self.cachedRoutes的字典里面Key为带参数的URL，Value是RouterParams。 1[self.cachedRoutes setObject:openParams forKey:url]; 最后将匹配封装出来的RouterParams转换成对应的Controller。 123456789101112131415161718192021222324252627- (UIViewController *)controllerForRouterParams:(RouterParams *)params { SEL CONTROLLER_CLASS_SELECTOR = sel_registerName(&quot;allocWithRouterParams:&quot;); SEL CONTROLLER_SELECTOR = sel_registerName(&quot;initWithRouterParams:&quot;); UIViewController *controller = nil; Class controllerClass = params.routerOptions.openClass;#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; if ([controllerClass respondsToSelector:CONTROLLER_CLASS_SELECTOR]) { controller = [controllerClass performSelector:CONTROLLER_CLASS_SELECTOR withObject:[params controllerParams]]; } else if ([params.routerOptions.openClass instancesRespondToSelector:CONTROLLER_SELECTOR]) { controller = [[params.routerOptions.openClass alloc] performSelector:CONTROLLER_SELECTOR withObject:[params controllerParams]]; }#pragma clang diagnostic pop if (!controller) { if (_ignoresExceptions) { return controller; } @throw [NSException exceptionWithName:@&quot;RoutableInitializerNotFound&quot; reason:[NSString stringWithFormat:INVALID_CONTROLLER_FORMAT, NSStringFromClass(controllerClass), NSStringFromSelector(CONTROLLER_CLASS_SELECTOR), NSStringFromSelector(CONTROLLER_SELECTOR)] userInfo:nil]; } controller.modalTransitionStyle = params.routerOptions.transitionStyle; controller.modalPresentationStyle = params.routerOptions.presentationStyle; return controller;} 如果Controller是一个类，那么就调用allocWithRouterParams:方法去初始化。如果Controller已经是一个实例了，那么就调用initWithRouterParams:方法去初始化。 将Routable的大致流程图解如下： HHRouter ViewController提供了2个方法。map是用来设置路由规则，matchController是用来匹配路由规则的，匹配争取之后返回对应的UIViewController。 12- (void)map:(NSString *)route toControllerClass:(Class)controllerClass;- (UIViewController *)matchController:(NSString *)route; block闭包提供了三个方法，map也是设置路由规则，matchBlock：是用来匹配路由，找到指定的block，但是不会调用该block。callBlock:是找到指定的block，找到以后就立即调用。 1234- (void)map:(NSString *)route toBlock:(HHRouterBlock)block;- (HHRouterBlock)matchBlock:(NSString *)route;- (id)callBlock:(NSString *)route; matchBlock:和callBlock:的区别就在于前者不会自动调用闭包。所以matchBlock:方法找到对应的block之后，如果想调用，需要手动调用一次。 除去上面这些方法，HHRouter还为我们提供了一个特殊的方法。 1- (HHRouteType)canRoute:(NSString *)route; 这个方法就是用来找到执行路由规则对应的RouteType，RouteType总共就3种: 12345typedef NS_ENUM (NSInteger, HHRouteType) { HHRouteTypeNone = 0, HHRouteTypeViewController = 1, HHRouteTypeBlock = 2}; 再来看看HHRouter是如何管理路由规则的。整个HHRouter就是由一个NSMutableDictionary *routes控制的。 123@interface HHRouter ()@property (strong, nonatomic) NSMutableDictionary *routes;@end 别看只有这一个看似“简单”的字典数据结构，但是HHRouter路由设计的还是很精妙的。 1234567891011- (void)map:(NSString *)route toBlock:(HHRouterBlock)block{ NSMutableDictionary *subRoutes = [self subRoutesToRoute:route]; subRoutes[@&quot;_&quot;] = [block copy];}- (void)map:(NSString *)route toControllerClass:(Class)controllerClass{ NSMutableDictionary *subRoutes = [self subRoutesToRoute:route]; subRoutes[@&quot;_&quot;] = controllerClass;} 上面两个方法分别是block闭包和ViewController设置路由规则调用的方法实体。不管是ViewController还是block闭包，设置规则的时候都会调用subRoutesToRoute:方法。 123456789101112131415161718- (NSMutableDictionary *)subRoutesToRoute:(NSString *)route{ NSArray *pathComponents = [self pathComponentsFromRoute:route]; NSInteger index = 0; NSMutableDictionary *subRoutes = self.routes; while (index &lt; pathComponents.count) { NSString *pathComponent = pathComponents[index]; if (![subRoutes objectForKey:pathComponent]) { subRoutes[pathComponent] = [[NSMutableDictionary alloc] init]; } subRoutes = subRoutes[pathComponent]; index++; } return subRoutes;} 上面这段函数就是来构造路由匹配规则的字典。 举个例子： 123456[[HHRouter shared] map:@&quot;/user/:userId/&quot; toControllerClass:[UserViewController class]];[[HHRouter shared] map:@&quot;/story/:storyId/&quot; toControllerClass:[StoryViewController class]];[[HHRouter shared] map:@&quot;/user/:userId/story/?a=0&quot; toControllerClass:[StoryListViewController class]]; 设置3条规则以后，按照上面构造路由匹配规则的字典的方法，该路由规则字典就会变成这个样子： 123456789101112131415{ story = { &quot;:storyId&quot; = { &quot;_&quot; = StoryViewController; }; }; user = { &quot;:userId&quot; = { &quot;_&quot; = UserViewController; story = { &quot;_&quot; = StoryListViewController; }; }; };} 路由规则字典生成之后，等到匹配的时候就会遍历这个字典。 假设这时候有一条路由过来： 1[[[HHRouter shared] matchController:@&quot;hhrouter20://user/1/&quot;] class], HHRouter对这条路由的处理方式是先匹配前面的scheme，如果连scheme都不正确的话，会直接导致后面匹配失败。 然后再进行路由匹配，最后生成的参数字典如下： 12345{ &quot;controller_class&quot; = UserViewController; route = &quot;/user/1/&quot;; userId = 1;} 具体的路由参数匹配的函数在 1- (NSDictionary *)paramsInRoute:(NSString *)route 个方法里面实现的。这个方法就是按照路由匹配规则，把传进来的URL的参数都一一解析出来，带？号的也都会解析成字典。这个方法没什么难度，就不在赘述了。 ViewController 的字典里面默认还会加上2项： 12&quot;controller_class&quot; = route = route里面都会保存传过来的完整的URL。 如果传进来的路由后面带访问字符串呢？那我们再来看看： 1[[HHRouter shared] matchController:@&quot;/user/1/?a=b&amp;c=d&quot;] 那么解析出所有的参数字典会是下面的样子： 1234567{ a = b; c = d; &quot;controller_class&quot; = UserViewController; route = &quot;/user/1/?a=b&amp;c=d&quot;; userId = 1;} 同理，如果是一个block闭包的情况呢？ 还是先添加一条block闭包的路由规则： 12[[HHRouter shared] map:@&quot;/user/add/&quot; toBlock:^id(NSDictionary* params) {}]; 这条规则对应的会生成一个路由规则的字典。 123456789101112131415161718{ story = { &quot;:storyId&quot; = { &quot;_&quot; = StoryViewController; }; }; user = { &quot;:userId&quot; = { &quot;_&quot; = UserViewController; story = { &quot;_&quot; = StoryListViewController; }; }; add = { &quot;_&quot; = &quot;&lt;__NSMallocBlock__: 0x600000240480&gt;&quot;; }; };} 注意”_”后面跟着是一个block。 匹配block闭包的方式有两种。 1234567// 1.第一种方式匹配到对应的block之后，还需要手动调用一次闭包。 HHRouterBlock block = [[HHRouter shared] matchBlock:@&quot;/user/add/?a=1&amp;b=2&quot;]; block(nil);// 2.第二种方式匹配block之后自动会调用改闭包。 [[HHRouter shared] callBlock:@&quot;/user/add/?a=1&amp;b=2&quot;]; 匹配出来的参数字典是如下： 123456{ a = 1; b = 2; block = &quot;&lt;__NSMallocBlock__: 0x600000056b90&gt;&quot;; route = &quot;/user/add/?a=1&amp;b=2&quot;;} block的字典里面会默认加上下面这2项： 12block = route = route里面都会保存传过来的完整的URL。 生成的参数字典最终会被绑定到ViewController的Associated Object关联对象上。 123456789- (void)setParams:(NSDictionary *)paramsDictionary{ objc_setAssociatedObject(self, &amp;kAssociatedParamsObjectKey, paramsDictionary, OBJC_ASSOCIATION_RETAIN_NONATOMIC);}- (NSDictionary *)params{ return objc_getAssociatedObject(self, &amp;kAssociatedParamsObjectKey);} 这个绑定的过程是在match匹配完成的时候进行的。 12345678910111213- (UIViewController *)matchController:(NSString *)route{ NSDictionary *params = [self paramsInRoute:route]; Class controllerClass = params[@&quot;controller_class&quot;]; UIViewController *viewController = [[controllerClass alloc] init]; if ([viewController respondsToSelector:@selector(setParams:)]) { [viewController performSelector:@selector(setParams:) withObject:[params copy]]; } return viewController;} 最终得到的ViewController也是我们想要的。相应的参数都在它绑定的params属性的字典里面。 将上述过程图解出来，如下： MGJRouter JLRoutes 的问题主要在于查找 URL 的实现不够高效，通过遍历而不是匹配。还有就是功能偏多。 HHRouter 的 URL 查找是基于匹配，所以会更高效，MGJRouter 也是采用的这种方法，但它跟 ViewController 绑定地过于紧密，一定程度上降低了灵活性。 于是就有了 MGJRouter。 从数据结构来看，MGJRouter还是和HHRouter一模一样的 123@interface MGJRouter ()@property (nonatomic) NSMutableDictionary *routes;@end 那么我们就来看看它对HHRouter做了哪些优化改进。 1.MGJRouter支持openURL时，可以传一些 userinfo 过去 1[MGJRouter openURL:@&quot;mgj://category/travel&quot; withUserInfo:@{@&quot;user_id&quot;: @1900} completion:nil]; 这个对比HHRouter，仅仅只是写法上的一个语法糖，在HHRouter中虽然不支持带字典的参数，但是在URL后面可以用URL Query Parameter来弥补。 12345678910111213if (parameters) { MGJRouterHandler handler = parameters[@&quot;block&quot;]; if (completion) { parameters[MGJRouterParameterCompletion] = completion; } if (userInfo) { parameters[MGJRouterParameterUserInfo] = userInfo; } if (handler) { [parameters removeObjectForKey:@&quot;block&quot;]; handler(parameters); } } MGJRouter对userInfo的处理是直接把它封装到Key = MGJRouterParameterUserInfo对应的Value里面。 2.支持中文的URL。 12345[parameters enumerateKeysAndObjectsUsingBlock:^(id key, NSString *obj, BOOL *stop) { if ([obj isKindOfClass:[NSString class]]) { parameters[key] = [obj stringByReplacingPercentEscapesUsingEncoding:NSUTF8StringEncoding]; } }]; 这里就是需要注意一下编码。 3.定义一个全局的 URL Pattern 作为 Fallback。 这一点是模仿的JLRoutes的匹配不到会自动降级到global的思想。 1234567if (parameters) { MGJRouterHandler handler = parameters[@&quot;block&quot;]; if (handler) { [parameters removeObjectForKey:@&quot;block&quot;]; handler(parameters); } } parameters字典里面会先存储下一个路由规则，存在block闭包中，在匹配的时候会取出这个handler，降级匹配到这个闭包中，进行最终的处理。 4.当 OpenURL 结束时，可以执行 Completion Block。 在MGJRouter里面，作者对原来的HHRouter字典里面存储的路由规则的结构进行了改造。 123NSString *const MGJRouterParameterURL = @&quot;MGJRouterParameterURL&quot;; NSString *const MGJRouterParameterCompletion = @&quot;MGJRouterParameterCompletion&quot;; NSString *const MGJRouterParameterUserInfo = @&quot;MGJRouterParameterUserInfo&quot;; 这3个key会分别保存一些信息： MGJRouterParameterURL保存的传进来的完整的URL信息。 MGJRouterParameterCompletion保存的是completion闭包。 MGJRouterParameterUserInfo保存的是UserInfo字典。 举个例子： 12345678910[MGJRouter registerURLPattern:@&quot;ele://name/:name&quot; toHandler:^(NSDictionary *routerParameters) { void (^completion)(NSString *) = routerParameters[MGJRouterParameterCompletion]; if (completion) { completion(@&quot;完成了&quot;); } }]; [MGJRouter openURL:@&quot;ele://name/halfrost/?age=20&quot; withUserInfo:@{@&quot;user_id&quot;: @1900} completion:^(id result) { NSLog(@&quot;result = %@&quot;,result); }]; 上面的URL会匹配成功，那么生成的参数字典结构如下： 12345678910{ MGJRouterParameterCompletion = &quot;&lt;__NSGlobalBlock__: 0x107ffe680&gt;&quot;; MGJRouterParameterURL = &quot;ele://name/halfrost/?age=20&quot;; MGJRouterParameterUserInfo = { &quot;user_id&quot; = 1900; }; age = 20; block = &quot;&lt;__NSMallocBlock__: 0x608000252120&gt;&quot;; name = halfrost;} 5.可以统一管理URL 这个功能非常有用。 URL 的处理一不小心，就容易散落在项目的各个角落，不容易管理。比如注册时的 pattern 是 mgj://beauty/:id，然后 open 时就是 mgj://beauty/123，这样到时候 url 有改动，处理起来就会很麻烦，不好统一管理。 所以 MGJRouter 提供了一个类方法来处理这个问题。 12345678#define TEMPLATE_URL @&quot;qq://name/:name&quot;[MGJRouter registerURLPattern:TEMPLATE_URL toHandler:^(NSDictionary *routerParameters) { NSLog(@&quot;routerParameters[name]:%@&quot;, routerParameters[@&quot;name&quot;]); // halfrost}];[MGJRouter openURL:[MGJRouter generateURLWithPattern:TEMPLATE_URL parameters:@[@&quot;halfrost&quot;]]];} generateURLWithPattern:函数会对我们定义的宏里面的所有的:进行替换，替换成后面的字符串数组，依次赋值。 将上述过程图解出来，如下： 蘑菇街为了区分开页面间调用和组件间调用，于是想出了一种新的方法。用Protocol的方法来进行组件间的调用。 每个组件之间都有一个 Entry，这个 Entry，主要做了三件事： 注册这个组件关心的 URL 注册这个组件能够被调用的方法/属性 在 App 生命周期的不同阶段做不同的响应 页面间的openURL调用就是如下的样子： 每个组件间都会向MGJRouter注册，组件间相互调用或者是其他的App都可以通过openURL:方法打开一个界面或者调用一个组件。 在组件间的调用，蘑菇街采用了Protocol的方式。 [ModuleManager registerClass:ClassA forProtocol:ProtocolA] 的结果就是在 MM 内部维护的 dict 里新加了一个映射关系。 [ModuleManager classForProtocol:ProtocolA] 的返回结果就是之前在 MM 内部 dict 里 protocol 对应的 class，使用方不需要关心这个 class 是个什么东东，反正实现了 ProtocolA 协议，拿来用就行。 这里需要有一个公共的地方来容纳这些 public protocl，也就是图中的 PublicProtocl.h。 我猜测，大概实现可能是下面的样子： 123456@interface ModuleProtocolManager : NSObject+ (void)registServiceProvide:(id)provide forProtocol:(Protocol*)protocol;+ (id)serviceProvideForProtocol:(Protocol *)protocol;@end 然后这是一个单例，在这里注册各个协议 12345678910111213141516171819202122232425262728293031323334353637@interface ModuleProtocolManager ()@property (nonatomic, strong) NSMutableDictionary *serviceProvideSource;@end@implementation ModuleProtocolManager+ (ModuleProtocolManager *)sharedInstance{ static ModuleProtocolManager * instance; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^{ instance = [[self alloc] init]; }); return instance;}- (instancetype)init{ self = [super init]; if (self) { _serviceProvideSource = [[NSMutableDictionary alloc] init]; } return self;}+ (void)registServiceProvide:(id)provide forProtocol:(Protocol*)protocol{ if (provide == nil || protocol == nil) return; [[self sharedInstance].serviceProvideSource setObject:provide forKey:NSStringFromProtocol(protocol)];}+ (id)serviceProvideForProtocol:(Protocol *)protocol{ return [[self sharedInstance].serviceProvideSource objectForKey:NSStringFromProtocol(protocol)];} 在ModuleProtocolManager中用一个字典保存每个注册的protocol。现在再来猜猜ModuleEntry的实现。 12345678#import &lt;Foundation/Foundation.h&gt;#import &lt;UIKit/UIKit.h&gt;@protocol DetailModuleEntryProtocol &lt;NSObject&gt;@required;- (UIViewController *)detailViewControllerWithId:(NSString*)Id Name:(NSString *)name;@end 然后每个模块内都有一个和暴露到外面的协议相连接的“接头”。 1234#import &lt;Foundation/Foundation.h&gt;@interface DetailModuleEntry : NSObject@end 在它的实现中，需要引入3个外部文件，一个是ModuleProtocolManager，一个是DetailModuleEntryProtocol，最后一个是所在模块需要跳转或者调用的组件或者页面。 123456789101112131415161718192021222324#import &quot;DetailModuleEntry.h&quot;#import &lt;DetailModuleEntryProtocol/DetailModuleEntryProtocol.h&gt;#import &lt;ModuleProtocolManager/ModuleProtocolManager.h&gt;#import &quot;DetailViewController.h&quot;@interface DetailModuleEntry()&lt;DetailModuleEntryProtocol&gt;@end@implementation DetailModuleEntry+ (void)load{ [ModuleProtocolManager registServiceProvide:[[self alloc] init] forProtocol:@protocol(DetailModuleEntryProtocol)];}- (UIViewController *)detailViewControllerWithId:(NSString*)Id Name:(NSString *)name{ DetailViewController *detailVC = [[DetailViewController alloc] initWithId:id Name:name]; return detailVC;}@end 至此基于Protocol的方案就完成了。如果需要调用某个组件或者跳转某个页面，只要先从ModuleProtocolManager的字典里面根据对应的ModuleEntryProtocol找到对应的DetailModuleEntry，找到了DetailModuleEntry就是找到了组件或者页面的“入口”了。再把参数传进去即可。 1234567- (void)didClickDetailButton:(UIButton *)button{ id&lt; DetailModuleEntryProtocol &gt; DetailModuleEntry = [ModuleProtocolManager serviceProvideForProtocol:@protocol(DetailModuleEntryProtocol)]; UIViewController *detailVC = [DetailModuleEntry detailViewControllerWithId:@“详情界面” Name:@“我的购物车”]; [self.navigationController pushViewController:detailVC animated:YES];} 这样就可以调用到组件或者界面了。 如果组件之间有相同的接口，那么还可以进一步的把这些接口都抽离出来。这些抽离出来的接口变成“元接口”，它们是可以足够支撑起整个组件一层的。 CTMediator 这方案是基于Mediator的。 传统的中间人Mediator的模式是这样的 这种模式每个页面或者组件都会依赖中间者，各个组件之间互相不再依赖，组件间调用只依赖中间者Mediator，Mediator还是会依赖其他组件。那么这是最终方案了么？ 主要思想是利用了Target-Action简单粗暴的思想，利用Runtime解决解耦的问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354- (id)performTarget:(NSString *)targetName action:(NSString *)actionName params:(NSDictionary *)params shouldCacheTarget:(BOOL)shouldCacheTarget{ NSString *targetClassString = [NSString stringWithFormat:@&quot;Target_%@&quot;, targetName]; NSString *actionString = [NSString stringWithFormat:@&quot;Action_%@:&quot;, actionName]; Class targetClass; NSObject *target = self.cachedTarget[targetClassString]; if (target == nil) { targetClass = NSClassFromString(targetClassString); target = [[targetClass alloc] init]; } SEL action = NSSelectorFromString(actionString); if (target == nil) { // 这里是处理无响应请求的地方之一，这个demo做得比较简单，如果没有可以响应的target，就直接return了。实际开发过程中是可以事先给一个固定的target专门用于在这个时候顶上，然后处理这种请求的 return nil; } if (shouldCacheTarget) { self.cachedTarget[targetClassString] = target; } if ([target respondsToSelector:action]) {#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; return [target performSelector:action withObject:params];#pragma clang diagnostic pop } else { // 有可能target是Swift对象 actionString = [NSString stringWithFormat:@&quot;Action_%@WithParams:&quot;, actionName]; action = NSSelectorFromString(actionString); if ([target respondsToSelector:action]) {#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; return [target performSelector:action withObject:params];#pragma clang diagnostic pop } else { // 这里是处理无响应请求的地方，如果无响应，则尝试调用对应target的notFound方法统一处理 SEL action = NSSelectorFromString(@&quot;notFound:&quot;); if ([target respondsToSelector:action]) {#pragma clang diagnostic push#pragma clang diagnostic ignored &quot;-Warc-performSelector-leaks&quot; return [target performSelector:action withObject:params];#pragma clang diagnostic pop } else { // 这里也是处理无响应请求的地方，在notFound都没有的时候，这个demo是直接return了。实际开发过程中，可以用前面提到的固定的target顶上的。 [self.cachedTarget removeObjectForKey:targetClassString]; return nil; } } }} targetName就是调用接口的Object，actionName就是调用方法的SEL，params是参数，shouldCacheTarget代表是否需要缓存，如果需要缓存就把target存起来，Key是targetClassString，Value是target。 通过这种方式进行改造的，外面调用的方法都很统一，都是调用performTarget: action: params: shouldCacheTarget:。第三个参数是一个字典，这个字典里面可以传很多参数，只要Key-Value写好就可以了。处理错误的方式也统一在一个地方了，target没有，或者是target无法响应相应的方法，都可以在Mediator这里进行统一出错处理。 但是在实际开发过程中，不管是界面调用，组件间调用，在Mediator中需要定义很多方法。于是作者又想出了建议我们用Category的方法，对Mediator的所有方法进行拆分，这样就就可以不会导致Mediator这个类过于庞大了。 123456789101112131415161718192021222324252627282930313233- (UIViewController *)CTMediator_viewControllerForDetail{ UIViewController *viewController = [self performTarget:kCTMediatorTargetA action:kCTMediatorActionNativFetchDetailViewController params:@{@&quot;key&quot;:@&quot;value&quot;} shouldCacheTarget:NO ]; if ([viewController isKindOfClass:[UIViewController class]]) { // view controller 交付出去之后，可以由外界选择是push还是present return viewController; } else { // 这里处理异常场景，具体如何处理取决于产品 return [[UIViewController alloc] init]; }}- (void)CTMediator_presentImage:(UIImage *)image{ if (image) { [self performTarget:kCTMediatorTargetA action:kCTMediatorActionNativePresentImage params:@{@&quot;image&quot;:image} shouldCacheTarget:NO]; } else { // 这里处理image为nil的场景，如何处理取决于产品 [self performTarget:kCTMediatorTargetA action:kCTMediatorActionNativeNoImage params:@{@&quot;image&quot;:[UIImage imageNamed:@&quot;noImage&quot;]} shouldCacheTarget:NO]; }} 把这些具体的方法一个个的都写在Category里面就好了，调用的方式都非常的一致，都是调用performTarget: action: params: shouldCacheTarget:方法。 最终去掉了中间者Mediator对组件的依赖，各个组件之间互相不再依赖，组件间调用只依赖中间者Mediator，Mediator不依赖其他任何组件。 没有开源的解决方案 Uber在发现MVC的一些弊端之后：比如动辄上万行巨胖无比的VC，无法进行单元测试等缺点后，于是考虑把架构换成VIPER。但是VIPER也有一定的弊端。因为它的iOS特定的结构，意味着iOS必须为Android做出一些妥协的权衡。以视图为驱动的应用程序逻辑，代表应用程序状态由视图驱动，整个应用程序都锁定在视图树上。由操作应用程序状态所关联的业务逻辑的改变，就必须经过Presenter。因此会暴露业务逻辑。最终导致了视图树和业务树进行了紧紧的耦合。这样想实现一个紧紧只有业务逻辑的Node节点或者紧紧只有视图逻辑的Node节点就非常的困难了。 通过改进VIPER架构，吸收其优秀的特点，改进其缺点，就形成了Uber 骑手App的全新架构——Riblets(肋骨)。 在这个新的架构中，即使是相似的逻辑也会被区分成很小很小，相互独立，可以单独进行测试的组件。每个组件都有非常明确的用途。使用这些一小块一小块的Riblets(肋骨)，最终把整个App拼接成一颗Riblets(肋骨)树。 通过抽象，一个Riblets(肋骨)被定义成一下6个更小的组件，这些组件各自有各自的职责。通过一个Riblets(肋骨)进一步的抽象业务逻辑和视图逻辑 一个Riblets(肋骨)被设计成这样，那和之前的VIPER和MVC有什么区别呢？最大的区别在路由上面。 Riblets(肋骨)内的Router不再是视图逻辑驱动的，现在变成了业务逻辑驱动。这一重大改变就导致了整个App不再是由表现形式驱动，现在变成了由数据流驱动。 每一个Riblet都是由一个路由Router，一个关联器Interactor，一个构造器Builder和它们相关的组件构成的。所以它的命名（Router - Interactor - Builder，Rib）也由此得来。当然还可以有可选的展示器Presenter和视图View。路由Router和关联器Interactor处理业务逻辑，展示器Presenter和视图View处理视图逻辑。 重点分析一下Riblet里面路由的职责。 路由职责 在整个App的结构树中，路由的职责是用来关联和取消关联其他子Riblet的。至于决定是由关联器Interactor传递过来的。在状态转换过程中，关联和取消关联子Riblet的时候，路由也会影响到关联器Interactor的生命周期。路由只包含2个业务逻辑： 1.提供关联和取消关联其他路由的方法。 2.在多个孩子之间决定最终状态的状态转换逻辑 拼装 每一个Riblets只有一对Router路由和Interactor关联器。但是它们可以有多对视图。Riblets只处理业务逻辑，不处理视图相关的部分。Riblets可以拥有单一的视图（一个Presenter展示器和一个View视图），也可以拥有多个视图（一个Presenter展示器和多个View视图，或者多个Presenter展示器和多个View视图），甚至也可以能没有视图（没有Presenter展示器也没有View视图）。这种设计可以有助于业务逻辑树的构建，也可以和视图树做到很好的分离。 举个例子，骑手的Riblet是一个没有视图的Riblet，它用来检查当前用户是否有一个激活的路线。如果骑手确定了路线，那么这个Riblet就会关联到路线的Riblet上面。路线的Riblet会在地图上显示出路线图。如果没有确定路线，骑手的Riblet就会被关联到请求的Riblet上。请求的Riblet会在屏幕上显示等待被呼叫。像骑手的Riblet这样没有任何视图逻辑的Riblet，它分开了业务逻辑，在驱动App和支撑模块化架构起了重大作用。 在这个新的架构中，数据流动是单向的。Data数据流从service服务流到Model Stream生成Model流。Model流再从Model Stream流动到Interactor关联器。Interactor关联器，scheduler调度器，远程推送都可以想Service触发变化来引起Model Stream的改动。Model Stream生成不可改动的models。这个强制的要求就导致关联器只能通过Service层改变App的状态。 举两个例子： 数据从后台到视图View上 一个状态的改变，引起服务器后台触发推送到App。数据就被Push到App，然后生成不可变的数据流。关联器收到model之后，把它传递给展示器Presenter。展示器Presenter把model转换成view model传递给视图View。 数据从视图到服务器后台 当用户点击了一个按钮，比如登录按钮。视图View就会触发UI事件传递给展示器Presenter。展示器Presenter调用关联器Interactor登录方法。关联器Interactor又会调用Service call的实际登录方法。请求网络之后会把数据pull到后台服务器。 Riblet间的数据流 当一个关联器Interactor在处理业务逻辑的工程中，需要调用其他Riblet的事件的时候，关联器Interactor需要和子关联器Interactor进行关联。见上图5个步骤。 如果调用方法是从子调用父类，父类的Interactor的接口通常被定义成监听者listener。如果调用方法是从父类调用到子类，那么子类的接口通常是一个delegate，实现父类的一些Protocol。 在Riblet的方案中，路由Router仅仅只是用来维护一个树型关系，而关联器Interactor才担当的是用来决定触发组件间的逻辑跳转的角色。 各个方案对比 APP间跳转 URL Scheme方式 Universal Link方式 APP内路由跳转 URLRoute注册 Protocol-Class 注册 Target-Action 经过上面的分析，可以发现，路由的设计思路是从URLRoute -&gt;Protocol-class -&gt;Target-Action一步步的深入的过程。这也是逐渐深入本质的过程。 1. URLRoute注册方案的优缺点 首先URLRoute也许是借鉴前端Router和系统App内跳转的方式想出来的方法。它通过URL来请求资源。不管是H5，RN，We